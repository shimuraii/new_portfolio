(async () => {
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver((i) => {
      for (const s of i) if (s.type === "childList") for (const r of s.addedNodes) r.tagName === "LINK" && r.rel === "modulepreload" && n(r);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function t(i) {
      const s = {};
      return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
    }
    function n(i) {
      if (i.ep) return;
      i.ep = true;
      const s = t(i);
      fetch(i.href, s);
    }
  })();
  const Xa = "149", $i = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
  }, Zi = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
  }, $p = 0, Cc = 1, Zp = 2, Z_ = 3, J_ = 0, gh = 1, vh = 2, Xs = 3, On = 0, on = 1, Dn = 2, Q_ = 2, ii = 0, rs = 1, Ac = 2, Pc = 3, Lc = 4, Jp = 5, Qi = 100, Qp = 101, ef = 102, Rc = 103, Ic = 104, tf = 200, nf = 201, sf = 202, rf = 203, _h = 204, xh = 205, of = 206, af = 207, lf = 208, cf = 209, hf = 210, uf = 0, df = 1, pf = 2, Va = 3, ff = 4, mf = 5, gf = 6, vf = 7, po = 0, _f = 1, xf = 2, kn = 0, bf = 1, yf = 2, wf = 3, bh = 4, Mf = 5, ja = 300, Si = 301, Ei = 302, Jr = 303, Qr = 304, hr = 306, Ti = 1e3, Xt = 1001, er = 1002, Et = 1003, eo = 1004, e0 = 1004, Zs = 1005, t0 = 1005, yt = 1006, Ka = 1007, n0 = 1007, Fn = 1008, i0 = 1008, Ci = 1009, Sf = 1010, Ef = 1011, yh = 1012, Tf = 1013, wi = 1014, ei = 1015, tr = 1016, Cf = 1017, Af = 1018, os = 1020, Pf = 1021, un = 1023, Lf = 1024, Rf = 1025, Mi = 1026, hs = 1027, If = 1028, Df = 1029, kf = 1030, Nf = 1031, Of = 1033, La = 33776, Ra = 33777, Ia = 33778, Da = 33779, Dc = 35840, kc = 35841, Nc = 35842, Oc = 35843, Ff = 36196, Fc = 37492, Bc = 37496, Uc = 37808, zc = 37809, Vc = 37810, Gc = 37811, Hc = 37812, Wc = 37813, qc = 37814, Xc = 37815, jc = 37816, Kc = 37817, Yc = 37818, $c = 37819, Zc = 37820, Jc = 37821, ka = 36492, Bf = 36283, Qc = 36284, eh = 36285, th = 36286, Uf = 2200, zf = 2201, Vf = 2202, nr = 2300, us = 2301, Na = 2302, ts = 2400, ns = 2401, to = 2402, Ya = 2500, wh = 2501, Gf = 0, Mh = 1, Ga = 2, Ai = 3e3, ct = 3001, Hf = 3200, Wf = 3201, Ri = 0, qf = 1, s0 = "", Sn = "srgb", ir = "srgb-linear", r0 = 0, Oa = 7680, o0 = 7681, a0 = 7682, l0 = 7683, c0 = 34055, h0 = 34056, u0 = 5386, d0 = 512, p0 = 513, f0 = 514, m0 = 515, g0 = 516, v0 = 517, _0 = 518, Xf = 519, no = 35044, x0 = 35048, b0 = 35040, y0 = 35045, w0 = 35049, M0 = 35041, S0 = 35046, E0 = 35050, T0 = 35042, C0 = "100", nh = "300 es", Ha = 1035;
  class zn {
    addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      const n = this._listeners;
      n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
    }
    hasEventListener(e, t) {
      if (this._listeners === void 0) return false;
      const n = this._listeners;
      return n[e] !== void 0 && n[e].indexOf(t) !== -1;
    }
    removeEventListener(e, t) {
      if (this._listeners === void 0) return;
      const i = this._listeners[e];
      if (i !== void 0) {
        const s = i.indexOf(t);
        s !== -1 && i.splice(s, 1);
      }
    }
    dispatchEvent(e) {
      if (this._listeners === void 0) return;
      const n = this._listeners[e.type];
      if (n !== void 0) {
        e.target = this;
        const i = n.slice(0);
        for (let s = 0, r = i.length; s < r; s++) i[s].call(this, e);
        e.target = null;
      }
    }
  }
  const Kt = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff"
  ];
  let fd = 1234567;
  const as = Math.PI / 180, io = 180 / Math.PI;
  function dn() {
    const l = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
    return (Kt[l & 255] + Kt[l >> 8 & 255] + Kt[l >> 16 & 255] + Kt[l >> 24 & 255] + "-" + Kt[e & 255] + Kt[e >> 8 & 255] + "-" + Kt[e >> 16 & 15 | 64] + Kt[e >> 24 & 255] + "-" + Kt[t & 63 | 128] + Kt[t >> 8 & 255] + "-" + Kt[t >> 16 & 255] + Kt[t >> 24 & 255] + Kt[n & 255] + Kt[n >> 8 & 255] + Kt[n >> 16 & 255] + Kt[n >> 24 & 255]).toLowerCase();
  }
  function At(l, e, t) {
    return Math.max(e, Math.min(t, l));
  }
  function Sh(l, e) {
    return (l % e + e) % e;
  }
  function A0(l, e, t, n, i) {
    return n + (l - e) * (i - n) / (t - e);
  }
  function P0(l, e, t) {
    return l !== e ? (t - l) / (e - l) : 0;
  }
  function Yr(l, e, t) {
    return (1 - t) * l + t * e;
  }
  function L0(l, e, t, n) {
    return Yr(l, e, 1 - Math.exp(-t * n));
  }
  function R0(l, e = 1) {
    return e - Math.abs(Sh(l, e * 2) - e);
  }
  function I0(l, e, t) {
    return l <= e ? 0 : l >= t ? 1 : (l = (l - e) / (t - e), l * l * (3 - 2 * l));
  }
  function D0(l, e, t) {
    return l <= e ? 0 : l >= t ? 1 : (l = (l - e) / (t - e), l * l * l * (l * (l * 6 - 15) + 10));
  }
  function k0(l, e) {
    return l + Math.floor(Math.random() * (e - l + 1));
  }
  function N0(l, e) {
    return l + Math.random() * (e - l);
  }
  function O0(l) {
    return l * (0.5 - Math.random());
  }
  function F0(l) {
    l !== void 0 && (fd = l);
    let e = fd += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
  }
  function B0(l) {
    return l * as;
  }
  function U0(l) {
    return l * io;
  }
  function ih(l) {
    return (l & l - 1) === 0 && l !== 0;
  }
  function jf(l) {
    return Math.pow(2, Math.ceil(Math.log(l) / Math.LN2));
  }
  function Wa(l) {
    return Math.pow(2, Math.floor(Math.log(l) / Math.LN2));
  }
  function z0(l, e, t, n, i) {
    const s = Math.cos, r = Math.sin, a = s(t / 2), c = r(t / 2), u = s((e + n) / 2), p = r((e + n) / 2), f = s((e - n) / 2), m = r((e - n) / 2), v = s((n - e) / 2), b = r((n - e) / 2);
    switch (i) {
      case "XYX":
        l.set(a * p, c * f, c * m, a * u);
        break;
      case "YZY":
        l.set(c * m, a * p, c * f, a * u);
        break;
      case "ZXZ":
        l.set(c * f, c * m, a * p, a * u);
        break;
      case "XZX":
        l.set(a * p, c * b, c * v, a * u);
        break;
      case "YXY":
        l.set(c * v, a * p, c * b, a * u);
        break;
      case "ZYZ":
        l.set(c * b, c * v, a * p, a * u);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
    }
  }
  function ti(l, e) {
    switch (e.constructor) {
      case Float32Array:
        return l;
      case Uint16Array:
        return l / 65535;
      case Uint8Array:
        return l / 255;
      case Int16Array:
        return Math.max(l / 32767, -1);
      case Int8Array:
        return Math.max(l / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function mt(l, e) {
    switch (e.constructor) {
      case Float32Array:
        return l;
      case Uint16Array:
        return Math.round(l * 65535);
      case Uint8Array:
        return Math.round(l * 255);
      case Int16Array:
        return Math.round(l * 32767);
      case Int8Array:
        return Math.round(l * 127);
      default:
        throw new Error("Invalid component type.");
    }
  }
  var Kf = Object.freeze({
    __proto__: null,
    DEG2RAD: as,
    RAD2DEG: io,
    ceilPowerOfTwo: jf,
    clamp: At,
    damp: L0,
    degToRad: B0,
    denormalize: ti,
    euclideanModulo: Sh,
    floorPowerOfTwo: Wa,
    generateUUID: dn,
    inverseLerp: P0,
    isPowerOfTwo: ih,
    lerp: Yr,
    mapLinear: A0,
    normalize: mt,
    pingpong: R0,
    radToDeg: U0,
    randFloat: N0,
    randFloatSpread: O0,
    randInt: k0,
    seededRandom: F0,
    setQuaternionFromProperEuler: z0,
    smootherstep: D0,
    smoothstep: I0
  });
  class te {
    constructor(e = 0, t = 0) {
      te.prototype.isVector2 = true, this.x = e, this.y = t;
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return this.x = e, this.y = t, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this;
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = e.elements;
      return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y;
      return t * t + n * n;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this;
    }
    rotateAround(e, t) {
      const n = Math.cos(t), i = Math.sin(t), s = this.x - e.x, r = this.y - e.y;
      return this.x = s * n - r * i + e.x, this.y = s * i + r * n + e.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class nn {
    constructor() {
      nn.prototype.isMatrix3 = true, this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
    }
    set(e, t, n, i, s, r, a, c, u) {
      const p = this.elements;
      return p[0] = e, p[1] = i, p[2] = a, p[3] = t, p[4] = s, p[5] = c, p[6] = n, p[7] = r, p[8] = u, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, s = this.elements, r = n[0], a = n[3], c = n[6], u = n[1], p = n[4], f = n[7], m = n[2], v = n[5], b = n[8], _ = i[0], x = i[3], w = i[6], S = i[1], y = i[4], M = i[7], C = i[2], R = i[5], k = i[8];
      return s[0] = r * _ + a * S + c * C, s[3] = r * x + a * y + c * R, s[6] = r * w + a * M + c * k, s[1] = u * _ + p * S + f * C, s[4] = u * x + p * y + f * R, s[7] = u * w + p * M + f * k, s[2] = m * _ + v * S + b * C, s[5] = m * x + v * y + b * R, s[8] = m * w + v * M + b * k, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], r = e[4], a = e[5], c = e[6], u = e[7], p = e[8];
      return t * r * p - t * a * u - n * s * p + n * a * c + i * s * u - i * r * c;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], r = e[4], a = e[5], c = e[6], u = e[7], p = e[8], f = p * r - a * u, m = a * c - p * s, v = u * s - r * c, b = t * f + n * m + i * v;
      if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const _ = 1 / b;
      return e[0] = f * _, e[1] = (i * u - p * n) * _, e[2] = (a * n - i * r) * _, e[3] = m * _, e[4] = (p * t - i * c) * _, e[5] = (i * s - a * t) * _, e[6] = v * _, e[7] = (n * c - u * t) * _, e[8] = (r * t - n * s) * _, this;
    }
    transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
    }
    setUvTransform(e, t, n, i, s, r, a) {
      const c = Math.cos(s), u = Math.sin(s);
      return this.set(n * c, n * u, -n * (c * r + u * a) + r + e, -i * u, i * c, -i * (-u * r + c * a) + a + t, 0, 0, 1), this;
    }
    scale(e, t) {
      return this.premultiply(Ul.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(Ul.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(Ul.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
    }
    makeRotation(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const Ul = new nn();
  function Yf(l) {
    for (let e = l.length - 1; e >= 0; --e) if (l[e] >= 65535) return true;
    return false;
  }
  const V0 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  function js(l, e) {
    return new V0[l](e);
  }
  function so(l) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", l);
  }
  function ls(l) {
    return l < 0.04045 ? l * 0.0773993808 : Math.pow(l * 0.9478672986 + 0.0521327014, 2.4);
  }
  function Fa(l) {
    return l < 31308e-7 ? l * 12.92 : 1.055 * Math.pow(l, 0.41666) - 0.055;
  }
  const zl = {
    [Sn]: {
      [ir]: ls
    },
    [ir]: {
      [Sn]: Fa
    }
  }, Yt = {
    legacyMode: true,
    get workingColorSpace() {
      return ir;
    },
    set workingColorSpace(l) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(l, e, t) {
      if (this.legacyMode || e === t || !e || !t) return l;
      if (zl[e] && zl[e][t] !== void 0) {
        const n = zl[e][t];
        return l.r = n(l.r), l.g = n(l.g), l.b = n(l.b), l;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(l, e) {
      return this.convert(l, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function(l, e) {
      return this.convert(l, e, this.workingColorSpace);
    }
  }, $f = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, Ot = {
    r: 0,
    g: 0,
    b: 0
  }, yn = {
    h: 0,
    s: 0,
    l: 0
  }, qo = {
    h: 0,
    s: 0,
    l: 0
  };
  function Vl(l, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? l + (e - l) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? l + (e - l) * 6 * (2 / 3 - t) : l;
  }
  function Xo(l, e) {
    return e.r = l.r, e.g = l.g, e.b = l.b, e;
  }
  class we {
    constructor(e, t, n) {
      return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n);
    }
    set(e) {
      return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
    }
    setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this;
    }
    setHex(e, t = Sn) {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Yt.toWorkingColorSpace(this, t), this;
    }
    setRGB(e, t, n, i = Yt.workingColorSpace) {
      return this.r = e, this.g = t, this.b = n, Yt.toWorkingColorSpace(this, i), this;
    }
    setHSL(e, t, n, i = Yt.workingColorSpace) {
      if (e = Sh(e, 1), t = At(t, 0, 1), n = At(n, 0, 1), t === 0) this.r = this.g = this.b = n;
      else {
        const s = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - s;
        this.r = Vl(r, s, e + 1 / 3), this.g = Vl(r, s, e), this.b = Vl(r, s, e - 1 / 3);
      }
      return Yt.toWorkingColorSpace(this, i), this;
    }
    setStyle(e, t = Sn) {
      function n(s) {
        s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
      }
      let i;
      if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
        let s;
        const r = i[1], a = i[2];
        switch (r) {
          case "rgb":
          case "rgba":
            if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, Yt.toWorkingColorSpace(this, t), n(s[4]), this;
            if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, Yt.toWorkingColorSpace(this, t), n(s[4]), this;
            break;
          case "hsl":
          case "hsla":
            if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
              const c = parseFloat(s[1]) / 360, u = parseFloat(s[2]) / 100, p = parseFloat(s[3]) / 100;
              return n(s[4]), this.setHSL(c, u, p, t);
            }
            break;
        }
      } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
        const s = i[1], r = s.length;
        if (r === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, Yt.toWorkingColorSpace(this, t), this;
        if (r === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, Yt.toWorkingColorSpace(this, t), this;
      }
      return e && e.length > 0 ? this.setColorName(e, t) : this;
    }
    setColorName(e, t = Sn) {
      const n = $f[e.toLowerCase()];
      return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this;
    }
    copySRGBToLinear(e) {
      return this.r = ls(e.r), this.g = ls(e.g), this.b = ls(e.b), this;
    }
    copyLinearToSRGB(e) {
      return this.r = Fa(e.r), this.g = Fa(e.g), this.b = Fa(e.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = Sn) {
      return Yt.fromWorkingColorSpace(Xo(this, Ot), e), At(Ot.r * 255, 0, 255) << 16 ^ At(Ot.g * 255, 0, 255) << 8 ^ At(Ot.b * 255, 0, 255) << 0;
    }
    getHexString(e = Sn) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = Yt.workingColorSpace) {
      Yt.fromWorkingColorSpace(Xo(this, Ot), t);
      const n = Ot.r, i = Ot.g, s = Ot.b, r = Math.max(n, i, s), a = Math.min(n, i, s);
      let c, u;
      const p = (a + r) / 2;
      if (a === r) c = 0, u = 0;
      else {
        const f = r - a;
        switch (u = p <= 0.5 ? f / (r + a) : f / (2 - r - a), r) {
          case n:
            c = (i - s) / f + (i < s ? 6 : 0);
            break;
          case i:
            c = (s - n) / f + 2;
            break;
          case s:
            c = (n - i) / f + 4;
            break;
        }
        c /= 6;
      }
      return e.h = c, e.s = u, e.l = p, e;
    }
    getRGB(e, t = Yt.workingColorSpace) {
      return Yt.fromWorkingColorSpace(Xo(this, Ot), t), e.r = Ot.r, e.g = Ot.g, e.b = Ot.b, e;
    }
    getStyle(e = Sn) {
      return Yt.fromWorkingColorSpace(Xo(this, Ot), e), e !== Sn ? `color(${e} ${Ot.r} ${Ot.g} ${Ot.b})` : `rgb(${Ot.r * 255 | 0},${Ot.g * 255 | 0},${Ot.b * 255 | 0})`;
    }
    offsetHSL(e, t, n) {
      return this.getHSL(yn), yn.h += e, yn.s += t, yn.l += n, this.setHSL(yn.h, yn.s, yn.l), this;
    }
    add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this;
    }
    addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
    }
    addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this;
    }
    sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
    }
    multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
    }
    multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this;
    }
    lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
    }
    lerpColors(e, t, n) {
      return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
    }
    lerpHSL(e, t) {
      this.getHSL(yn), e.getHSL(qo);
      const n = Yr(yn.h, qo.h, t), i = Yr(yn.s, qo.s, t), s = Yr(yn.l, qo.l, t);
      return this.setHSL(n, i, s), this;
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
    }
    fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  we.NAMES = $f;
  let As;
  class Eh {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        As === void 0 && (As = so("canvas")), As.width = e.width, As.height = e.height;
        const n = As.getContext("2d");
        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = As;
      }
      return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
        const t = so("canvas");
        t.width = e.width, t.height = e.height;
        const n = t.getContext("2d");
        n.drawImage(e, 0, 0, e.width, e.height);
        const i = n.getImageData(0, 0, e.width, e.height), s = i.data;
        for (let r = 0; r < s.length; r++) s[r] = ls(s[r] / 255) * 255;
        return n.putImageData(i, 0, 0), t;
      } else if (e.data) {
        const t = e.data.slice(0);
        for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(ls(t[n] / 255) * 255) : t[n] = ls(t[n]);
        return {
          data: t,
          width: e.width,
          height: e.height
        };
      } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
    }
  }
  class is {
    constructor(e = null) {
      this.isSource = true, this.uuid = dn(), this.data = e, this.version = 0;
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const n = {
        uuid: this.uuid,
        url: ""
      }, i = this.data;
      if (i !== null) {
        let s;
        if (Array.isArray(i)) {
          s = [];
          for (let r = 0, a = i.length; r < a; r++) i[r].isDataTexture ? s.push(Gl(i[r].image)) : s.push(Gl(i[r]));
        } else s = Gl(i);
        n.url = s;
      }
      return t || (e.images[this.uuid] = n), n;
    }
  }
  function Gl(l) {
    return typeof HTMLImageElement < "u" && l instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && l instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && l instanceof ImageBitmap ? Eh.getDataURL(l) : l.data ? {
      data: Array.from(l.data),
      width: l.width,
      height: l.height,
      type: l.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let G0 = 0;
  class Mt extends zn {
    constructor(e = Mt.DEFAULT_IMAGE, t = Mt.DEFAULT_MAPPING, n = Xt, i = Xt, s = yt, r = Fn, a = un, c = Ci, u = Mt.DEFAULT_ANISOTROPY, p = Ai) {
      super(), this.isTexture = true, Object.defineProperty(this, "id", {
        value: G0++
      }), this.uuid = dn(), this.name = "", this.source = new is(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = r, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = c, this.offset = new te(0, 0), this.repeat = new te(1, 1), this.center = new te(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new nn(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = p, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
    }
    get image() {
      return this.source.data;
    }
    set image(e) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        repeat: [
          this.repeat.x,
          this.repeat.y
        ],
        offset: [
          this.offset.x,
          this.offset.y
        ],
        center: [
          this.center.x,
          this.center.y
        ],
        rotation: this.rotation,
        wrap: [
          this.wrapS,
          this.wrapT
        ],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    transformUv(e) {
      if (this.mapping !== ja) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
        case Ti:
          e.x = e.x - Math.floor(e.x);
          break;
        case Xt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case er:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
        case Ti:
          e.y = e.y - Math.floor(e.y);
          break;
        case Xt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case er:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === true && (this.version++, this.source.needsUpdate = true);
    }
  }
  Mt.DEFAULT_IMAGE = null;
  Mt.DEFAULT_MAPPING = ja;
  Mt.DEFAULT_ANISOTROPY = 1;
  class ft {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      ft.prototype.isVector4 = true, this.x = e, this.y = t, this.z = n, this.w = i;
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, n, i) {
      return this.x = e, this.y = t, this.z = n, this.w = i, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this.w = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setW(e) {
      return this.w = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this.w += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, s = this.w, r = e.elements;
      return this.x = r[0] * t + r[4] * n + r[8] * i + r[12] * s, this.y = r[1] * t + r[5] * n + r[9] * i + r[13] * s, this.z = r[2] * t + r[6] * n + r[10] * i + r[14] * s, this.w = r[3] * t + r[7] * n + r[11] * i + r[15] * s, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
    }
    setAxisAngleFromRotationMatrix(e) {
      let t, n, i, s;
      const c = e.elements, u = c[0], p = c[4], f = c[8], m = c[1], v = c[5], b = c[9], _ = c[2], x = c[6], w = c[10];
      if (Math.abs(p - m) < 0.01 && Math.abs(f - _) < 0.01 && Math.abs(b - x) < 0.01) {
        if (Math.abs(p + m) < 0.1 && Math.abs(f + _) < 0.1 && Math.abs(b + x) < 0.1 && Math.abs(u + v + w - 3) < 0.1) return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        const y = (u + 1) / 2, M = (v + 1) / 2, C = (w + 1) / 2, R = (p + m) / 4, k = (f + _) / 4, T = (b + x) / 4;
        return y > M && y > C ? y < 0.01 ? (n = 0, i = 0.707106781, s = 0.707106781) : (n = Math.sqrt(y), i = R / n, s = k / n) : M > C ? M < 0.01 ? (n = 0.707106781, i = 0, s = 0.707106781) : (i = Math.sqrt(M), n = R / i, s = T / i) : C < 0.01 ? (n = 0.707106781, i = 0.707106781, s = 0) : (s = Math.sqrt(C), n = k / s, i = T / s), this.set(n, i, s, t), this;
      }
      let S = Math.sqrt((x - b) * (x - b) + (f - _) * (f - _) + (m - p) * (m - p));
      return Math.abs(S) < 1e-3 && (S = 1), this.x = (x - b) / S, this.y = (f - _) / S, this.z = (m - p) / S, this.w = Math.acos((u + v + w - 1) / 2), this;
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class Tn extends zn {
    constructor(e = 1, t = 1, n = {}) {
      super(), this.isWebGLRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new ft(0, 0, e, t), this.scissorTest = false, this.viewport = new ft(0, 0, e, t);
      const i = {
        width: e,
        height: t,
        depth: 1
      };
      this.texture = new Mt(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : false, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : yt, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : true, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : false, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0;
    }
    setSize(e, t, n = 1) {
      (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = true;
      const t = Object.assign({}, e.texture.image);
      return this.texture.source = new is(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  class $a extends Mt {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isDataArrayTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = Et, this.minFilter = Et, this.wrapR = Xt, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class H0 extends Tn {
    constructor(e = 1, t = 1, n = 1) {
      super(e, t), this.isWebGLArrayRenderTarget = true, this.depth = n, this.texture = new $a(null, e, t, n), this.texture.isRenderTargetTexture = true;
    }
  }
  class Th extends Mt {
    constructor(e = null, t = 1, n = 1, i = 1) {
      super(null), this.isData3DTexture = true, this.image = {
        data: e,
        width: t,
        height: n,
        depth: i
      }, this.magFilter = Et, this.minFilter = Et, this.wrapR = Xt, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  class W0 extends Tn {
    constructor(e = 1, t = 1, n = 1) {
      super(e, t), this.isWebGL3DRenderTarget = true, this.depth = n, this.texture = new Th(null, e, t, n), this.texture.isRenderTargetTexture = true;
    }
  }
  class q0 extends Tn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
      super(e, t, i), this.isWebGLMultipleRenderTargets = true;
      const s = this.texture;
      this.texture = [];
      for (let r = 0; r < n; r++) this.texture[r] = s.clone(), this.texture[r].isRenderTargetTexture = true;
    }
    setSize(e, t, n = 1) {
      if (this.width !== e || this.height !== t || this.depth !== n) {
        this.width = e, this.height = t, this.depth = n;
        for (let i = 0, s = this.texture.length; i < s; i++) this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
        this.dispose();
      }
      return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
    }
    copy(e) {
      this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
      for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = true;
      return this;
    }
  }
  class xt {
    constructor(e = 0, t = 0, n = 0, i = 1) {
      this.isQuaternion = true, this._x = e, this._y = t, this._z = n, this._w = i;
    }
    static slerpFlat(e, t, n, i, s, r, a) {
      let c = n[i + 0], u = n[i + 1], p = n[i + 2], f = n[i + 3];
      const m = s[r + 0], v = s[r + 1], b = s[r + 2], _ = s[r + 3];
      if (a === 0) {
        e[t + 0] = c, e[t + 1] = u, e[t + 2] = p, e[t + 3] = f;
        return;
      }
      if (a === 1) {
        e[t + 0] = m, e[t + 1] = v, e[t + 2] = b, e[t + 3] = _;
        return;
      }
      if (f !== _ || c !== m || u !== v || p !== b) {
        let x = 1 - a;
        const w = c * m + u * v + p * b + f * _, S = w >= 0 ? 1 : -1, y = 1 - w * w;
        if (y > Number.EPSILON) {
          const C = Math.sqrt(y), R = Math.atan2(C, w * S);
          x = Math.sin(x * R) / C, a = Math.sin(a * R) / C;
        }
        const M = a * S;
        if (c = c * x + m * M, u = u * x + v * M, p = p * x + b * M, f = f * x + _ * M, x === 1 - a) {
          const C = 1 / Math.sqrt(c * c + u * u + p * p + f * f);
          c *= C, u *= C, p *= C, f *= C;
        }
      }
      e[t] = c, e[t + 1] = u, e[t + 2] = p, e[t + 3] = f;
    }
    static multiplyQuaternionsFlat(e, t, n, i, s, r) {
      const a = n[i], c = n[i + 1], u = n[i + 2], p = n[i + 3], f = s[r], m = s[r + 1], v = s[r + 2], b = s[r + 3];
      return e[t] = a * b + p * f + c * v - u * m, e[t + 1] = c * b + p * m + u * f - a * v, e[t + 2] = u * b + p * v + a * m - c * f, e[t + 3] = p * b - a * f - c * m - u * v, e;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      this._w = e, this._onChangeCallback();
    }
    set(e, t, n, i) {
      return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
    }
    setFromEuler(e, t) {
      const n = e._x, i = e._y, s = e._z, r = e._order, a = Math.cos, c = Math.sin, u = a(n / 2), p = a(i / 2), f = a(s / 2), m = c(n / 2), v = c(i / 2), b = c(s / 2);
      switch (r) {
        case "XYZ":
          this._x = m * p * f + u * v * b, this._y = u * v * f - m * p * b, this._z = u * p * b + m * v * f, this._w = u * p * f - m * v * b;
          break;
        case "YXZ":
          this._x = m * p * f + u * v * b, this._y = u * v * f - m * p * b, this._z = u * p * b - m * v * f, this._w = u * p * f + m * v * b;
          break;
        case "ZXY":
          this._x = m * p * f - u * v * b, this._y = u * v * f + m * p * b, this._z = u * p * b + m * v * f, this._w = u * p * f - m * v * b;
          break;
        case "ZYX":
          this._x = m * p * f - u * v * b, this._y = u * v * f + m * p * b, this._z = u * p * b - m * v * f, this._w = u * p * f + m * v * b;
          break;
        case "YZX":
          this._x = m * p * f + u * v * b, this._y = u * v * f + m * p * b, this._z = u * p * b - m * v * f, this._w = u * p * f - m * v * b;
          break;
        case "XZY":
          this._x = m * p * f - u * v * b, this._y = u * v * f - m * p * b, this._z = u * p * b + m * v * f, this._w = u * p * f + m * v * b;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
      }
      return t !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      const n = t / 2, i = Math.sin(n);
      return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e) {
      const t = e.elements, n = t[0], i = t[4], s = t[8], r = t[1], a = t[5], c = t[9], u = t[2], p = t[6], f = t[10], m = n + a + f;
      if (m > 0) {
        const v = 0.5 / Math.sqrt(m + 1);
        this._w = 0.25 / v, this._x = (p - c) * v, this._y = (s - u) * v, this._z = (r - i) * v;
      } else if (n > a && n > f) {
        const v = 2 * Math.sqrt(1 + n - a - f);
        this._w = (p - c) / v, this._x = 0.25 * v, this._y = (i + r) / v, this._z = (s + u) / v;
      } else if (a > f) {
        const v = 2 * Math.sqrt(1 + a - n - f);
        this._w = (s - u) / v, this._x = (i + r) / v, this._y = 0.25 * v, this._z = (c + p) / v;
      } else {
        const v = 2 * Math.sqrt(1 + f - n - a);
        this._w = (r - i) / v, this._x = (s + u) / v, this._y = (c + p) / v, this._z = 0.25 * v;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let n = e.dot(t) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(At(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      const n = this.angleTo(e);
      if (n === 0) return this;
      const i = Math.min(1, t / n);
      return this.slerp(e, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let e = this.length();
      return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      const n = e._x, i = e._y, s = e._z, r = e._w, a = t._x, c = t._y, u = t._z, p = t._w;
      return this._x = n * p + r * a + i * u - s * c, this._y = i * p + r * c + s * a - n * u, this._z = s * p + r * u + n * c - i * a, this._w = r * p - n * a - i * c - s * u, this._onChangeCallback(), this;
    }
    slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      const n = this._x, i = this._y, s = this._z, r = this._w;
      let a = r * e._w + n * e._x + i * e._y + s * e._z;
      if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = r, this._x = n, this._y = i, this._z = s, this;
      const c = 1 - a * a;
      if (c <= Number.EPSILON) {
        const v = 1 - t;
        return this._w = v * r + t * this._w, this._x = v * n + t * this._x, this._y = v * i + t * this._y, this._z = v * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      const u = Math.sqrt(c), p = Math.atan2(u, a), f = Math.sin((1 - t) * p) / u, m = Math.sin(t * p) / u;
      return this._w = r * f + this._w * m, this._x = n * f + this._x * m, this._y = i * f + this._y * m, this._z = s * f + this._z * m, this._onChangeCallback(), this;
    }
    slerpQuaternions(e, t, n) {
      return this.copy(e).slerp(t, n);
    }
    random() {
      const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
      return this.set(t * Math.cos(i), n * Math.sin(s), n * Math.cos(s), t * Math.sin(i));
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
    }
    fromArray(e, t = 0) {
      return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
    }
    fromBufferAttribute(e, t) {
      return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class P {
    constructor(e = 0, t = 0, n = 0) {
      P.prototype.isVector3 = true, this.x = e, this.y = t, this.z = n;
    }
    set(e, t, n) {
      return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
    }
    setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this;
    }
    setX(e) {
      return this.x = e, this;
    }
    setY(e) {
      return this.y = e, this;
    }
    setZ(e) {
      return this.z = e, this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this;
    }
    add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this;
    }
    addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this;
    }
    addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
    }
    addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
    }
    sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
    }
    subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this;
    }
    subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
    }
    multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
    }
    multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this;
    }
    multiplyVectors(e, t) {
      return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
    }
    applyEuler(e) {
      return this.applyQuaternion(md.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(md.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      const t = this.x, n = this.y, i = this.z, s = e.elements;
      return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this;
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      const t = this.x, n = this.y, i = this.z, s = e.elements, r = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
      return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * r, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * r, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * r, this;
    }
    applyQuaternion(e) {
      const t = this.x, n = this.y, i = this.z, s = e.x, r = e.y, a = e.z, c = e.w, u = c * t + r * i - a * n, p = c * n + a * t - s * i, f = c * i + s * n - r * t, m = -s * t - r * n - a * i;
      return this.x = u * c + m * -s + p * -a - f * -r, this.y = p * c + m * -r + f * -s - u * -a, this.z = f * c + m * -a + u * -r - p * -s, this;
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
    }
    transformDirection(e) {
      const t = this.x, n = this.y, i = this.z, s = e.elements;
      return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize();
    }
    divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
    }
    max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
    }
    clamp(e, t) {
      return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
    }
    clampScalar(e, t) {
      return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
    }
    clampLength(e, t) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
    }
    lerpVectors(e, t, n) {
      return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      const n = e.x, i = e.y, s = e.z, r = t.x, a = t.y, c = t.z;
      return this.x = i * c - s * a, this.y = s * r - n * c, this.z = n * a - i * r, this;
    }
    projectOnVector(e) {
      const t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      const n = e.dot(this) / t;
      return this.copy(e).multiplyScalar(n);
    }
    projectOnPlane(e) {
      return Hl.copy(this).projectOnVector(e), this.sub(Hl);
    }
    reflect(e) {
      return this.sub(Hl.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const n = this.dot(e) / t;
      return Math.acos(At(n, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
      return t * t + n * n + i * i;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, n) {
      const i = Math.sin(t) * e;
      return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, n) {
      return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this;
    }
    setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
      return this.x = t, this.y = n, this.z = i, this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3);
    }
    setFromEuler(e) {
      return this.x = e._x, this.y = e._y, this.z = e._z, this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
    }
    fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
      return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const Hl = new P(), md = new xt();
  class Bn {
    constructor(e = new P(1 / 0, 1 / 0, 1 / 0), t = new P(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = true, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      let t = 1 / 0, n = 1 / 0, i = 1 / 0, s = -1 / 0, r = -1 / 0, a = -1 / 0;
      for (let c = 0, u = e.length; c < u; c += 3) {
        const p = e[c], f = e[c + 1], m = e[c + 2];
        p < t && (t = p), f < n && (n = f), m < i && (i = m), p > s && (s = p), f > r && (r = f), m > a && (a = m);
      }
      return this.min.set(t, n, i), this.max.set(s, r, a), this;
    }
    setFromBufferAttribute(e) {
      let t = 1 / 0, n = 1 / 0, i = 1 / 0, s = -1 / 0, r = -1 / 0, a = -1 / 0;
      for (let c = 0, u = e.count; c < u; c++) {
        const p = e.getX(c), f = e.getY(c), m = e.getZ(c);
        p < t && (t = p), f < n && (n = f), m < i && (i = m), p > s && (s = p), f > r && (r = f), m > a && (a = m);
      }
      return this.min.set(t, n, i), this.max.set(s, r, a), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = Gi.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    setFromObject(e, t = false) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = false) {
      e.updateWorldMatrix(false, false);
      const n = e.geometry;
      if (n !== void 0) if (t && n.attributes != null && n.attributes.position !== void 0) {
        const s = n.attributes.position;
        for (let r = 0, a = s.count; r < a; r++) Gi.fromBufferAttribute(s, r).applyMatrix4(e.matrixWorld), this.expandByPoint(Gi);
      } else n.boundingBox === null && n.computeBoundingBox(), Wl.copy(n.boundingBox), Wl.applyMatrix4(e.matrixWorld), this.union(Wl);
      const i = e.children;
      for (let s = 0, r = i.length; s < r; s++) this.expandByObject(i[s], t);
      return this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
    }
    getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
    }
    intersectsSphere(e) {
      return this.clampPoint(e.center, Gi), Gi.distanceToSquared(e.center) <= e.radius * e.radius;
    }
    intersectsPlane(e) {
      let t, n;
      return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return false;
      this.getCenter(Ir), jo.subVectors(this.max, Ir), Ps.subVectors(e.a, Ir), Ls.subVectors(e.b, Ir), Rs.subVectors(e.c, Ir), fi.subVectors(Ls, Ps), mi.subVectors(Rs, Ls), Hi.subVectors(Ps, Rs);
      let t = [
        0,
        -fi.z,
        fi.y,
        0,
        -mi.z,
        mi.y,
        0,
        -Hi.z,
        Hi.y,
        fi.z,
        0,
        -fi.x,
        mi.z,
        0,
        -mi.x,
        Hi.z,
        0,
        -Hi.x,
        -fi.y,
        fi.x,
        0,
        -mi.y,
        mi.x,
        0,
        -Hi.y,
        Hi.x,
        0
      ];
      return !ql(t, Ps, Ls, Rs, jo) || (t = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ], !ql(t, Ps, Ls, Rs, jo)) ? false : (Ko.crossVectors(fi, mi), t = [
        Ko.x,
        Ko.y,
        Ko.z
      ], ql(t, Ps, Ls, Rs, jo));
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return Gi.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    getBoundingSphere(e) {
      return this.getCenter(e.center), e.radius = this.getSize(Gi).length() * 0.5, e;
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return this.isEmpty() ? this : (jn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), jn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), jn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), jn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), jn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), jn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), jn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), jn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(jn), this);
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const jn = [
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P(),
    new P()
  ], Gi = new P(), Wl = new Bn(), Ps = new P(), Ls = new P(), Rs = new P(), fi = new P(), mi = new P(), Hi = new P(), Ir = new P(), jo = new P(), Ko = new P(), Wi = new P();
  function ql(l, e, t, n, i) {
    for (let s = 0, r = l.length - 3; s <= r; s += 3) {
      Wi.fromArray(l, s);
      const a = i.x * Math.abs(Wi.x) + i.y * Math.abs(Wi.y) + i.z * Math.abs(Wi.z), c = e.dot(Wi), u = t.dot(Wi), p = n.dot(Wi);
      if (Math.max(-Math.max(c, u, p), Math.min(c, u, p)) > a) return false;
    }
    return true;
  }
  const X0 = new Bn(), Dr = new P(), Xl = new P();
  class Ii {
    constructor(e = new P(), t = -1) {
      this.center = e, this.radius = t;
    }
    set(e, t) {
      return this.center.copy(e), this.radius = t, this;
    }
    setFromPoints(e, t) {
      const n = this.center;
      t !== void 0 ? n.copy(t) : X0.setFromPoints(e).getCenter(n);
      let i = 0;
      for (let s = 0, r = e.length; s < r; s++) i = Math.max(i, n.distanceToSquared(e[s]));
      return this.radius = Math.sqrt(i), this;
    }
    copy(e) {
      return this.center.copy(e.center), this.radius = e.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const n = this.center.distanceToSquared(e);
      return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
    }
    getBoundingBox(e) {
      return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
      Dr.subVectors(e, this.center);
      const t = Dr.lengthSq();
      if (t > this.radius * this.radius) {
        const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
        this.center.addScaledVector(Dr, i / n), this.radius += i;
      }
      return this;
    }
    union(e) {
      return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (Xl.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Dr.copy(e.center).add(Xl)), this.expandByPoint(Dr.copy(e.center).sub(Xl))), this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Kn = new P(), jl = new P(), Yo = new P(), gi = new P(), Kl = new P(), $o = new P(), Yl = new P();
  class fo {
    constructor(e = new P(), t = new P(0, 0, -1)) {
      this.origin = e, this.direction = t;
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.direction).multiplyScalar(e).add(this.origin);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, Kn)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      const n = t.dot(this.direction);
      return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      const t = Kn.subVectors(e, this.origin).dot(this.direction);
      return t < 0 ? this.origin.distanceToSquared(e) : (Kn.copy(this.direction).multiplyScalar(t).add(this.origin), Kn.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, n, i) {
      jl.copy(e).add(t).multiplyScalar(0.5), Yo.copy(t).sub(e).normalize(), gi.copy(this.origin).sub(jl);
      const s = e.distanceTo(t) * 0.5, r = -this.direction.dot(Yo), a = gi.dot(this.direction), c = -gi.dot(Yo), u = gi.lengthSq(), p = Math.abs(1 - r * r);
      let f, m, v, b;
      if (p > 0) if (f = r * c - a, m = r * a - c, b = s * p, f >= 0) if (m >= -b) if (m <= b) {
        const _ = 1 / p;
        f *= _, m *= _, v = f * (f + r * m + 2 * a) + m * (r * f + m + 2 * c) + u;
      } else m = s, f = Math.max(0, -(r * m + a)), v = -f * f + m * (m + 2 * c) + u;
      else m = -s, f = Math.max(0, -(r * m + a)), v = -f * f + m * (m + 2 * c) + u;
      else m <= -b ? (f = Math.max(0, -(-r * s + a)), m = f > 0 ? -s : Math.min(Math.max(-s, -c), s), v = -f * f + m * (m + 2 * c) + u) : m <= b ? (f = 0, m = Math.min(Math.max(-s, -c), s), v = m * (m + 2 * c) + u) : (f = Math.max(0, -(r * s + a)), m = f > 0 ? s : Math.min(Math.max(-s, -c), s), v = -f * f + m * (m + 2 * c) + u);
      else m = r > 0 ? -s : s, f = Math.max(0, -(r * m + a)), v = -f * f + m * (m + 2 * c) + u;
      return n && n.copy(this.direction).multiplyScalar(f).add(this.origin), i && i.copy(Yo).multiplyScalar(m).add(jl), v;
    }
    intersectSphere(e, t) {
      Kn.subVectors(e.center, this.origin);
      const n = Kn.dot(this.direction), i = Kn.dot(Kn) - n * n, s = e.radius * e.radius;
      if (i > s) return null;
      const r = Math.sqrt(s - i), a = n - r, c = n + r;
      return a < 0 && c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      const n = -(this.origin.dot(e.normal) + e.constant) / t;
      return n >= 0 ? n : null;
    }
    intersectPlane(e, t) {
      const n = this.distanceToPlane(e);
      return n === null ? null : this.at(n, t);
    }
    intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let n, i, s, r, a, c;
      const u = 1 / this.direction.x, p = 1 / this.direction.y, f = 1 / this.direction.z, m = this.origin;
      return u >= 0 ? (n = (e.min.x - m.x) * u, i = (e.max.x - m.x) * u) : (n = (e.max.x - m.x) * u, i = (e.min.x - m.x) * u), p >= 0 ? (s = (e.min.y - m.y) * p, r = (e.max.y - m.y) * p) : (s = (e.max.y - m.y) * p, r = (e.min.y - m.y) * p), n > r || s > i || ((s > n || isNaN(n)) && (n = s), (r < i || isNaN(i)) && (i = r), f >= 0 ? (a = (e.min.z - m.z) * f, c = (e.max.z - m.z) * f) : (a = (e.max.z - m.z) * f, c = (e.min.z - m.z) * f), n > c || a > i) || ((a > n || n !== n) && (n = a), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, t);
    }
    intersectsBox(e) {
      return this.intersectBox(e, Kn) !== null;
    }
    intersectTriangle(e, t, n, i, s) {
      Kl.subVectors(t, e), $o.subVectors(n, e), Yl.crossVectors(Kl, $o);
      let r = this.direction.dot(Yl), a;
      if (r > 0) {
        if (i) return null;
        a = 1;
      } else if (r < 0) a = -1, r = -r;
      else return null;
      gi.subVectors(this.origin, e);
      const c = a * this.direction.dot($o.crossVectors(gi, $o));
      if (c < 0) return null;
      const u = a * this.direction.dot(Kl.cross(gi));
      if (u < 0 || c + u > r) return null;
      const p = -a * gi.dot(Yl);
      return p < 0 ? null : this.at(p / r, s);
    }
    applyMatrix4(e) {
      return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class ze {
    constructor() {
      ze.prototype.isMatrix4 = true, this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
    }
    set(e, t, n, i, s, r, a, c, u, p, f, m, v, b, _, x) {
      const w = this.elements;
      return w[0] = e, w[4] = t, w[8] = n, w[12] = i, w[1] = s, w[5] = r, w[9] = a, w[13] = c, w[2] = u, w[6] = p, w[10] = f, w[14] = m, w[3] = v, w[7] = b, w[11] = _, w[15] = x, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new ze().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements, n = e.elements;
      return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
    }
    copyPosition(e) {
      const t = this.elements, n = e.elements;
      return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
    }
    setFromMatrix3(e) {
      const t = e.elements;
      return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(e, t, n) {
      return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(e, t, n) {
      return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(e) {
      const t = this.elements, n = e.elements, i = 1 / Is.setFromMatrixColumn(e, 0).length(), s = 1 / Is.setFromMatrixColumn(e, 1).length(), r = 1 / Is.setFromMatrixColumn(e, 2).length();
      return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * r, t[9] = n[9] * r, t[10] = n[10] * r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromEuler(e) {
      const t = this.elements, n = e.x, i = e.y, s = e.z, r = Math.cos(n), a = Math.sin(n), c = Math.cos(i), u = Math.sin(i), p = Math.cos(s), f = Math.sin(s);
      if (e.order === "XYZ") {
        const m = r * p, v = r * f, b = a * p, _ = a * f;
        t[0] = c * p, t[4] = -c * f, t[8] = u, t[1] = v + b * u, t[5] = m - _ * u, t[9] = -a * c, t[2] = _ - m * u, t[6] = b + v * u, t[10] = r * c;
      } else if (e.order === "YXZ") {
        const m = c * p, v = c * f, b = u * p, _ = u * f;
        t[0] = m + _ * a, t[4] = b * a - v, t[8] = r * u, t[1] = r * f, t[5] = r * p, t[9] = -a, t[2] = v * a - b, t[6] = _ + m * a, t[10] = r * c;
      } else if (e.order === "ZXY") {
        const m = c * p, v = c * f, b = u * p, _ = u * f;
        t[0] = m - _ * a, t[4] = -r * f, t[8] = b + v * a, t[1] = v + b * a, t[5] = r * p, t[9] = _ - m * a, t[2] = -r * u, t[6] = a, t[10] = r * c;
      } else if (e.order === "ZYX") {
        const m = r * p, v = r * f, b = a * p, _ = a * f;
        t[0] = c * p, t[4] = b * u - v, t[8] = m * u + _, t[1] = c * f, t[5] = _ * u + m, t[9] = v * u - b, t[2] = -u, t[6] = a * c, t[10] = r * c;
      } else if (e.order === "YZX") {
        const m = r * c, v = r * u, b = a * c, _ = a * u;
        t[0] = c * p, t[4] = _ - m * f, t[8] = b * f + v, t[1] = f, t[5] = r * p, t[9] = -a * p, t[2] = -u * p, t[6] = v * f + b, t[10] = m - _ * f;
      } else if (e.order === "XZY") {
        const m = r * c, v = r * u, b = a * c, _ = a * u;
        t[0] = c * p, t[4] = -f, t[8] = u * p, t[1] = m * f + _, t[5] = r * p, t[9] = v * f - b, t[2] = b * f - v, t[6] = a * p, t[10] = _ * f + m;
      }
      return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
    }
    makeRotationFromQuaternion(e) {
      return this.compose(j0, e, K0);
    }
    lookAt(e, t, n) {
      const i = this.elements;
      return cn.subVectors(e, t), cn.lengthSq() === 0 && (cn.z = 1), cn.normalize(), vi.crossVectors(n, cn), vi.lengthSq() === 0 && (Math.abs(n.z) === 1 ? cn.x += 1e-4 : cn.z += 1e-4, cn.normalize(), vi.crossVectors(n, cn)), vi.normalize(), Zo.crossVectors(cn, vi), i[0] = vi.x, i[4] = Zo.x, i[8] = cn.x, i[1] = vi.y, i[5] = Zo.y, i[9] = cn.y, i[2] = vi.z, i[6] = Zo.z, i[10] = cn.z, this;
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const n = e.elements, i = t.elements, s = this.elements, r = n[0], a = n[4], c = n[8], u = n[12], p = n[1], f = n[5], m = n[9], v = n[13], b = n[2], _ = n[6], x = n[10], w = n[14], S = n[3], y = n[7], M = n[11], C = n[15], R = i[0], k = i[4], T = i[8], L = i[12], F = i[1], j = i[5], Y = i[9], z = i[13], B = i[2], Z = i[6], ie = i[10], re = i[14], W = i[3], pe = i[7], ae = i[11], Te = i[15];
      return s[0] = r * R + a * F + c * B + u * W, s[4] = r * k + a * j + c * Z + u * pe, s[8] = r * T + a * Y + c * ie + u * ae, s[12] = r * L + a * z + c * re + u * Te, s[1] = p * R + f * F + m * B + v * W, s[5] = p * k + f * j + m * Z + v * pe, s[9] = p * T + f * Y + m * ie + v * ae, s[13] = p * L + f * z + m * re + v * Te, s[2] = b * R + _ * F + x * B + w * W, s[6] = b * k + _ * j + x * Z + w * pe, s[10] = b * T + _ * Y + x * ie + w * ae, s[14] = b * L + _ * z + x * re + w * Te, s[3] = S * R + y * F + M * B + C * W, s[7] = S * k + y * j + M * Z + C * pe, s[11] = S * T + y * Y + M * ie + C * ae, s[15] = S * L + y * z + M * re + C * Te, this;
    }
    multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
    }
    determinant() {
      const e = this.elements, t = e[0], n = e[4], i = e[8], s = e[12], r = e[1], a = e[5], c = e[9], u = e[13], p = e[2], f = e[6], m = e[10], v = e[14], b = e[3], _ = e[7], x = e[11], w = e[15];
      return b * (+s * c * f - i * u * f - s * a * m + n * u * m + i * a * v - n * c * v) + _ * (+t * c * v - t * u * m + s * r * m - i * r * v + i * u * p - s * c * p) + x * (+t * u * f - t * a * v - s * r * f + n * r * v + s * a * p - n * u * p) + w * (-i * a * p - t * c * f + t * a * m + i * r * f - n * r * m + n * c * p);
    }
    transpose() {
      const e = this.elements;
      let t;
      return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
    }
    setPosition(e, t, n) {
      const i = this.elements;
      return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
    }
    invert() {
      const e = this.elements, t = e[0], n = e[1], i = e[2], s = e[3], r = e[4], a = e[5], c = e[6], u = e[7], p = e[8], f = e[9], m = e[10], v = e[11], b = e[12], _ = e[13], x = e[14], w = e[15], S = f * x * u - _ * m * u + _ * c * v - a * x * v - f * c * w + a * m * w, y = b * m * u - p * x * u - b * c * v + r * x * v + p * c * w - r * m * w, M = p * _ * u - b * f * u + b * a * v - r * _ * v - p * a * w + r * f * w, C = b * f * c - p * _ * c - b * a * m + r * _ * m + p * a * x - r * f * x, R = t * S + n * y + i * M + s * C;
      if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const k = 1 / R;
      return e[0] = S * k, e[1] = (_ * m * s - f * x * s - _ * i * v + n * x * v + f * i * w - n * m * w) * k, e[2] = (a * x * s - _ * c * s + _ * i * u - n * x * u - a * i * w + n * c * w) * k, e[3] = (f * c * s - a * m * s - f * i * u + n * m * u + a * i * v - n * c * v) * k, e[4] = y * k, e[5] = (p * x * s - b * m * s + b * i * v - t * x * v - p * i * w + t * m * w) * k, e[6] = (b * c * s - r * x * s - b * i * u + t * x * u + r * i * w - t * c * w) * k, e[7] = (r * m * s - p * c * s + p * i * u - t * m * u - r * i * v + t * c * v) * k, e[8] = M * k, e[9] = (b * f * s - p * _ * s - b * n * v + t * _ * v + p * n * w - t * f * w) * k, e[10] = (r * _ * s - b * a * s + b * n * u - t * _ * u - r * n * w + t * a * w) * k, e[11] = (p * a * s - r * f * s - p * n * u + t * f * u + r * n * v - t * a * v) * k, e[12] = C * k, e[13] = (p * _ * i - b * f * i + b * n * m - t * _ * m - p * n * x + t * f * x) * k, e[14] = (b * a * i - r * _ * i - b * n * c + t * _ * c + r * n * x - t * a * x) * k, e[15] = (r * f * i - p * a * i + p * n * c - t * f * c - r * n * m + t * a * m) * k, this;
    }
    scale(e) {
      const t = this.elements, n = e.x, i = e.y, s = e.z;
      return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this;
    }
    getMaxScaleOnAxis() {
      const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, n, i));
    }
    makeTranslation(e, t, n) {
      return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      const t = Math.cos(e), n = Math.sin(e);
      return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      const n = Math.cos(t), i = Math.sin(t), s = 1 - n, r = e.x, a = e.y, c = e.z, u = s * r, p = s * a;
      return this.set(u * r + n, u * a - i * c, u * c + i * a, 0, u * a + i * c, p * a + n, p * c - i * r, 0, u * c - i * a, p * c + i * r, s * c * c + n, 0, 0, 0, 0, 1), this;
    }
    makeScale(e, t, n) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, n, i, s, r) {
      return this.set(1, n, s, 0, e, 1, r, 0, t, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, n) {
      const i = this.elements, s = t._x, r = t._y, a = t._z, c = t._w, u = s + s, p = r + r, f = a + a, m = s * u, v = s * p, b = s * f, _ = r * p, x = r * f, w = a * f, S = c * u, y = c * p, M = c * f, C = n.x, R = n.y, k = n.z;
      return i[0] = (1 - (_ + w)) * C, i[1] = (v + M) * C, i[2] = (b - y) * C, i[3] = 0, i[4] = (v - M) * R, i[5] = (1 - (m + w)) * R, i[6] = (x + S) * R, i[7] = 0, i[8] = (b + y) * k, i[9] = (x - S) * k, i[10] = (1 - (m + _)) * k, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
    }
    decompose(e, t, n) {
      const i = this.elements;
      let s = Is.set(i[0], i[1], i[2]).length();
      const r = Is.set(i[4], i[5], i[6]).length(), a = Is.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], wn.copy(this);
      const u = 1 / s, p = 1 / r, f = 1 / a;
      return wn.elements[0] *= u, wn.elements[1] *= u, wn.elements[2] *= u, wn.elements[4] *= p, wn.elements[5] *= p, wn.elements[6] *= p, wn.elements[8] *= f, wn.elements[9] *= f, wn.elements[10] *= f, t.setFromRotationMatrix(wn), n.x = s, n.y = r, n.z = a, this;
    }
    makePerspective(e, t, n, i, s, r) {
      const a = this.elements, c = 2 * s / (t - e), u = 2 * s / (n - i), p = (t + e) / (t - e), f = (n + i) / (n - i), m = -(r + s) / (r - s), v = -2 * r * s / (r - s);
      return a[0] = c, a[4] = 0, a[8] = p, a[12] = 0, a[1] = 0, a[5] = u, a[9] = f, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = m, a[14] = v, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
    }
    makeOrthographic(e, t, n, i, s, r) {
      const a = this.elements, c = 1 / (t - e), u = 1 / (n - i), p = 1 / (r - s), f = (t + e) * c, m = (n + i) * u, v = (r + s) * p;
      return a[0] = 2 * c, a[4] = 0, a[8] = 0, a[12] = -f, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -m, a[2] = 0, a[6] = 0, a[10] = -2 * p, a[14] = -v, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
    }
    equals(e) {
      const t = this.elements, n = e.elements;
      for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return false;
      return true;
    }
    fromArray(e, t = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.elements;
      return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
    }
  }
  const Is = new P(), wn = new ze(), j0 = new P(0, 0, 0), K0 = new P(1, 1, 1), vi = new P(), Zo = new P(), cn = new P(), gd = new ze(), vd = new xt();
  class mo {
    constructor(e = 0, t = 0, n = 0, i = mo.DEFAULT_ORDER) {
      this.isEuler = true, this._x = e, this._y = t, this._z = n, this._order = i;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x = e, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y = e, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      this._z = e, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      this._order = e, this._onChangeCallback();
    }
    set(e, t, n, i = this._order) {
      return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(e, t = this._order, n = true) {
      const i = e.elements, s = i[0], r = i[4], a = i[8], c = i[1], u = i[5], p = i[9], f = i[2], m = i[6], v = i[10];
      switch (t) {
        case "XYZ":
          this._y = Math.asin(At(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-p, v), this._z = Math.atan2(-r, s)) : (this._x = Math.atan2(m, u), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-At(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(a, v), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-f, s), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(At(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-f, v), this._z = Math.atan2(-r, u)) : (this._y = 0, this._z = Math.atan2(c, s));
          break;
        case "ZYX":
          this._y = Math.asin(-At(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(m, v), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-r, u));
          break;
        case "YZX":
          this._z = Math.asin(At(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-p, u), this._y = Math.atan2(-f, s)) : (this._x = 0, this._y = Math.atan2(a, v));
          break;
        case "XZY":
          this._z = Math.asin(-At(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(m, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-p, v), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
      }
      return this._order = t, n === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, n) {
      return gd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(gd, t, n);
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return vd.setFromEuler(this), this.setFromQuaternion(vd, e);
    }
    equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
    }
    fromArray(e) {
      return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
    }
    toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
    }
    _onChange(e) {
      return this._onChangeCallback = e, this;
    }
    _onChangeCallback() {
    }
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  mo.DEFAULT_ORDER = "XYZ";
  class Za {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = (1 << e | 0) >>> 0;
    }
    enable(e) {
      this.mask |= 1 << e | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= 1 << e | 0;
    }
    disable(e) {
      this.mask &= ~(1 << e | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return (this.mask & e.mask) !== 0;
    }
    isEnabled(e) {
      return (this.mask & (1 << e | 0)) !== 0;
    }
  }
  let Y0 = 0;
  const _d = new P(), Ds = new xt(), Yn = new ze(), Jo = new P(), kr = new P(), $0 = new P(), Z0 = new xt(), xd = new P(1, 0, 0), bd = new P(0, 1, 0), yd = new P(0, 0, 1), J0 = {
    type: "added"
  }, wd = {
    type: "removed"
  };
  class rt extends zn {
    constructor() {
      super(), this.isObject3D = true, Object.defineProperty(this, "id", {
        value: Y0++
      }), this.uuid = dn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = rt.DEFAULT_UP.clone();
      const e = new P(), t = new mo(), n = new xt(), i = new P(1, 1, 1);
      function s() {
        n.setFromEuler(t, false);
      }
      function r() {
        t.setFromQuaternion(n, void 0, false);
      }
      t._onChange(s), n._onChange(r), Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: e
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: t
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: n
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: i
        },
        modelViewMatrix: {
          value: new ze()
        },
        normalMatrix: {
          value: new nn()
        }
      }), this.matrix = new ze(), this.matrixWorld = new ze(), this.matrixAutoUpdate = rt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.matrixWorldAutoUpdate = rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Za(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, true);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return Ds.setFromAxisAngle(e, t), this.quaternion.multiply(Ds), this;
    }
    rotateOnWorldAxis(e, t) {
      return Ds.setFromAxisAngle(e, t), this.quaternion.premultiply(Ds), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(xd, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(bd, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(yd, e);
    }
    translateOnAxis(e, t) {
      return _d.copy(e).applyQuaternion(this.quaternion), this.position.add(_d.multiplyScalar(t)), this;
    }
    translateX(e) {
      return this.translateOnAxis(xd, e);
    }
    translateY(e) {
      return this.translateOnAxis(bd, e);
    }
    translateZ(e) {
      return this.translateOnAxis(yd, e);
    }
    localToWorld(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return this.updateWorldMatrix(true, false), e.applyMatrix4(Yn.copy(this.matrixWorld).invert());
    }
    lookAt(e, t, n) {
      e.isVector3 ? Jo.copy(e) : Jo.set(e, t, n);
      const i = this.parent;
      this.updateWorldMatrix(true, false), kr.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Yn.lookAt(kr, Jo, this.up) : Yn.lookAt(Jo, kr, this.up), this.quaternion.setFromRotationMatrix(Yn), i && (Yn.extractRotation(i.matrixWorld), Ds.setFromRotationMatrix(Yn), this.quaternion.premultiply(Ds.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(J0)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
        return this;
      }
      const t = this.children.indexOf(e);
      return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(wd)), this;
    }
    removeFromParent() {
      const e = this.parent;
      return e !== null && e.remove(this), this;
    }
    clear() {
      for (let e = 0; e < this.children.length; e++) {
        const t = this.children[e];
        t.parent = null, t.dispatchEvent(wd);
      }
      return this.children.length = 0, this;
    }
    attach(e) {
      return this.updateWorldMatrix(true, false), Yn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), Yn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Yn), this.add(e), e.updateWorldMatrix(false, true), this;
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const r = this.children[n].getObjectByProperty(e, t);
        if (r !== void 0) return r;
      }
    }
    getObjectsByProperty(e, t) {
      let n = [];
      this[e] === t && n.push(this);
      for (let i = 0, s = this.children.length; i < s; i++) {
        const r = this.children[i].getObjectsByProperty(e, t);
        r.length > 0 && (n = n.concat(r));
      }
      return n;
    }
    getWorldPosition(e) {
      return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(kr, e, $0), e;
    }
    getWorldScale(e) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(kr, Z0, e), e;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(true, false);
      const t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {
    }
    traverse(e) {
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
    }
    traverseVisible(e) {
      if (this.visible === false) return;
      e(this);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
    }
    traverseAncestors(e) {
      const t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
      const t = this.children;
      for (let n = 0, i = t.length; n < i; n++) {
        const s = t[n];
        (s.matrixWorldAutoUpdate === true || e === true) && s.updateMatrixWorld(e);
      }
    }
    updateWorldMatrix(e, t) {
      const n = this.parent;
      if (e === true && n !== null && n.matrixWorldAutoUpdate === true && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === true) {
        const i = this.children;
        for (let s = 0, r = i.length; s < r; s++) {
          const a = i[s];
          a.matrixWorldAutoUpdate === true && a.updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string", n = {};
      t && (e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      }, n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      const i = {};
      i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === true && (i.castShadow = true), this.receiveShadow === true && (i.receiveShadow = true), this.visible === false && (i.visible = false), this.frustumCulled === false && (i.frustumCulled = false), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
      function s(a, c) {
        return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid;
      }
      if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (i.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = s(e.geometries, this.geometry);
        const a = this.geometry.parameters;
        if (a !== void 0 && a.shapes !== void 0) {
          const c = a.shapes;
          if (Array.isArray(c)) for (let u = 0, p = c.length; u < p; u++) {
            const f = c[u];
            s(e.shapes, f);
          }
          else s(e.shapes, c);
        }
      }
      if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
        const a = [];
        for (let c = 0, u = this.material.length; c < u; c++) a.push(s(e.materials, this.material[c]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let a = 0; a < this.animations.length; a++) {
          const c = this.animations[a];
          i.animations.push(s(e.animations, c));
        }
      }
      if (t) {
        const a = r(e.geometries), c = r(e.materials), u = r(e.textures), p = r(e.images), f = r(e.shapes), m = r(e.skeletons), v = r(e.animations), b = r(e.nodes);
        a.length > 0 && (n.geometries = a), c.length > 0 && (n.materials = c), u.length > 0 && (n.textures = u), p.length > 0 && (n.images = p), f.length > 0 && (n.shapes = f), m.length > 0 && (n.skeletons = m), v.length > 0 && (n.animations = v), b.length > 0 && (n.nodes = b);
      }
      return n.object = i, n;
      function r(a) {
        const c = [];
        for (const u in a) {
          const p = a[u];
          delete p.metadata, c.push(p);
        }
        return c;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = true) {
      if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
      return this;
    }
  }
  rt.DEFAULT_UP = new P(0, 1, 0);
  rt.DEFAULT_MATRIX_AUTO_UPDATE = true;
  rt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  const Mn = new P(), $n = new P(), $l = new P(), Zn = new P(), ks = new P(), Ns = new P(), Md = new P(), Zl = new P(), Jl = new P(), Ql = new P();
  class xn {
    constructor(e = new P(), t = new P(), n = new P()) {
      this.a = e, this.b = t, this.c = n;
    }
    static getNormal(e, t, n, i) {
      i.subVectors(n, t), Mn.subVectors(e, t), i.cross(Mn);
      const s = i.lengthSq();
      return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
    }
    static getBarycoord(e, t, n, i, s) {
      Mn.subVectors(i, t), $n.subVectors(n, t), $l.subVectors(e, t);
      const r = Mn.dot(Mn), a = Mn.dot($n), c = Mn.dot($l), u = $n.dot($n), p = $n.dot($l), f = r * u - a * a;
      if (f === 0) return s.set(-2, -1, -1);
      const m = 1 / f, v = (u * c - a * p) * m, b = (r * p - a * c) * m;
      return s.set(1 - v - b, b, v);
    }
    static containsPoint(e, t, n, i) {
      return this.getBarycoord(e, t, n, i, Zn), Zn.x >= 0 && Zn.y >= 0 && Zn.x + Zn.y <= 1;
    }
    static getUV(e, t, n, i, s, r, a, c) {
      return this.getBarycoord(e, t, n, i, Zn), c.set(0, 0), c.addScaledVector(s, Zn.x), c.addScaledVector(r, Zn.y), c.addScaledVector(a, Zn.z), c;
    }
    static isFrontFacing(e, t, n, i) {
      return Mn.subVectors(n, t), $n.subVectors(e, t), Mn.cross($n).dot(i) < 0;
    }
    set(e, t, n) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
    }
    setFromPointsAndIndices(e, t, n, i) {
      return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
    }
    setFromAttributeAndIndices(e, t, n, i) {
      return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return Mn.subVectors(this.c, this.b), $n.subVectors(this.a, this.b), Mn.cross($n).length() * 0.5;
    }
    getMidpoint(e) {
      return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return xn.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return xn.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, n, i, s) {
      return xn.getUV(e, this.a, this.b, this.c, t, n, i, s);
    }
    containsPoint(e) {
      return xn.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return xn.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      const n = this.a, i = this.b, s = this.c;
      let r, a;
      ks.subVectors(i, n), Ns.subVectors(s, n), Zl.subVectors(e, n);
      const c = ks.dot(Zl), u = Ns.dot(Zl);
      if (c <= 0 && u <= 0) return t.copy(n);
      Jl.subVectors(e, i);
      const p = ks.dot(Jl), f = Ns.dot(Jl);
      if (p >= 0 && f <= p) return t.copy(i);
      const m = c * f - p * u;
      if (m <= 0 && c >= 0 && p <= 0) return r = c / (c - p), t.copy(n).addScaledVector(ks, r);
      Ql.subVectors(e, s);
      const v = ks.dot(Ql), b = Ns.dot(Ql);
      if (b >= 0 && v <= b) return t.copy(s);
      const _ = v * u - c * b;
      if (_ <= 0 && u >= 0 && b <= 0) return a = u / (u - b), t.copy(n).addScaledVector(Ns, a);
      const x = p * b - v * f;
      if (x <= 0 && f - p >= 0 && v - b >= 0) return Md.subVectors(s, i), a = (f - p) / (f - p + (v - b)), t.copy(i).addScaledVector(Md, a);
      const w = 1 / (x + _ + m);
      return r = _ * w, a = m * w, t.copy(n).addScaledVector(ks, r).addScaledVector(Ns, a);
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  }
  let Q0 = 0;
  class Bt extends zn {
    constructor() {
      super(), this.isMaterial = true, Object.defineProperty(this, "id", {
        value: Q0++
      }), this.uuid = dn(), this.name = "", this.type = "Material", this.blending = rs, this.side = On, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = _h, this.blendDst = xh, this.blendEquation = Qi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Va, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Xf, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Oa, this.stencilZFail = Oa, this.stencilZPass = Oa, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (e !== void 0) for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      t && (e = {
        textures: {},
        images: {}
      });
      const n = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== rs && (n.blending = this.blending), this.side !== On && (n.side = this.side), this.vertexColors && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === true && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === true && (n.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === true && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === true && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === true && (n.forceSinglePass = this.forceSinglePass), this.wireframe === true && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n.flatShading = this.flatShading), this.visible === false && (n.visible = false), this.toneMapped === false && (n.toneMapped = false), this.fog === false && (n.fog = false), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
      function i(s) {
        const r = [];
        for (const a in s) {
          const c = s[a];
          delete c.metadata, r.push(c);
        }
        return r;
      }
      if (t) {
        const s = i(e.textures), r = i(e.images);
        s.length > 0 && (n.textures = s), r.length > 0 && (n.images = r);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
      const t = e.clippingPlanes;
      let n = null;
      if (t !== null) {
        const i = t.length;
        n = new Array(i);
        for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
  }
  class $t extends Bt {
    constructor(e) {
      super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new we(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = po, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
  }
  const Dt = new P(), Qo = new te();
  class ht {
    constructor(e, t, n = false) {
      if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = no, this.updateRange = {
        offset: 0,
        count: -1
      }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    copy(e) {
      return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
    }
    copyAt(e, t, n) {
      e *= this.itemSize, n *= t.itemSize;
      for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    applyMatrix3(e) {
      if (this.itemSize === 2) for (let t = 0, n = this.count; t < n; t++) Qo.fromBufferAttribute(this, t), Qo.applyMatrix3(e), this.setXY(t, Qo.x, Qo.y);
      else if (this.itemSize === 3) for (let t = 0, n = this.count; t < n; t++) Dt.fromBufferAttribute(this, t), Dt.applyMatrix3(e), this.setXYZ(t, Dt.x, Dt.y, Dt.z);
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.count; t < n; t++) Dt.fromBufferAttribute(this, t), Dt.applyMatrix4(e), this.setXYZ(t, Dt.x, Dt.y, Dt.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) Dt.fromBufferAttribute(this, t), Dt.applyNormalMatrix(e), this.setXYZ(t, Dt.x, Dt.y, Dt.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) Dt.fromBufferAttribute(this, t), Dt.transformDirection(e), this.setXYZ(t, Dt.x, Dt.y, Dt.z);
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    setX(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize] = t, this;
    }
    getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    setY(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
    }
    getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    setZ(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
    }
    getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    setW(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
    }
    setXY(e, t, n) {
      return e *= this.itemSize, this.normalized && (t = mt(t, this.array), n = mt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e *= this.itemSize, this.normalized && (t = mt(t, this.array), n = mt(n, this.array), i = mt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, s) {
      return e *= this.itemSize, this.normalized && (t = mt(t, this.array), n = mt(n, this.array), i = mt(i, this.array), s = mt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized
      };
      return this.name !== "" && (e.name = this.name), this.usage !== no && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
    }
    copyColorsArray() {
      console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
    }
    copyVector2sArray() {
      console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
    }
    copyVector3sArray() {
      console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
    }
    copyVector4sArray() {
      console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
    }
  }
  class ex extends ht {
    constructor(e, t, n) {
      super(new Int8Array(e), t, n);
    }
  }
  class tx extends ht {
    constructor(e, t, n) {
      super(new Uint8Array(e), t, n);
    }
  }
  class nx extends ht {
    constructor(e, t, n) {
      super(new Uint8ClampedArray(e), t, n);
    }
  }
  class ix extends ht {
    constructor(e, t, n) {
      super(new Int16Array(e), t, n);
    }
  }
  class Ch extends ht {
    constructor(e, t, n) {
      super(new Uint16Array(e), t, n);
    }
  }
  class sx extends ht {
    constructor(e, t, n) {
      super(new Int32Array(e), t, n);
    }
  }
  class Ah extends ht {
    constructor(e, t, n) {
      super(new Uint32Array(e), t, n);
    }
  }
  class rx extends ht {
    constructor(e, t, n) {
      super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = true;
    }
  }
  class Pe extends ht {
    constructor(e, t, n) {
      super(new Float32Array(e), t, n);
    }
  }
  class ox extends ht {
    constructor(e, t, n) {
      super(new Float64Array(e), t, n);
    }
  }
  let ax = 0;
  const gn = new ze(), ec = new rt(), Os = new P(), hn = new Bn(), Nr = new Bn(), Ht = new P();
  class Xe extends zn {
    constructor() {
      super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
        value: ax++
      }), this.uuid = dn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
        start: 0,
        count: 1 / 0
      }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return Array.isArray(e) ? this.index = new (Yf(e) ? Ah : Ch)(e, 1) : this.index = e, this;
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return this.attributes[e] = t, this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return this.attributes[e] !== void 0;
    }
    addGroup(e, t, n = 0) {
      this.groups.push({
        start: e,
        count: t,
        materialIndex: n
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      this.drawRange.start = e, this.drawRange.count = t;
    }
    applyMatrix4(e) {
      const t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
      const n = this.attributes.normal;
      if (n !== void 0) {
        const s = new nn().getNormalMatrix(e);
        n.applyNormalMatrix(s), n.needsUpdate = true;
      }
      const i = this.attributes.tangent;
      return i !== void 0 && (i.transformDirection(e), i.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(e) {
      return gn.makeRotationFromQuaternion(e), this.applyMatrix4(gn), this;
    }
    rotateX(e) {
      return gn.makeRotationX(e), this.applyMatrix4(gn), this;
    }
    rotateY(e) {
      return gn.makeRotationY(e), this.applyMatrix4(gn), this;
    }
    rotateZ(e) {
      return gn.makeRotationZ(e), this.applyMatrix4(gn), this;
    }
    translate(e, t, n) {
      return gn.makeTranslation(e, t, n), this.applyMatrix4(gn), this;
    }
    scale(e, t, n) {
      return gn.makeScale(e, t, n), this.applyMatrix4(gn), this;
    }
    lookAt(e) {
      return ec.lookAt(e), ec.updateMatrix(), this.applyMatrix4(ec.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(Os).negate(), this.translate(Os.x, Os.y, Os.z), this;
    }
    setFromPoints(e) {
      const t = [];
      for (let n = 0, i = e.length; n < i; n++) {
        const s = e[n];
        t.push(s.x, s.y, s.z || 0);
      }
      return this.setAttribute("position", new Pe(t, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Bn());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new P(-1 / 0, -1 / 0, -1 / 0), new P(1 / 0, 1 / 0, 1 / 0));
        return;
      }
      if (e !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(e), t) for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          hn.setFromBufferAttribute(s), this.morphTargetsRelative ? (Ht.addVectors(this.boundingBox.min, hn.min), this.boundingBox.expandByPoint(Ht), Ht.addVectors(this.boundingBox.max, hn.max), this.boundingBox.expandByPoint(Ht)) : (this.boundingBox.expandByPoint(hn.min), this.boundingBox.expandByPoint(hn.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new Ii());
      const e = this.attributes.position, t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new P(), 1 / 0);
        return;
      }
      if (e) {
        const n = this.boundingSphere.center;
        if (hn.setFromBufferAttribute(e), t) for (let s = 0, r = t.length; s < r; s++) {
          const a = t[s];
          Nr.setFromBufferAttribute(a), this.morphTargetsRelative ? (Ht.addVectors(hn.min, Nr.min), hn.expandByPoint(Ht), Ht.addVectors(hn.max, Nr.max), hn.expandByPoint(Ht)) : (hn.expandByPoint(Nr.min), hn.expandByPoint(Nr.max));
        }
        hn.getCenter(n);
        let i = 0;
        for (let s = 0, r = e.count; s < r; s++) Ht.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(Ht));
        if (t) for (let s = 0, r = t.length; s < r; s++) {
          const a = t[s], c = this.morphTargetsRelative;
          for (let u = 0, p = a.count; u < p; u++) Ht.fromBufferAttribute(a, u), c && (Os.fromBufferAttribute(e, u), Ht.add(Os)), i = Math.max(i, n.distanceToSquared(Ht));
        }
        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      const e = this.index, t = this.attributes;
      if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const n = e.array, i = t.position.array, s = t.normal.array, r = t.uv.array, a = i.length / 3;
      this.hasAttribute("tangent") === false && this.setAttribute("tangent", new ht(new Float32Array(4 * a), 4));
      const c = this.getAttribute("tangent").array, u = [], p = [];
      for (let F = 0; F < a; F++) u[F] = new P(), p[F] = new P();
      const f = new P(), m = new P(), v = new P(), b = new te(), _ = new te(), x = new te(), w = new P(), S = new P();
      function y(F, j, Y) {
        f.fromArray(i, F * 3), m.fromArray(i, j * 3), v.fromArray(i, Y * 3), b.fromArray(r, F * 2), _.fromArray(r, j * 2), x.fromArray(r, Y * 2), m.sub(f), v.sub(f), _.sub(b), x.sub(b);
        const z = 1 / (_.x * x.y - x.x * _.y);
        isFinite(z) && (w.copy(m).multiplyScalar(x.y).addScaledVector(v, -_.y).multiplyScalar(z), S.copy(v).multiplyScalar(_.x).addScaledVector(m, -x.x).multiplyScalar(z), u[F].add(w), u[j].add(w), u[Y].add(w), p[F].add(S), p[j].add(S), p[Y].add(S));
      }
      let M = this.groups;
      M.length === 0 && (M = [
        {
          start: 0,
          count: n.length
        }
      ]);
      for (let F = 0, j = M.length; F < j; ++F) {
        const Y = M[F], z = Y.start, B = Y.count;
        for (let Z = z, ie = z + B; Z < ie; Z += 3) y(n[Z + 0], n[Z + 1], n[Z + 2]);
      }
      const C = new P(), R = new P(), k = new P(), T = new P();
      function L(F) {
        k.fromArray(s, F * 3), T.copy(k);
        const j = u[F];
        C.copy(j), C.sub(k.multiplyScalar(k.dot(j))).normalize(), R.crossVectors(T, j);
        const z = R.dot(p[F]) < 0 ? -1 : 1;
        c[F * 4] = C.x, c[F * 4 + 1] = C.y, c[F * 4 + 2] = C.z, c[F * 4 + 3] = z;
      }
      for (let F = 0, j = M.length; F < j; ++F) {
        const Y = M[F], z = Y.start, B = Y.count;
        for (let Z = z, ie = z + B; Z < ie; Z += 3) L(n[Z + 0]), L(n[Z + 1]), L(n[Z + 2]);
      }
    }
    computeVertexNormals() {
      const e = this.index, t = this.getAttribute("position");
      if (t !== void 0) {
        let n = this.getAttribute("normal");
        if (n === void 0) n = new ht(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
        else for (let m = 0, v = n.count; m < v; m++) n.setXYZ(m, 0, 0, 0);
        const i = new P(), s = new P(), r = new P(), a = new P(), c = new P(), u = new P(), p = new P(), f = new P();
        if (e) for (let m = 0, v = e.count; m < v; m += 3) {
          const b = e.getX(m + 0), _ = e.getX(m + 1), x = e.getX(m + 2);
          i.fromBufferAttribute(t, b), s.fromBufferAttribute(t, _), r.fromBufferAttribute(t, x), p.subVectors(r, s), f.subVectors(i, s), p.cross(f), a.fromBufferAttribute(n, b), c.fromBufferAttribute(n, _), u.fromBufferAttribute(n, x), a.add(p), c.add(p), u.add(p), n.setXYZ(b, a.x, a.y, a.z), n.setXYZ(_, c.x, c.y, c.z), n.setXYZ(x, u.x, u.y, u.z);
        }
        else for (let m = 0, v = t.count; m < v; m += 3) i.fromBufferAttribute(t, m + 0), s.fromBufferAttribute(t, m + 1), r.fromBufferAttribute(t, m + 2), p.subVectors(r, s), f.subVectors(i, s), p.cross(f), n.setXYZ(m + 0, p.x, p.y, p.z), n.setXYZ(m + 1, p.x, p.y, p.z), n.setXYZ(m + 2, p.x, p.y, p.z);
        this.normalizeNormals(), n.needsUpdate = true;
      }
    }
    merge() {
      return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this;
    }
    normalizeNormals() {
      const e = this.attributes.normal;
      for (let t = 0, n = e.count; t < n; t++) Ht.fromBufferAttribute(e, t), Ht.normalize(), e.setXYZ(t, Ht.x, Ht.y, Ht.z);
    }
    toNonIndexed() {
      function e(a, c) {
        const u = a.array, p = a.itemSize, f = a.normalized, m = new u.constructor(c.length * p);
        let v = 0, b = 0;
        for (let _ = 0, x = c.length; _ < x; _++) {
          a.isInterleavedBufferAttribute ? v = c[_] * a.data.stride + a.offset : v = c[_] * p;
          for (let w = 0; w < p; w++) m[b++] = u[v++];
        }
        return new ht(m, p, f);
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t = new Xe(), n = this.index.array, i = this.attributes;
      for (const a in i) {
        const c = i[a], u = e(c, n);
        t.setAttribute(a, u);
      }
      const s = this.morphAttributes;
      for (const a in s) {
        const c = [], u = s[a];
        for (let p = 0, f = u.length; p < f; p++) {
          const m = u[p], v = e(m, n);
          c.push(v);
        }
        t.morphAttributes[a] = c;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const r = this.groups;
      for (let a = 0, c = r.length; a < c; a++) {
        const u = r[a];
        t.addGroup(u.start, u.count, u.materialIndex);
      }
      return t;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
        const c = this.parameters;
        for (const u in c) c[u] !== void 0 && (e[u] = c[u]);
        return e;
      }
      e.data = {
        attributes: {}
      };
      const t = this.index;
      t !== null && (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array)
      });
      const n = this.attributes;
      for (const c in n) {
        const u = n[c];
        e.data.attributes[c] = u.toJSON(e.data);
      }
      const i = {};
      let s = false;
      for (const c in this.morphAttributes) {
        const u = this.morphAttributes[c], p = [];
        for (let f = 0, m = u.length; f < m; f++) {
          const v = u[f];
          p.push(v.toJSON(e.data));
        }
        p.length > 0 && (i[c] = p, s = true);
      }
      s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
      const r = this.groups;
      r.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(r)));
      const a = this.boundingSphere;
      return a !== null && (e.data.boundingSphere = {
        center: a.center.toArray(),
        radius: a.radius
      }), e;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t = {};
      this.name = e.name;
      const n = e.index;
      n !== null && this.setIndex(n.clone(t));
      const i = e.attributes;
      for (const u in i) {
        const p = i[u];
        this.setAttribute(u, p.clone(t));
      }
      const s = e.morphAttributes;
      for (const u in s) {
        const p = [], f = s[u];
        for (let m = 0, v = f.length; m < v; m++) p.push(f[m].clone(t));
        this.morphAttributes[u] = p;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const r = e.groups;
      for (let u = 0, p = r.length; u < p; u++) {
        const f = r[u];
        this.addGroup(f.start, f.count, f.materialIndex);
      }
      const a = e.boundingBox;
      a !== null && (this.boundingBox = a.clone());
      const c = e.boundingSphere;
      return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  const Sd = new ze(), Fs = new fo(), tc = new Ii(), Or = new P(), Fr = new P(), Br = new P(), nc = new P(), ea = new P(), ta = new te(), na = new te(), ia = new te(), ic = new P(), sa = new P();
  class kt extends rt {
    constructor(e = new Xe(), t = new $t()) {
      super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, r = i.length; s < r; s++) {
            const a = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
    getVertexPosition(e, t) {
      const n = this.geometry, i = n.attributes.position, s = n.morphAttributes.position, r = n.morphTargetsRelative;
      t.fromBufferAttribute(i, e);
      const a = this.morphTargetInfluences;
      if (s && a) {
        ea.set(0, 0, 0);
        for (let c = 0, u = s.length; c < u; c++) {
          const p = a[c], f = s[c];
          p !== 0 && (nc.fromBufferAttribute(f, e), r ? ea.addScaledVector(nc, p) : ea.addScaledVector(nc.sub(t), p));
        }
        t.add(ea);
      }
      return this.isSkinnedMesh && this.boneTransform(e, t), t;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.material, s = this.matrixWorld;
      if (i === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), tc.copy(n.boundingSphere), tc.applyMatrix4(s), e.ray.intersectsSphere(tc) === false) || (Sd.copy(s).invert(), Fs.copy(e.ray).applyMatrix4(Sd), n.boundingBox !== null && Fs.intersectsBox(n.boundingBox) === false)) return;
      let r;
      const a = n.index, c = n.attributes.position, u = n.attributes.uv, p = n.attributes.uv2, f = n.groups, m = n.drawRange;
      if (a !== null) if (Array.isArray(i)) for (let v = 0, b = f.length; v < b; v++) {
        const _ = f[v], x = i[_.materialIndex], w = Math.max(_.start, m.start), S = Math.min(a.count, Math.min(_.start + _.count, m.start + m.count));
        for (let y = w, M = S; y < M; y += 3) {
          const C = a.getX(y), R = a.getX(y + 1), k = a.getX(y + 2);
          r = ra(this, x, e, Fs, u, p, C, R, k), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = _.materialIndex, t.push(r));
        }
      }
      else {
        const v = Math.max(0, m.start), b = Math.min(a.count, m.start + m.count);
        for (let _ = v, x = b; _ < x; _ += 3) {
          const w = a.getX(_), S = a.getX(_ + 1), y = a.getX(_ + 2);
          r = ra(this, i, e, Fs, u, p, w, S, y), r && (r.faceIndex = Math.floor(_ / 3), t.push(r));
        }
      }
      else if (c !== void 0) if (Array.isArray(i)) for (let v = 0, b = f.length; v < b; v++) {
        const _ = f[v], x = i[_.materialIndex], w = Math.max(_.start, m.start), S = Math.min(c.count, Math.min(_.start + _.count, m.start + m.count));
        for (let y = w, M = S; y < M; y += 3) {
          const C = y, R = y + 1, k = y + 2;
          r = ra(this, x, e, Fs, u, p, C, R, k), r && (r.faceIndex = Math.floor(y / 3), r.face.materialIndex = _.materialIndex, t.push(r));
        }
      }
      else {
        const v = Math.max(0, m.start), b = Math.min(c.count, m.start + m.count);
        for (let _ = v, x = b; _ < x; _ += 3) {
          const w = _, S = _ + 1, y = _ + 2;
          r = ra(this, i, e, Fs, u, p, w, S, y), r && (r.faceIndex = Math.floor(_ / 3), t.push(r));
        }
      }
    }
  }
  function lx(l, e, t, n, i, s, r, a) {
    let c;
    if (e.side === on ? c = n.intersectTriangle(r, s, i, true, a) : c = n.intersectTriangle(i, s, r, e.side === On, a), c === null) return null;
    sa.copy(a), sa.applyMatrix4(l.matrixWorld);
    const u = t.ray.origin.distanceTo(sa);
    return u < t.near || u > t.far ? null : {
      distance: u,
      point: sa.clone(),
      object: l
    };
  }
  function ra(l, e, t, n, i, s, r, a, c) {
    l.getVertexPosition(r, Or), l.getVertexPosition(a, Fr), l.getVertexPosition(c, Br);
    const u = lx(l, e, t, n, Or, Fr, Br, ic);
    if (u) {
      i && (ta.fromBufferAttribute(i, r), na.fromBufferAttribute(i, a), ia.fromBufferAttribute(i, c), u.uv = xn.getUV(ic, Or, Fr, Br, ta, na, ia, new te())), s && (ta.fromBufferAttribute(s, r), na.fromBufferAttribute(s, a), ia.fromBufferAttribute(s, c), u.uv2 = xn.getUV(ic, Or, Fr, Br, ta, na, ia, new te()));
      const p = {
        a: r,
        b: a,
        c,
        normal: new P(),
        materialIndex: 0
      };
      xn.getNormal(Or, Fr, Br, p.normal), u.face = p;
    }
    return u;
  }
  class Vn extends Xe {
    constructor(e = 1, t = 1, n = 1, i = 1, s = 1, r = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: r
      };
      const a = this;
      i = Math.floor(i), s = Math.floor(s), r = Math.floor(r);
      const c = [], u = [], p = [], f = [];
      let m = 0, v = 0;
      b("z", "y", "x", -1, -1, n, t, e, r, s, 0), b("z", "y", "x", 1, -1, n, t, -e, r, s, 1), b("x", "z", "y", 1, 1, e, n, t, i, r, 2), b("x", "z", "y", 1, -1, e, n, -t, i, r, 3), b("x", "y", "z", 1, -1, e, t, n, i, s, 4), b("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(c), this.setAttribute("position", new Pe(u, 3)), this.setAttribute("normal", new Pe(p, 3)), this.setAttribute("uv", new Pe(f, 2));
      function b(_, x, w, S, y, M, C, R, k, T, L) {
        const F = M / k, j = C / T, Y = M / 2, z = C / 2, B = R / 2, Z = k + 1, ie = T + 1;
        let re = 0, W = 0;
        const pe = new P();
        for (let ae = 0; ae < ie; ae++) {
          const Te = ae * j - z;
          for (let q = 0; q < Z; q++) {
            const le = q * F - Y;
            pe[_] = le * S, pe[x] = Te * y, pe[w] = B, u.push(pe.x, pe.y, pe.z), pe[_] = 0, pe[x] = 0, pe[w] = R > 0 ? 1 : -1, p.push(pe.x, pe.y, pe.z), f.push(q / k), f.push(1 - ae / T), re += 1;
          }
        }
        for (let ae = 0; ae < T; ae++) for (let Te = 0; Te < k; Te++) {
          const q = m + Te + Z * ae, le = m + Te + Z * (ae + 1), oe = m + (Te + 1) + Z * (ae + 1), ce = m + (Te + 1) + Z * ae;
          c.push(q, le, ce), c.push(le, oe, ce), W += 6;
        }
        a.addGroup(v, W, L), v += W, m += re;
      }
    }
    static fromJSON(e) {
      return new Vn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
    }
  }
  function sr(l) {
    const e = {};
    for (const t in l) {
      e[t] = {};
      for (const n in l[t]) {
        const i = l[t][n];
        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
      }
    }
    return e;
  }
  function tn(l) {
    const e = {};
    for (let t = 0; t < l.length; t++) {
      const n = sr(l[t]);
      for (const i in n) e[i] = n[i];
    }
    return e;
  }
  function cx(l) {
    const e = [];
    for (let t = 0; t < l.length; t++) e.push(l[t].clone());
    return e;
  }
  function Zf(l) {
    return l.getRenderTarget() === null && l.outputEncoding === ct ? Sn : ir;
  }
  const Jf = {
    clone: sr,
    merge: tn
  };
  var hx = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, ux = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
  class Un extends Bt {
    constructor(e) {
      super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = hx, this.fragmentShader = ux, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
      }, this.defaultAttributeValues = {
        color: [
          1,
          1,
          1
        ],
        uv: [
          0,
          0
        ],
        uv2: [
          0,
          0
        ]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = sr(e.uniforms), this.uniformsGroups = cx(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      t.glslVersion = this.glslVersion, t.uniforms = {};
      for (const i in this.uniforms) {
        const r = this.uniforms[i].value;
        r && r.isTexture ? t.uniforms[i] = {
          type: "t",
          value: r.toJSON(e).uuid
        } : r && r.isColor ? t.uniforms[i] = {
          type: "c",
          value: r.getHex()
        } : r && r.isVector2 ? t.uniforms[i] = {
          type: "v2",
          value: r.toArray()
        } : r && r.isVector3 ? t.uniforms[i] = {
          type: "v3",
          value: r.toArray()
        } : r && r.isVector4 ? t.uniforms[i] = {
          type: "v4",
          value: r.toArray()
        } : r && r.isMatrix3 ? t.uniforms[i] = {
          type: "m3",
          value: r.toArray()
        } : r && r.isMatrix4 ? t.uniforms[i] = {
          type: "m4",
          value: r.toArray()
        } : t.uniforms[i] = {
          value: r
        };
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
      const n = {};
      for (const i in this.extensions) this.extensions[i] === true && (n[i] = true);
      return Object.keys(n).length > 0 && (t.extensions = n), t;
    }
  }
  let Ja = class extends rt {
    constructor() {
      super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new ze(), this.projectionMatrix = new ze(), this.projectionMatrixInverse = new ze();
    }
    copy(e, t) {
      return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(true, false);
      const t = this.matrixWorld.elements;
      return e.set(-t[8], -t[9], -t[10]).normalize();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  class Ft extends Ja {
    constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
      super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
    }
    setFocalLength(e) {
      const t = 0.5 * this.getFilmHeight() / e;
      this.fov = io * 2 * Math.atan(t), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e = Math.tan(as * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / e;
    }
    getEffectiveFOV() {
      return io * 2 * Math.atan(Math.tan(as * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, n, i, s, r) {
      this.aspect = e / t, this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = this.near;
      let t = e * Math.tan(as * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, s = -0.5 * i;
      const r = this.view;
      if (this.view !== null && this.view.enabled) {
        const c = r.fullWidth, u = r.fullHeight;
        s += r.offsetX * i / c, t -= r.offsetY * n / u, i *= r.width / c, n *= r.height / u;
      }
      const a = this.filmOffset;
      a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
    }
  }
  const Bs = -90, Us = 1;
  class Qf extends rt {
    constructor(e, t, n) {
      super(), this.type = "CubeCamera", this.renderTarget = n;
      const i = new Ft(Bs, Us, e, t);
      i.layers = this.layers, i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i);
      const s = new Ft(Bs, Us, e, t);
      s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s);
      const r = new Ft(Bs, Us, e, t);
      r.layers = this.layers, r.up.set(0, 0, -1), r.lookAt(0, 1, 0), this.add(r);
      const a = new Ft(Bs, Us, e, t);
      a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a);
      const c = new Ft(Bs, Us, e, t);
      c.layers = this.layers, c.up.set(0, 1, 0), c.lookAt(0, 0, 1), this.add(c);
      const u = new Ft(Bs, Us, e, t);
      u.layers = this.layers, u.up.set(0, 1, 0), u.lookAt(0, 0, -1), this.add(u);
    }
    update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      const n = this.renderTarget, [i, s, r, a, c, u] = this.children, p = e.getRenderTarget(), f = e.toneMapping, m = e.xr.enabled;
      e.toneMapping = kn, e.xr.enabled = false;
      const v = n.texture.generateMipmaps;
      n.texture.generateMipmaps = false, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, r), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(p), e.toneMapping = f, e.xr.enabled = m, n.texture.needsPMREMUpdate = true;
    }
  }
  class go extends Mt {
    constructor(e, t, n, i, s, r, a, c, u, p) {
      e = e !== void 0 ? e : [], t = t !== void 0 ? t : Si, super(e, t, n, i, s, r, a, c, u, p), this.isCubeTexture = true, this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  }
  class em extends Tn {
    constructor(e = 1, t = {}) {
      super(e, e, t), this.isWebGLCubeRenderTarget = true;
      const n = {
        width: e,
        height: e,
        depth: 1
      }, i = [
        n,
        n,
        n,
        n,
        n,
        n
      ];
      this.texture = new go(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : yt;
    }
    fromEquirectangularTexture(e, t) {
      this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
      const n = {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      }, i = new Vn(5, 5, 5), s = new Un({
        name: "CubemapFromEquirect",
        uniforms: sr(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: on,
        blending: ii
      });
      s.uniforms.tEquirect.value = t;
      const r = new kt(i, s), a = t.minFilter;
      return t.minFilter === Fn && (t.minFilter = yt), new Qf(1, 10, this).update(e, r), t.minFilter = a, r.geometry.dispose(), r.material.dispose(), this;
    }
    clear(e, t, n, i) {
      const s = e.getRenderTarget();
      for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
      e.setRenderTarget(s);
    }
  }
  const sc = new P(), dx = new P(), px = new nn();
  class bi {
    constructor(e = new P(1, 0, 0), t = 0) {
      this.isPlane = true, this.normal = e, this.constant = t;
    }
    set(e, t) {
      return this.normal.copy(e), this.constant = t, this;
    }
    setComponents(e, t, n, i) {
      return this.normal.set(e, t, n), this.constant = i, this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
    }
    setFromCoplanarPoints(e, t, n) {
      const i = sc.subVectors(n, t).cross(dx.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), this.constant = e.constant, this;
    }
    normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
    }
    intersectLine(e, t) {
      const n = e.delta(sc), i = this.normal.dot(n);
      if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
      const s = -(e.start.dot(this.normal) + this.constant) / i;
      return s < 0 || s > 1 ? null : t.copy(n).multiplyScalar(s).add(e.start);
    }
    intersectsLine(e) {
      const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
      return t < 0 && n > 0 || n < 0 && t > 0;
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      const n = t || px.getNormalMatrix(e), i = this.coplanarPoint(sc).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize();
      return this.constant = -i.dot(s), this;
    }
    translate(e) {
      return this.constant -= e.dot(this.normal), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const zs = new Ii(), oa = new P();
  class Qa {
    constructor(e = new bi(), t = new bi(), n = new bi(), i = new bi(), s = new bi(), r = new bi()) {
      this.planes = [
        e,
        t,
        n,
        i,
        s,
        r
      ];
    }
    set(e, t, n, i, s, r) {
      const a = this.planes;
      return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(s), a[5].copy(r), this;
    }
    copy(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
      return this;
    }
    setFromProjectionMatrix(e) {
      const t = this.planes, n = e.elements, i = n[0], s = n[1], r = n[2], a = n[3], c = n[4], u = n[5], p = n[6], f = n[7], m = n[8], v = n[9], b = n[10], _ = n[11], x = n[12], w = n[13], S = n[14], y = n[15];
      return t[0].setComponents(a - i, f - c, _ - m, y - x).normalize(), t[1].setComponents(a + i, f + c, _ + m, y + x).normalize(), t[2].setComponents(a + s, f + u, _ + v, y + w).normalize(), t[3].setComponents(a - s, f - u, _ - v, y - w).normalize(), t[4].setComponents(a - r, f - p, _ - b, y - S).normalize(), t[5].setComponents(a + r, f + p, _ + b, y + S).normalize(), this;
    }
    intersectsObject(e) {
      const t = e.geometry;
      return t.boundingSphere === null && t.computeBoundingSphere(), zs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(zs);
    }
    intersectsSprite(e) {
      return zs.center.set(0, 0, 0), zs.radius = 0.7071067811865476, zs.applyMatrix4(e.matrixWorld), this.intersectsSphere(zs);
    }
    intersectsSphere(e) {
      const t = this.planes, n = e.center, i = -e.radius;
      for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < i) return false;
      return true;
    }
    intersectsBox(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = t[n];
        if (oa.x = i.normal.x > 0 ? e.max.x : e.min.x, oa.y = i.normal.y > 0 ? e.max.y : e.min.y, oa.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(oa) < 0) return false;
      }
      return true;
    }
    containsPoint(e) {
      const t = this.planes;
      for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function tm() {
    let l = null, e = false, t = null, n = null;
    function i(s, r) {
      t(s, r), n = l.requestAnimationFrame(i);
    }
    return {
      start: function() {
        e !== true && t !== null && (n = l.requestAnimationFrame(i), e = true);
      },
      stop: function() {
        l.cancelAnimationFrame(n), e = false;
      },
      setAnimationLoop: function(s) {
        t = s;
      },
      setContext: function(s) {
        l = s;
      }
    };
  }
  function fx(l, e) {
    const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
    function i(u, p) {
      const f = u.array, m = u.usage, v = l.createBuffer();
      l.bindBuffer(p, v), l.bufferData(p, f, m), u.onUploadCallback();
      let b;
      if (f instanceof Float32Array) b = 5126;
      else if (f instanceof Uint16Array) if (u.isFloat16BufferAttribute) if (t) b = 5131;
      else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else b = 5123;
      else if (f instanceof Int16Array) b = 5122;
      else if (f instanceof Uint32Array) b = 5125;
      else if (f instanceof Int32Array) b = 5124;
      else if (f instanceof Int8Array) b = 5120;
      else if (f instanceof Uint8Array) b = 5121;
      else if (f instanceof Uint8ClampedArray) b = 5121;
      else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
      return {
        buffer: v,
        type: b,
        bytesPerElement: f.BYTES_PER_ELEMENT,
        version: u.version
      };
    }
    function s(u, p, f) {
      const m = p.array, v = p.updateRange;
      l.bindBuffer(f, u), v.count === -1 ? l.bufferSubData(f, 0, m) : (t ? l.bufferSubData(f, v.offset * m.BYTES_PER_ELEMENT, m, v.offset, v.count) : l.bufferSubData(f, v.offset * m.BYTES_PER_ELEMENT, m.subarray(v.offset, v.offset + v.count)), v.count = -1), p.onUploadCallback();
    }
    function r(u) {
      return u.isInterleavedBufferAttribute && (u = u.data), n.get(u);
    }
    function a(u) {
      u.isInterleavedBufferAttribute && (u = u.data);
      const p = n.get(u);
      p && (l.deleteBuffer(p.buffer), n.delete(u));
    }
    function c(u, p) {
      if (u.isGLBufferAttribute) {
        const m = n.get(u);
        (!m || m.version < u.version) && n.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version
        });
        return;
      }
      u.isInterleavedBufferAttribute && (u = u.data);
      const f = n.get(u);
      f === void 0 ? n.set(u, i(u, p)) : f.version < u.version && (s(f.buffer, u, p), f.version = u.version);
    }
    return {
      get: r,
      remove: a,
      update: c
    };
  }
  class ur extends Xe {
    constructor(e = 1, t = 1, n = 1, i = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i
      };
      const s = e / 2, r = t / 2, a = Math.floor(n), c = Math.floor(i), u = a + 1, p = c + 1, f = e / a, m = t / c, v = [], b = [], _ = [], x = [];
      for (let w = 0; w < p; w++) {
        const S = w * m - r;
        for (let y = 0; y < u; y++) {
          const M = y * f - s;
          b.push(M, -S, 0), _.push(0, 0, 1), x.push(y / a), x.push(1 - w / c);
        }
      }
      for (let w = 0; w < c; w++) for (let S = 0; S < a; S++) {
        const y = S + u * w, M = S + u * (w + 1), C = S + 1 + u * (w + 1), R = S + 1 + u * w;
        v.push(y, M, R), v.push(M, C, R);
      }
      this.setIndex(v), this.setAttribute("position", new Pe(b, 3)), this.setAttribute("normal", new Pe(_, 3)), this.setAttribute("uv", new Pe(x, 2));
    }
    static fromJSON(e) {
      return new ur(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  }
  var mx = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, gx = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, vx = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, _x = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, xx = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, bx = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, yx = "vec3 transformed = vec3( position );", wx = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Mx = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, Sx = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Ex = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Tx = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, Cx = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Ax = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Px = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Lx = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Rx = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Ix = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Dx = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, kx = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, Nx = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Ox = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Fx = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Bx = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, Ux = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, zx = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Vx = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Gx = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Hx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Wx = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, qx = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Xx = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, jx = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Kx = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Yx = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, $x = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Zx = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Jx = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Qx = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, eb = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, tb = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, nb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, ib = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, sb = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, rb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, ob = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ab = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, lb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, cb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, hb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, ub = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, db = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, pb = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, fb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, mb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, gb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, vb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, _b = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, xb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, bb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, yb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, wb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Mb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Sb = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Eb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Tb = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, Cb = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Ab = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, Pb = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Lb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Rb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Ib = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Db = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, kb = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, Nb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, Ob = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, Fb = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Bb = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Ub = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, zb = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Vb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Gb = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Hb = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Wb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, qb = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Xb = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, jb = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Kb = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Yb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, $b = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Zb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, Jb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Qb = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, ey = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ty = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, ny = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, iy = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, sy = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, ry = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, oy = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, ay = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, ly = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, cy = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, hy = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, uy = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, dy = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
  const py = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, fy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, my = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, gy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, vy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, _y = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, xy = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, by = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, yy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, wy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, My = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Sy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, Ey = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ty = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Cy = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Ay = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Py = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ly = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ry = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Iy = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Dy = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, ky = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Ny = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Oy = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Fy = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, By = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Uy = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zy = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Vy = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Gy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Hy = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Wy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, qy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Xy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Ye = {
    alphamap_fragment: mx,
    alphamap_pars_fragment: gx,
    alphatest_fragment: vx,
    alphatest_pars_fragment: _x,
    aomap_fragment: xx,
    aomap_pars_fragment: bx,
    begin_vertex: yx,
    beginnormal_vertex: wx,
    bsdfs: Mx,
    iridescence_fragment: Sx,
    bumpmap_pars_fragment: Ex,
    clipping_planes_fragment: Tx,
    clipping_planes_pars_fragment: Cx,
    clipping_planes_pars_vertex: Ax,
    clipping_planes_vertex: Px,
    color_fragment: Lx,
    color_pars_fragment: Rx,
    color_pars_vertex: Ix,
    color_vertex: Dx,
    common: kx,
    cube_uv_reflection_fragment: Nx,
    defaultnormal_vertex: Ox,
    displacementmap_pars_vertex: Fx,
    displacementmap_vertex: Bx,
    emissivemap_fragment: Ux,
    emissivemap_pars_fragment: zx,
    encodings_fragment: Vx,
    encodings_pars_fragment: Gx,
    envmap_fragment: Hx,
    envmap_common_pars_fragment: Wx,
    envmap_pars_fragment: qx,
    envmap_pars_vertex: Xx,
    envmap_physical_pars_fragment: sb,
    envmap_vertex: jx,
    fog_vertex: Kx,
    fog_pars_vertex: Yx,
    fog_fragment: $x,
    fog_pars_fragment: Zx,
    gradientmap_pars_fragment: Jx,
    lightmap_fragment: Qx,
    lightmap_pars_fragment: eb,
    lights_lambert_fragment: tb,
    lights_lambert_pars_fragment: nb,
    lights_pars_begin: ib,
    lights_toon_fragment: rb,
    lights_toon_pars_fragment: ob,
    lights_phong_fragment: ab,
    lights_phong_pars_fragment: lb,
    lights_physical_fragment: cb,
    lights_physical_pars_fragment: hb,
    lights_fragment_begin: ub,
    lights_fragment_maps: db,
    lights_fragment_end: pb,
    logdepthbuf_fragment: fb,
    logdepthbuf_pars_fragment: mb,
    logdepthbuf_pars_vertex: gb,
    logdepthbuf_vertex: vb,
    map_fragment: _b,
    map_pars_fragment: xb,
    map_particle_fragment: bb,
    map_particle_pars_fragment: yb,
    metalnessmap_fragment: wb,
    metalnessmap_pars_fragment: Mb,
    morphcolor_vertex: Sb,
    morphnormal_vertex: Eb,
    morphtarget_pars_vertex: Tb,
    morphtarget_vertex: Cb,
    normal_fragment_begin: Ab,
    normal_fragment_maps: Pb,
    normal_pars_fragment: Lb,
    normal_pars_vertex: Rb,
    normal_vertex: Ib,
    normalmap_pars_fragment: Db,
    clearcoat_normal_fragment_begin: kb,
    clearcoat_normal_fragment_maps: Nb,
    clearcoat_pars_fragment: Ob,
    iridescence_pars_fragment: Fb,
    output_fragment: Bb,
    packing: Ub,
    premultiplied_alpha_fragment: zb,
    project_vertex: Vb,
    dithering_fragment: Gb,
    dithering_pars_fragment: Hb,
    roughnessmap_fragment: Wb,
    roughnessmap_pars_fragment: qb,
    shadowmap_pars_fragment: Xb,
    shadowmap_pars_vertex: jb,
    shadowmap_vertex: Kb,
    shadowmask_pars_fragment: Yb,
    skinbase_vertex: $b,
    skinning_pars_vertex: Zb,
    skinning_vertex: Jb,
    skinnormal_vertex: Qb,
    specularmap_fragment: ey,
    specularmap_pars_fragment: ty,
    tonemapping_fragment: ny,
    tonemapping_pars_fragment: iy,
    transmission_fragment: sy,
    transmission_pars_fragment: ry,
    uv_pars_fragment: oy,
    uv_pars_vertex: ay,
    uv_vertex: ly,
    uv2_pars_fragment: cy,
    uv2_pars_vertex: hy,
    uv2_vertex: uy,
    worldpos_vertex: dy,
    background_vert: py,
    background_frag: fy,
    backgroundCube_vert: my,
    backgroundCube_frag: gy,
    cube_vert: vy,
    cube_frag: _y,
    depth_vert: xy,
    depth_frag: by,
    distanceRGBA_vert: yy,
    distanceRGBA_frag: wy,
    equirect_vert: My,
    equirect_frag: Sy,
    linedashed_vert: Ey,
    linedashed_frag: Ty,
    meshbasic_vert: Cy,
    meshbasic_frag: Ay,
    meshlambert_vert: Py,
    meshlambert_frag: Ly,
    meshmatcap_vert: Ry,
    meshmatcap_frag: Iy,
    meshnormal_vert: Dy,
    meshnormal_frag: ky,
    meshphong_vert: Ny,
    meshphong_frag: Oy,
    meshphysical_vert: Fy,
    meshphysical_frag: By,
    meshtoon_vert: Uy,
    meshtoon_frag: zy,
    points_vert: Vy,
    points_frag: Gy,
    shadow_vert: Hy,
    shadow_frag: Wy,
    sprite_vert: qy,
    sprite_frag: Xy
  }, _e = {
    common: {
      diffuse: {
        value: new we(16777215)
      },
      opacity: {
        value: 1
      },
      map: {
        value: null
      },
      uvTransform: {
        value: new nn()
      },
      uv2Transform: {
        value: new nn()
      },
      alphaMap: {
        value: null
      },
      alphaTest: {
        value: 0
      }
    },
    specularmap: {
      specularMap: {
        value: null
      }
    },
    envmap: {
      envMap: {
        value: null
      },
      flipEnvMap: {
        value: -1
      },
      reflectivity: {
        value: 1
      },
      ior: {
        value: 1.5
      },
      refractionRatio: {
        value: 0.98
      }
    },
    aomap: {
      aoMap: {
        value: null
      },
      aoMapIntensity: {
        value: 1
      }
    },
    lightmap: {
      lightMap: {
        value: null
      },
      lightMapIntensity: {
        value: 1
      }
    },
    emissivemap: {
      emissiveMap: {
        value: null
      }
    },
    bumpmap: {
      bumpMap: {
        value: null
      },
      bumpScale: {
        value: 1
      }
    },
    normalmap: {
      normalMap: {
        value: null
      },
      normalScale: {
        value: new te(1, 1)
      }
    },
    displacementmap: {
      displacementMap: {
        value: null
      },
      displacementScale: {
        value: 1
      },
      displacementBias: {
        value: 0
      }
    },
    roughnessmap: {
      roughnessMap: {
        value: null
      }
    },
    metalnessmap: {
      metalnessMap: {
        value: null
      }
    },
    gradientmap: {
      gradientMap: {
        value: null
      }
    },
    fog: {
      fogDensity: {
        value: 25e-5
      },
      fogNear: {
        value: 1
      },
      fogFar: {
        value: 2e3
      },
      fogColor: {
        value: new we(16777215)
      }
    },
    lights: {
      ambientLightColor: {
        value: []
      },
      lightProbe: {
        value: []
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {}
        }
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      directionalShadowMap: {
        value: []
      },
      directionalShadowMatrix: {
        value: []
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        }
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotLightMap: {
        value: []
      },
      spotShadowMap: {
        value: []
      },
      spotLightMatrix: {
        value: []
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        }
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {
        value: []
      },
      pointShadowMatrix: {
        value: []
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        }
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        }
      },
      ltc_1: {
        value: null
      },
      ltc_2: {
        value: null
      }
    },
    points: {
      diffuse: {
        value: new we(16777215)
      },
      opacity: {
        value: 1
      },
      size: {
        value: 1
      },
      scale: {
        value: 1
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new nn()
      }
    },
    sprite: {
      diffuse: {
        value: new we(16777215)
      },
      opacity: {
        value: 1
      },
      center: {
        value: new te(0.5, 0.5)
      },
      rotation: {
        value: 0
      },
      map: {
        value: null
      },
      alphaMap: {
        value: null
      },
      alphaTest: {
        value: 0
      },
      uvTransform: {
        value: new nn()
      }
    }
  }, En = {
    basic: {
      uniforms: tn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.fog
      ]),
      vertexShader: Ye.meshbasic_vert,
      fragmentShader: Ye.meshbasic_frag
    },
    lambert: {
      uniforms: tn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        _e.lights,
        {
          emissive: {
            value: new we(0)
          }
        }
      ]),
      vertexShader: Ye.meshlambert_vert,
      fragmentShader: Ye.meshlambert_frag
    },
    phong: {
      uniforms: tn([
        _e.common,
        _e.specularmap,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        _e.lights,
        {
          emissive: {
            value: new we(0)
          },
          specular: {
            value: new we(1118481)
          },
          shininess: {
            value: 30
          }
        }
      ]),
      vertexShader: Ye.meshphong_vert,
      fragmentShader: Ye.meshphong_frag
    },
    standard: {
      uniforms: tn([
        _e.common,
        _e.envmap,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.roughnessmap,
        _e.metalnessmap,
        _e.fog,
        _e.lights,
        {
          emissive: {
            value: new we(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ye.meshphysical_vert,
      fragmentShader: Ye.meshphysical_frag
    },
    toon: {
      uniforms: tn([
        _e.common,
        _e.aomap,
        _e.lightmap,
        _e.emissivemap,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.gradientmap,
        _e.fog,
        _e.lights,
        {
          emissive: {
            value: new we(0)
          }
        }
      ]),
      vertexShader: Ye.meshtoon_vert,
      fragmentShader: Ye.meshtoon_frag
    },
    matcap: {
      uniforms: tn([
        _e.common,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        _e.fog,
        {
          matcap: {
            value: null
          }
        }
      ]),
      vertexShader: Ye.meshmatcap_vert,
      fragmentShader: Ye.meshmatcap_frag
    },
    points: {
      uniforms: tn([
        _e.points,
        _e.fog
      ]),
      vertexShader: Ye.points_vert,
      fragmentShader: Ye.points_frag
    },
    dashed: {
      uniforms: tn([
        _e.common,
        _e.fog,
        {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }
      ]),
      vertexShader: Ye.linedashed_vert,
      fragmentShader: Ye.linedashed_frag
    },
    depth: {
      uniforms: tn([
        _e.common,
        _e.displacementmap
      ]),
      vertexShader: Ye.depth_vert,
      fragmentShader: Ye.depth_frag
    },
    normal: {
      uniforms: tn([
        _e.common,
        _e.bumpmap,
        _e.normalmap,
        _e.displacementmap,
        {
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ye.meshnormal_vert,
      fragmentShader: Ye.meshnormal_frag
    },
    sprite: {
      uniforms: tn([
        _e.sprite,
        _e.fog
      ]),
      vertexShader: Ye.sprite_vert,
      fragmentShader: Ye.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new nn()
        },
        t2D: {
          value: null
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: Ye.background_vert,
      fragmentShader: Ye.background_frag
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        backgroundBlurriness: {
          value: 0
        },
        backgroundIntensity: {
          value: 1
        }
      },
      vertexShader: Ye.backgroundCube_vert,
      fragmentShader: Ye.backgroundCube_frag
    },
    cube: {
      uniforms: {
        tCube: {
          value: null
        },
        tFlip: {
          value: -1
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: Ye.cube_vert,
      fragmentShader: Ye.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: Ye.equirect_vert,
      fragmentShader: Ye.equirect_frag
    },
    distanceRGBA: {
      uniforms: tn([
        _e.common,
        _e.displacementmap,
        {
          referencePosition: {
            value: new P()
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }
      ]),
      vertexShader: Ye.distanceRGBA_vert,
      fragmentShader: Ye.distanceRGBA_frag
    },
    shadow: {
      uniforms: tn([
        _e.lights,
        _e.fog,
        {
          color: {
            value: new we(0)
          },
          opacity: {
            value: 1
          }
        }
      ]),
      vertexShader: Ye.shadow_vert,
      fragmentShader: Ye.shadow_frag
    }
  };
  En.physical = {
    uniforms: tn([
      En.standard.uniforms,
      {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatNormalScale: {
          value: new te(1, 1)
        },
        clearcoatNormalMap: {
          value: null
        },
        iridescence: {
          value: 0
        },
        iridescenceMap: {
          value: null
        },
        iridescenceIOR: {
          value: 1.3
        },
        iridescenceThicknessMinimum: {
          value: 100
        },
        iridescenceThicknessMaximum: {
          value: 400
        },
        iridescenceThicknessMap: {
          value: null
        },
        sheen: {
          value: 0
        },
        sheenColor: {
          value: new we(0)
        },
        sheenColorMap: {
          value: null
        },
        sheenRoughness: {
          value: 1
        },
        sheenRoughnessMap: {
          value: null
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        },
        transmissionSamplerSize: {
          value: new te()
        },
        transmissionSamplerMap: {
          value: null
        },
        thickness: {
          value: 0
        },
        thicknessMap: {
          value: null
        },
        attenuationDistance: {
          value: 0
        },
        attenuationColor: {
          value: new we(0)
        },
        specularIntensity: {
          value: 1
        },
        specularIntensityMap: {
          value: null
        },
        specularColor: {
          value: new we(1, 1, 1)
        },
        specularColorMap: {
          value: null
        }
      }
    ]),
    vertexShader: Ye.meshphysical_vert,
    fragmentShader: Ye.meshphysical_frag
  };
  const aa = {
    r: 0,
    b: 0,
    g: 0
  };
  function jy(l, e, t, n, i, s, r) {
    const a = new we(0);
    let c = s === true ? 0 : 1, u, p, f = null, m = 0, v = null;
    function b(x, w) {
      let S = false, y = w.isScene === true ? w.background : null;
      y && y.isTexture && (y = (w.backgroundBlurriness > 0 ? t : e).get(y));
      const M = l.xr, C = M.getSession && M.getSession();
      C && C.environmentBlendMode === "additive" && (y = null), y === null ? _(a, c) : y && y.isColor && (_(y, 1), S = true), (l.autoClear || S) && l.clear(l.autoClearColor, l.autoClearDepth, l.autoClearStencil), y && (y.isCubeTexture || y.mapping === hr) ? (p === void 0 && (p = new kt(new Vn(1, 1, 1), new Un({
        name: "BackgroundCubeMaterial",
        uniforms: sr(En.backgroundCube.uniforms),
        vertexShader: En.backgroundCube.vertexShader,
        fragmentShader: En.backgroundCube.fragmentShader,
        side: on,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), p.geometry.deleteAttribute("normal"), p.geometry.deleteAttribute("uv"), p.onBeforeRender = function(R, k, T) {
        this.matrixWorld.copyPosition(T.matrixWorld);
      }, Object.defineProperty(p.material, "envMap", {
        get: function() {
          return this.uniforms.envMap.value;
        }
      }), i.update(p)), p.material.uniforms.envMap.value = y, p.material.uniforms.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === false ? -1 : 1, p.material.uniforms.backgroundBlurriness.value = w.backgroundBlurriness, p.material.uniforms.backgroundIntensity.value = w.backgroundIntensity, p.material.toneMapped = y.encoding !== ct, (f !== y || m !== y.version || v !== l.toneMapping) && (p.material.needsUpdate = true, f = y, m = y.version, v = l.toneMapping), p.layers.enableAll(), x.unshift(p, p.geometry, p.material, 0, 0, null)) : y && y.isTexture && (u === void 0 && (u = new kt(new ur(2, 2), new Un({
        name: "BackgroundMaterial",
        uniforms: sr(En.background.uniforms),
        vertexShader: En.background.vertexShader,
        fragmentShader: En.background.fragmentShader,
        side: On,
        depthTest: false,
        depthWrite: false,
        fog: false
      })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
        get: function() {
          return this.uniforms.t2D.value;
        }
      }), i.update(u)), u.material.uniforms.t2D.value = y, u.material.uniforms.backgroundIntensity.value = w.backgroundIntensity, u.material.toneMapped = y.encoding !== ct, y.matrixAutoUpdate === true && y.updateMatrix(), u.material.uniforms.uvTransform.value.copy(y.matrix), (f !== y || m !== y.version || v !== l.toneMapping) && (u.material.needsUpdate = true, f = y, m = y.version, v = l.toneMapping), u.layers.enableAll(), x.unshift(u, u.geometry, u.material, 0, 0, null));
    }
    function _(x, w) {
      x.getRGB(aa, Zf(l)), n.buffers.color.setClear(aa.r, aa.g, aa.b, w, r);
    }
    return {
      getClearColor: function() {
        return a;
      },
      setClearColor: function(x, w = 1) {
        a.set(x), c = w, _(a, c);
      },
      getClearAlpha: function() {
        return c;
      },
      setClearAlpha: function(x) {
        c = x, _(a, c);
      },
      render: b
    };
  }
  function Ky(l, e, t, n) {
    const i = l.getParameter(34921), s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), r = n.isWebGL2 || s !== null, a = {}, c = x(null);
    let u = c, p = false;
    function f(B, Z, ie, re, W) {
      let pe = false;
      if (r) {
        const ae = _(re, ie, Z);
        u !== ae && (u = ae, v(u.object)), pe = w(B, re, ie, W), pe && S(B, re, ie, W);
      } else {
        const ae = Z.wireframe === true;
        (u.geometry !== re.id || u.program !== ie.id || u.wireframe !== ae) && (u.geometry = re.id, u.program = ie.id, u.wireframe = ae, pe = true);
      }
      W !== null && t.update(W, 34963), (pe || p) && (p = false, T(B, Z, ie, re), W !== null && l.bindBuffer(34963, t.get(W).buffer));
    }
    function m() {
      return n.isWebGL2 ? l.createVertexArray() : s.createVertexArrayOES();
    }
    function v(B) {
      return n.isWebGL2 ? l.bindVertexArray(B) : s.bindVertexArrayOES(B);
    }
    function b(B) {
      return n.isWebGL2 ? l.deleteVertexArray(B) : s.deleteVertexArrayOES(B);
    }
    function _(B, Z, ie) {
      const re = ie.wireframe === true;
      let W = a[B.id];
      W === void 0 && (W = {}, a[B.id] = W);
      let pe = W[Z.id];
      pe === void 0 && (pe = {}, W[Z.id] = pe);
      let ae = pe[re];
      return ae === void 0 && (ae = x(m()), pe[re] = ae), ae;
    }
    function x(B) {
      const Z = [], ie = [], re = [];
      for (let W = 0; W < i; W++) Z[W] = 0, ie[W] = 0, re[W] = 0;
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes: Z,
        enabledAttributes: ie,
        attributeDivisors: re,
        object: B,
        attributes: {},
        index: null
      };
    }
    function w(B, Z, ie, re) {
      const W = u.attributes, pe = Z.attributes;
      let ae = 0;
      const Te = ie.getAttributes();
      for (const q in Te) if (Te[q].location >= 0) {
        const oe = W[q];
        let ce = pe[q];
        if (ce === void 0 && (q === "instanceMatrix" && B.instanceMatrix && (ce = B.instanceMatrix), q === "instanceColor" && B.instanceColor && (ce = B.instanceColor)), oe === void 0 || oe.attribute !== ce || ce && oe.data !== ce.data) return true;
        ae++;
      }
      return u.attributesNum !== ae || u.index !== re;
    }
    function S(B, Z, ie, re) {
      const W = {}, pe = Z.attributes;
      let ae = 0;
      const Te = ie.getAttributes();
      for (const q in Te) if (Te[q].location >= 0) {
        let oe = pe[q];
        oe === void 0 && (q === "instanceMatrix" && B.instanceMatrix && (oe = B.instanceMatrix), q === "instanceColor" && B.instanceColor && (oe = B.instanceColor));
        const ce = {};
        ce.attribute = oe, oe && oe.data && (ce.data = oe.data), W[q] = ce, ae++;
      }
      u.attributes = W, u.attributesNum = ae, u.index = re;
    }
    function y() {
      const B = u.newAttributes;
      for (let Z = 0, ie = B.length; Z < ie; Z++) B[Z] = 0;
    }
    function M(B) {
      C(B, 0);
    }
    function C(B, Z) {
      const ie = u.newAttributes, re = u.enabledAttributes, W = u.attributeDivisors;
      ie[B] = 1, re[B] === 0 && (l.enableVertexAttribArray(B), re[B] = 1), W[B] !== Z && ((n.isWebGL2 ? l : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](B, Z), W[B] = Z);
    }
    function R() {
      const B = u.newAttributes, Z = u.enabledAttributes;
      for (let ie = 0, re = Z.length; ie < re; ie++) Z[ie] !== B[ie] && (l.disableVertexAttribArray(ie), Z[ie] = 0);
    }
    function k(B, Z, ie, re, W, pe) {
      n.isWebGL2 === true && (ie === 5124 || ie === 5125) ? l.vertexAttribIPointer(B, Z, ie, W, pe) : l.vertexAttribPointer(B, Z, ie, re, W, pe);
    }
    function T(B, Z, ie, re) {
      if (n.isWebGL2 === false && (B.isInstancedMesh || re.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
      y();
      const W = re.attributes, pe = ie.getAttributes(), ae = Z.defaultAttributeValues;
      for (const Te in pe) {
        const q = pe[Te];
        if (q.location >= 0) {
          let le = W[Te];
          if (le === void 0 && (Te === "instanceMatrix" && B.instanceMatrix && (le = B.instanceMatrix), Te === "instanceColor" && B.instanceColor && (le = B.instanceColor)), le !== void 0) {
            const oe = le.normalized, ce = le.itemSize, K = t.get(le);
            if (K === void 0) continue;
            const ke = K.buffer, Ce = K.type, Le = K.bytesPerElement;
            if (le.isInterleavedBufferAttribute) {
              const ve = le.data, Ve = ve.stride, se = le.offset;
              if (ve.isInstancedInterleavedBuffer) {
                for (let ne = 0; ne < q.locationSize; ne++) C(q.location + ne, ve.meshPerAttribute);
                B.isInstancedMesh !== true && re._maxInstanceCount === void 0 && (re._maxInstanceCount = ve.meshPerAttribute * ve.count);
              } else for (let ne = 0; ne < q.locationSize; ne++) M(q.location + ne);
              l.bindBuffer(34962, ke);
              for (let ne = 0; ne < q.locationSize; ne++) k(q.location + ne, ce / q.locationSize, Ce, oe, Ve * Le, (se + ce / q.locationSize * ne) * Le);
            } else {
              if (le.isInstancedBufferAttribute) {
                for (let ve = 0; ve < q.locationSize; ve++) C(q.location + ve, le.meshPerAttribute);
                B.isInstancedMesh !== true && re._maxInstanceCount === void 0 && (re._maxInstanceCount = le.meshPerAttribute * le.count);
              } else for (let ve = 0; ve < q.locationSize; ve++) M(q.location + ve);
              l.bindBuffer(34962, ke);
              for (let ve = 0; ve < q.locationSize; ve++) k(q.location + ve, ce / q.locationSize, Ce, oe, ce * Le, ce / q.locationSize * ve * Le);
            }
          } else if (ae !== void 0) {
            const oe = ae[Te];
            if (oe !== void 0) switch (oe.length) {
              case 2:
                l.vertexAttrib2fv(q.location, oe);
                break;
              case 3:
                l.vertexAttrib3fv(q.location, oe);
                break;
              case 4:
                l.vertexAttrib4fv(q.location, oe);
                break;
              default:
                l.vertexAttrib1fv(q.location, oe);
            }
          }
        }
      }
      R();
    }
    function L() {
      Y();
      for (const B in a) {
        const Z = a[B];
        for (const ie in Z) {
          const re = Z[ie];
          for (const W in re) b(re[W].object), delete re[W];
          delete Z[ie];
        }
        delete a[B];
      }
    }
    function F(B) {
      if (a[B.id] === void 0) return;
      const Z = a[B.id];
      for (const ie in Z) {
        const re = Z[ie];
        for (const W in re) b(re[W].object), delete re[W];
        delete Z[ie];
      }
      delete a[B.id];
    }
    function j(B) {
      for (const Z in a) {
        const ie = a[Z];
        if (ie[B.id] === void 0) continue;
        const re = ie[B.id];
        for (const W in re) b(re[W].object), delete re[W];
        delete ie[B.id];
      }
    }
    function Y() {
      z(), p = true, u !== c && (u = c, v(u.object));
    }
    function z() {
      c.geometry = null, c.program = null, c.wireframe = false;
    }
    return {
      setup: f,
      reset: Y,
      resetDefaultState: z,
      dispose: L,
      releaseStatesOfGeometry: F,
      releaseStatesOfProgram: j,
      initAttributes: y,
      enableAttribute: M,
      disableUnusedAttributes: R
    };
  }
  function Yy(l, e, t, n) {
    const i = n.isWebGL2;
    let s;
    function r(u) {
      s = u;
    }
    function a(u, p) {
      l.drawArrays(s, u, p), t.update(p, s, 1);
    }
    function c(u, p, f) {
      if (f === 0) return;
      let m, v;
      if (i) m = l, v = "drawArraysInstanced";
      else if (m = e.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", m === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      m[v](s, u, p, f), t.update(p, s, f);
    }
    this.setMode = r, this.render = a, this.renderInstances = c;
  }
  function $y(l, e, t) {
    let n;
    function i() {
      if (n !== void 0) return n;
      if (e.has("EXT_texture_filter_anisotropic") === true) {
        const k = e.get("EXT_texture_filter_anisotropic");
        n = l.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else n = 0;
      return n;
    }
    function s(k) {
      if (k === "highp") {
        if (l.getShaderPrecisionFormat(35633, 36338).precision > 0 && l.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
        k = "mediump";
      }
      return k === "mediump" && l.getShaderPrecisionFormat(35633, 36337).precision > 0 && l.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const r = typeof WebGL2RenderingContext < "u" && l instanceof WebGL2RenderingContext;
    let a = t.precision !== void 0 ? t.precision : "highp";
    const c = s(a);
    c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."), a = c);
    const u = r || e.has("WEBGL_draw_buffers"), p = t.logarithmicDepthBuffer === true, f = l.getParameter(34930), m = l.getParameter(35660), v = l.getParameter(3379), b = l.getParameter(34076), _ = l.getParameter(34921), x = l.getParameter(36347), w = l.getParameter(36348), S = l.getParameter(36349), y = m > 0, M = r || e.has("OES_texture_float"), C = y && M, R = r ? l.getParameter(36183) : 0;
    return {
      isWebGL2: r,
      drawBuffers: u,
      getMaxAnisotropy: i,
      getMaxPrecision: s,
      precision: a,
      logarithmicDepthBuffer: p,
      maxTextures: f,
      maxVertexTextures: m,
      maxTextureSize: v,
      maxCubemapSize: b,
      maxAttributes: _,
      maxVertexUniforms: x,
      maxVaryings: w,
      maxFragmentUniforms: S,
      vertexTextures: y,
      floatFragmentTextures: M,
      floatVertexTextures: C,
      maxSamples: R
    };
  }
  function Zy(l) {
    const e = this;
    let t = null, n = 0, i = false, s = false;
    const r = new bi(), a = new nn(), c = {
      value: null,
      needsUpdate: false
    };
    this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, m) {
      const v = f.length !== 0 || m || n !== 0 || i;
      return i = m, n = f.length, v;
    }, this.beginShadows = function() {
      s = true, p(null);
    }, this.endShadows = function() {
      s = false;
    }, this.setGlobalState = function(f, m) {
      t = p(f, m, 0);
    }, this.setState = function(f, m, v) {
      const b = f.clippingPlanes, _ = f.clipIntersection, x = f.clipShadows, w = l.get(f);
      if (!i || b === null || b.length === 0 || s && !x) s ? p(null) : u();
      else {
        const S = s ? 0 : n, y = S * 4;
        let M = w.clippingState || null;
        c.value = M, M = p(b, m, y, v);
        for (let C = 0; C !== y; ++C) M[C] = t[C];
        w.clippingState = M, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += S;
      }
    };
    function u() {
      c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
    }
    function p(f, m, v, b) {
      const _ = f !== null ? f.length : 0;
      let x = null;
      if (_ !== 0) {
        if (x = c.value, b !== true || x === null) {
          const w = v + _ * 4, S = m.matrixWorldInverse;
          a.getNormalMatrix(S), (x === null || x.length < w) && (x = new Float32Array(w));
          for (let y = 0, M = v; y !== _; ++y, M += 4) r.copy(f[y]).applyMatrix4(S, a), r.normal.toArray(x, M), x[M + 3] = r.constant;
        }
        c.value = x, c.needsUpdate = true;
      }
      return e.numPlanes = _, e.numIntersection = 0, x;
    }
  }
  function Jy(l) {
    let e = /* @__PURE__ */ new WeakMap();
    function t(r, a) {
      return a === Jr ? r.mapping = Si : a === Qr && (r.mapping = Ei), r;
    }
    function n(r) {
      if (r && r.isTexture && r.isRenderTargetTexture === false) {
        const a = r.mapping;
        if (a === Jr || a === Qr) if (e.has(r)) {
          const c = e.get(r).texture;
          return t(c, r.mapping);
        } else {
          const c = r.image;
          if (c && c.height > 0) {
            const u = new em(c.height / 2);
            return u.fromEquirectangularTexture(l, r), e.set(r, u), r.addEventListener("dispose", i), t(u.texture, r.mapping);
          } else return null;
        }
      }
      return r;
    }
    function i(r) {
      const a = r.target;
      a.removeEventListener("dispose", i);
      const c = e.get(a);
      c !== void 0 && (e.delete(a), c.dispose());
    }
    function s() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: n,
      dispose: s
    };
  }
  class vo extends Ja {
    constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, r = 2e3) {
      super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = r, this.updateProjectionMatrix();
    }
    copy(e, t) {
      return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
    }
    setViewOffset(e, t, n, i, s, r) {
      this.view === null && (this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = r, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
      let s = n - e, r = n + e, a = i + t, c = i - t;
      if (this.view !== null && this.view.enabled) {
        const u = (this.right - this.left) / this.view.fullWidth / this.zoom, p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        s += u * this.view.offsetX, r = s + u * this.view.width, a -= p * this.view.offsetY, c = a - p * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(s, r, a, c, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
    }
  }
  const Ks = 4, Ed = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
  ], es = 20, rc = new vo(), Td = new we();
  let oc = null;
  const Ji = (1 + Math.sqrt(5)) / 2, Vs = 1 / Ji, Cd = [
    new P(1, 1, 1),
    new P(-1, 1, 1),
    new P(1, 1, -1),
    new P(-1, 1, -1),
    new P(0, Ji, Vs),
    new P(0, Ji, -Vs),
    new P(Vs, 0, Ji),
    new P(-Vs, 0, Ji),
    new P(Ji, Vs, 0),
    new P(-Ji, Vs, 0)
  ];
  class sh {
    constructor(e) {
      this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, n = 0.1, i = 100) {
      oc = this._renderer.getRenderTarget(), this._setSize(256);
      const s = this._allocateTargets();
      return s.depthBuffer = true, this._sceneToCubeUV(e, n, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = Ld(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = Pd(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(oc), e.scissorTest = false, la(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === Si || e.mapping === Ei ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), oc = this._renderer.getRenderTarget();
      const n = t || this._allocateTargets();
      return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
    }
    _allocateTargets() {
      const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
        magFilter: yt,
        minFilter: yt,
        generateMipmaps: false,
        type: tr,
        format: un,
        encoding: Ai,
        depthBuffer: false
      }, i = Ad(e, t, n);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
        this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Ad(e, t, n);
        const { _lodMax: s } = this;
        ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Qy(s)), this._blurMaterial = ew(s, e, t);
      }
      return i;
    }
    _compileMaterial(e) {
      const t = new kt(this._lodPlanes[0], e);
      this._renderer.compile(t, rc);
    }
    _sceneToCubeUV(e, t, n, i) {
      const a = new Ft(90, 1, t, n), c = [
        1,
        -1,
        1,
        1,
        1,
        1
      ], u = [
        1,
        1,
        1,
        -1,
        -1,
        -1
      ], p = this._renderer, f = p.autoClear, m = p.toneMapping;
      p.getClearColor(Td), p.toneMapping = kn, p.autoClear = false;
      const v = new $t({
        name: "PMREM.Background",
        side: on,
        depthWrite: false,
        depthTest: false
      }), b = new kt(new Vn(), v);
      let _ = false;
      const x = e.background;
      x ? x.isColor && (v.color.copy(x), e.background = null, _ = true) : (v.color.copy(Td), _ = true);
      for (let w = 0; w < 6; w++) {
        const S = w % 3;
        S === 0 ? (a.up.set(0, c[w], 0), a.lookAt(u[w], 0, 0)) : S === 1 ? (a.up.set(0, 0, c[w]), a.lookAt(0, u[w], 0)) : (a.up.set(0, c[w], 0), a.lookAt(0, 0, u[w]));
        const y = this._cubeSize;
        la(i, S * y, w > 2 ? y : 0, y, y), p.setRenderTarget(i), _ && p.render(b, a), p.render(e, a);
      }
      b.geometry.dispose(), b.material.dispose(), p.toneMapping = m, p.autoClear = f, e.background = x;
    }
    _textureToCubeUV(e, t) {
      const n = this._renderer, i = e.mapping === Si || e.mapping === Ei;
      i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ld()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Pd());
      const s = i ? this._cubemapMaterial : this._equirectMaterial, r = new kt(this._lodPlanes[0], s), a = s.uniforms;
      a.envMap.value = e;
      const c = this._cubeSize;
      la(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(r, rc);
    }
    _applyPMREM(e) {
      const t = this._renderer, n = t.autoClear;
      t.autoClear = false;
      for (let i = 1; i < this._lodPlanes.length; i++) {
        const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), r = Cd[(i - 1) % Cd.length];
        this._blur(e, i - 1, i, s, r);
      }
      t.autoClear = n;
    }
    _blur(e, t, n, i, s) {
      const r = this._pingPongRenderTarget;
      this._halfBlur(e, r, t, n, i, "latitudinal", s), this._halfBlur(r, e, n, n, i, "longitudinal", s);
    }
    _halfBlur(e, t, n, i, s, r, a) {
      const c = this._renderer, u = this._blurMaterial;
      r !== "latitudinal" && r !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const p = 3, f = new kt(this._lodPlanes[i], u), m = u.uniforms, v = this._sizeLods[n] - 1, b = isFinite(s) ? Math.PI / (2 * v) : 2 * Math.PI / (2 * es - 1), _ = s / b, x = isFinite(s) ? 1 + Math.floor(p * _) : es;
      x > es && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${es}`);
      const w = [];
      let S = 0;
      for (let k = 0; k < es; ++k) {
        const T = k / _, L = Math.exp(-T * T / 2);
        w.push(L), k === 0 ? S += L : k < x && (S += 2 * L);
      }
      for (let k = 0; k < w.length; k++) w[k] = w[k] / S;
      m.envMap.value = e.texture, m.samples.value = x, m.weights.value = w, m.latitudinal.value = r === "latitudinal", a && (m.poleAxis.value = a);
      const { _lodMax: y } = this;
      m.dTheta.value = b, m.mipInt.value = y - n;
      const M = this._sizeLods[i], C = 3 * M * (i > y - Ks ? i - y + Ks : 0), R = 4 * (this._cubeSize - M);
      la(t, C, R, 3 * M, 2 * M), c.setRenderTarget(t), c.render(f, rc);
    }
  }
  function Qy(l) {
    const e = [], t = [], n = [];
    let i = l;
    const s = l - Ks + 1 + Ed.length;
    for (let r = 0; r < s; r++) {
      const a = Math.pow(2, i);
      t.push(a);
      let c = 1 / a;
      r > l - Ks ? c = Ed[r - l + Ks - 1] : r === 0 && (c = 0), n.push(c);
      const u = 1 / (a - 2), p = -u, f = 1 + u, m = [
        p,
        p,
        f,
        p,
        f,
        f,
        p,
        p,
        f,
        f,
        p,
        f
      ], v = 6, b = 6, _ = 3, x = 2, w = 1, S = new Float32Array(_ * b * v), y = new Float32Array(x * b * v), M = new Float32Array(w * b * v);
      for (let R = 0; R < v; R++) {
        const k = R % 3 * 2 / 3 - 1, T = R > 2 ? 0 : -1, L = [
          k,
          T,
          0,
          k + 2 / 3,
          T,
          0,
          k + 2 / 3,
          T + 1,
          0,
          k,
          T,
          0,
          k + 2 / 3,
          T + 1,
          0,
          k,
          T + 1,
          0
        ];
        S.set(L, _ * b * R), y.set(m, x * b * R);
        const F = [
          R,
          R,
          R,
          R,
          R,
          R
        ];
        M.set(F, w * b * R);
      }
      const C = new Xe();
      C.setAttribute("position", new ht(S, _)), C.setAttribute("uv", new ht(y, x)), C.setAttribute("faceIndex", new ht(M, w)), e.push(C), i > Ks && i--;
    }
    return {
      lodPlanes: e,
      sizeLods: t,
      sigmas: n
    };
  }
  function Ad(l, e, t) {
    const n = new Tn(l, e, t);
    return n.texture.mapping = hr, n.texture.name = "PMREM.cubeUv", n.scissorTest = true, n;
  }
  function la(l, e, t, n, i) {
    l.viewport.set(e, t, n, i), l.scissor.set(e, t, n, i);
  }
  function ew(l, e, t) {
    const n = new Float32Array(es), i = new P(0, 1, 0);
    return new Un({
      name: "SphericalGaussianBlur",
      defines: {
        n: es,
        CUBEUV_TEXEL_WIDTH: 1 / e,
        CUBEUV_TEXEL_HEIGHT: 1 / t,
        CUBEUV_MAX_MIP: `${l}.0`
      },
      uniforms: {
        envMap: {
          value: null
        },
        samples: {
          value: 1
        },
        weights: {
          value: n
        },
        latitudinal: {
          value: false
        },
        dTheta: {
          value: 0
        },
        mipInt: {
          value: 0
        },
        poleAxis: {
          value: i
        }
      },
      vertexShader: Ph(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: ii,
      depthTest: false,
      depthWrite: false
    });
  }
  function Pd() {
    return new Un({
      name: "EquirectangularToCubeUV",
      uniforms: {
        envMap: {
          value: null
        }
      },
      vertexShader: Ph(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: ii,
      depthTest: false,
      depthWrite: false
    });
  }
  function Ld() {
    return new Un({
      name: "CubemapToCubeUV",
      uniforms: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        }
      },
      vertexShader: Ph(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: ii,
      depthTest: false,
      depthWrite: false
    });
  }
  function Ph() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function tw(l) {
    let e = /* @__PURE__ */ new WeakMap(), t = null;
    function n(a) {
      if (a && a.isTexture) {
        const c = a.mapping, u = c === Jr || c === Qr, p = c === Si || c === Ei;
        if (u || p) if (a.isRenderTargetTexture && a.needsPMREMUpdate === true) {
          a.needsPMREMUpdate = false;
          let f = e.get(a);
          return t === null && (t = new sh(l)), f = u ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f), e.set(a, f), f.texture;
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const f = a.image;
            if (u && f && f.height > 0 || p && f && i(f)) {
              t === null && (t = new sh(l));
              const m = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, m), a.addEventListener("dispose", s), m.texture;
            } else return null;
          }
        }
      }
      return a;
    }
    function i(a) {
      let c = 0;
      const u = 6;
      for (let p = 0; p < u; p++) a[p] !== void 0 && c++;
      return c === u;
    }
    function s(a) {
      const c = a.target;
      c.removeEventListener("dispose", s);
      const u = e.get(c);
      u !== void 0 && (e.delete(c), u.dispose());
    }
    function r() {
      e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
    }
    return {
      get: n,
      dispose: r
    };
  }
  function nw(l) {
    const e = {};
    function t(n) {
      if (e[n] !== void 0) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i = l.getExtension("WEBGL_depth_texture") || l.getExtension("MOZ_WEBGL_depth_texture") || l.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i = l.getExtension("EXT_texture_filter_anisotropic") || l.getExtension("MOZ_EXT_texture_filter_anisotropic") || l.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i = l.getExtension("WEBGL_compressed_texture_s3tc") || l.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i = l.getExtension("WEBGL_compressed_texture_pvrtc") || l.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = l.getExtension(n);
      }
      return e[n] = i, i;
    }
    return {
      has: function(n) {
        return t(n) !== null;
      },
      init: function(n) {
        n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
      },
      get: function(n) {
        const i = t(n);
        return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
      }
    };
  }
  function iw(l, e, t, n) {
    const i = {}, s = /* @__PURE__ */ new WeakMap();
    function r(f) {
      const m = f.target;
      m.index !== null && e.remove(m.index);
      for (const b in m.attributes) e.remove(m.attributes[b]);
      m.removeEventListener("dispose", r), delete i[m.id];
      const v = s.get(m);
      v && (e.remove(v), s.delete(m)), n.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === true && delete m._maxInstanceCount, t.memory.geometries--;
    }
    function a(f, m) {
      return i[m.id] === true || (m.addEventListener("dispose", r), i[m.id] = true, t.memory.geometries++), m;
    }
    function c(f) {
      const m = f.attributes;
      for (const b in m) e.update(m[b], 34962);
      const v = f.morphAttributes;
      for (const b in v) {
        const _ = v[b];
        for (let x = 0, w = _.length; x < w; x++) e.update(_[x], 34962);
      }
    }
    function u(f) {
      const m = [], v = f.index, b = f.attributes.position;
      let _ = 0;
      if (v !== null) {
        const S = v.array;
        _ = v.version;
        for (let y = 0, M = S.length; y < M; y += 3) {
          const C = S[y + 0], R = S[y + 1], k = S[y + 2];
          m.push(C, R, R, k, k, C);
        }
      } else {
        const S = b.array;
        _ = b.version;
        for (let y = 0, M = S.length / 3 - 1; y < M; y += 3) {
          const C = y + 0, R = y + 1, k = y + 2;
          m.push(C, R, R, k, k, C);
        }
      }
      const x = new (Yf(m) ? Ah : Ch)(m, 1);
      x.version = _;
      const w = s.get(f);
      w && e.remove(w), s.set(f, x);
    }
    function p(f) {
      const m = s.get(f);
      if (m) {
        const v = f.index;
        v !== null && m.version < v.version && u(f);
      } else u(f);
      return s.get(f);
    }
    return {
      get: a,
      update: c,
      getWireframeAttribute: p
    };
  }
  function sw(l, e, t, n) {
    const i = n.isWebGL2;
    let s;
    function r(m) {
      s = m;
    }
    let a, c;
    function u(m) {
      a = m.type, c = m.bytesPerElement;
    }
    function p(m, v) {
      l.drawElements(s, v, a, m * c), t.update(v, s, 1);
    }
    function f(m, v, b) {
      if (b === 0) return;
      let _, x;
      if (i) _ = l, x = "drawElementsInstanced";
      else if (_ = e.get("ANGLE_instanced_arrays"), x = "drawElementsInstancedANGLE", _ === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      _[x](s, v, a, m * c, b), t.update(v, s, b);
    }
    this.setMode = r, this.setIndex = u, this.render = p, this.renderInstances = f;
  }
  function rw(l) {
    const e = {
      geometries: 0,
      textures: 0
    }, t = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function n(s, r, a) {
      switch (t.calls++, r) {
        case 4:
          t.triangles += a * (s / 3);
          break;
        case 1:
          t.lines += a * (s / 2);
          break;
        case 3:
          t.lines += a * (s - 1);
          break;
        case 2:
          t.lines += a * s;
          break;
        case 0:
          t.points += a * s;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", r);
          break;
      }
    }
    function i() {
      t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
    }
    return {
      memory: e,
      render: t,
      programs: null,
      autoReset: true,
      reset: i,
      update: n
    };
  }
  function ow(l, e) {
    return l[0] - e[0];
  }
  function aw(l, e) {
    return Math.abs(e[1]) - Math.abs(l[1]);
  }
  function lw(l, e, t) {
    const n = {}, i = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), r = new ft(), a = [];
    for (let u = 0; u < 8; u++) a[u] = [
      u,
      0
    ];
    function c(u, p, f, m) {
      const v = u.morphTargetInfluences;
      if (e.isWebGL2 === true) {
        const b = p.morphAttributes.position || p.morphAttributes.normal || p.morphAttributes.color, _ = b !== void 0 ? b.length : 0;
        let x = s.get(p);
        if (x === void 0 || x.count !== _) {
          let Z = function() {
            z.dispose(), s.delete(p), p.removeEventListener("dispose", Z);
          };
          x !== void 0 && x.texture.dispose();
          const y = p.morphAttributes.position !== void 0, M = p.morphAttributes.normal !== void 0, C = p.morphAttributes.color !== void 0, R = p.morphAttributes.position || [], k = p.morphAttributes.normal || [], T = p.morphAttributes.color || [];
          let L = 0;
          y === true && (L = 1), M === true && (L = 2), C === true && (L = 3);
          let F = p.attributes.position.count * L, j = 1;
          F > e.maxTextureSize && (j = Math.ceil(F / e.maxTextureSize), F = e.maxTextureSize);
          const Y = new Float32Array(F * j * 4 * _), z = new $a(Y, F, j, _);
          z.type = ei, z.needsUpdate = true;
          const B = L * 4;
          for (let ie = 0; ie < _; ie++) {
            const re = R[ie], W = k[ie], pe = T[ie], ae = F * j * 4 * ie;
            for (let Te = 0; Te < re.count; Te++) {
              const q = Te * B;
              y === true && (r.fromBufferAttribute(re, Te), Y[ae + q + 0] = r.x, Y[ae + q + 1] = r.y, Y[ae + q + 2] = r.z, Y[ae + q + 3] = 0), M === true && (r.fromBufferAttribute(W, Te), Y[ae + q + 4] = r.x, Y[ae + q + 5] = r.y, Y[ae + q + 6] = r.z, Y[ae + q + 7] = 0), C === true && (r.fromBufferAttribute(pe, Te), Y[ae + q + 8] = r.x, Y[ae + q + 9] = r.y, Y[ae + q + 10] = r.z, Y[ae + q + 11] = pe.itemSize === 4 ? r.w : 1);
            }
          }
          x = {
            count: _,
            texture: z,
            size: new te(F, j)
          }, s.set(p, x), p.addEventListener("dispose", Z);
        }
        let w = 0;
        for (let y = 0; y < v.length; y++) w += v[y];
        const S = p.morphTargetsRelative ? 1 : 1 - w;
        m.getUniforms().setValue(l, "morphTargetBaseInfluence", S), m.getUniforms().setValue(l, "morphTargetInfluences", v), m.getUniforms().setValue(l, "morphTargetsTexture", x.texture, t), m.getUniforms().setValue(l, "morphTargetsTextureSize", x.size);
      } else {
        const b = v === void 0 ? 0 : v.length;
        let _ = n[p.id];
        if (_ === void 0 || _.length !== b) {
          _ = [];
          for (let M = 0; M < b; M++) _[M] = [
            M,
            0
          ];
          n[p.id] = _;
        }
        for (let M = 0; M < b; M++) {
          const C = _[M];
          C[0] = M, C[1] = v[M];
        }
        _.sort(aw);
        for (let M = 0; M < 8; M++) M < b && _[M][1] ? (a[M][0] = _[M][0], a[M][1] = _[M][1]) : (a[M][0] = Number.MAX_SAFE_INTEGER, a[M][1] = 0);
        a.sort(ow);
        const x = p.morphAttributes.position, w = p.morphAttributes.normal;
        let S = 0;
        for (let M = 0; M < 8; M++) {
          const C = a[M], R = C[0], k = C[1];
          R !== Number.MAX_SAFE_INTEGER && k ? (x && p.getAttribute("morphTarget" + M) !== x[R] && p.setAttribute("morphTarget" + M, x[R]), w && p.getAttribute("morphNormal" + M) !== w[R] && p.setAttribute("morphNormal" + M, w[R]), i[M] = k, S += k) : (x && p.hasAttribute("morphTarget" + M) === true && p.deleteAttribute("morphTarget" + M), w && p.hasAttribute("morphNormal" + M) === true && p.deleteAttribute("morphNormal" + M), i[M] = 0);
        }
        const y = p.morphTargetsRelative ? 1 : 1 - S;
        m.getUniforms().setValue(l, "morphTargetBaseInfluence", y), m.getUniforms().setValue(l, "morphTargetInfluences", i);
      }
    }
    return {
      update: c
    };
  }
  function cw(l, e, t, n) {
    let i = /* @__PURE__ */ new WeakMap();
    function s(c) {
      const u = n.render.frame, p = c.geometry, f = e.get(c, p);
      return i.get(f) !== u && (e.update(f), i.set(f, u)), c.isInstancedMesh && (c.hasEventListener("dispose", a) === false && c.addEventListener("dispose", a), t.update(c.instanceMatrix, 34962), c.instanceColor !== null && t.update(c.instanceColor, 34962)), f;
    }
    function r() {
      i = /* @__PURE__ */ new WeakMap();
    }
    function a(c) {
      const u = c.target;
      u.removeEventListener("dispose", a), t.remove(u.instanceMatrix), u.instanceColor !== null && t.remove(u.instanceColor);
    }
    return {
      update: s,
      dispose: r
    };
  }
  const nm = new Mt(), im = new $a(), sm = new Th(), rm = new go(), Rd = [], Id = [], Dd = new Float32Array(16), kd = new Float32Array(9), Nd = new Float32Array(4);
  function dr(l, e, t) {
    const n = l[0];
    if (n <= 0 || n > 0) return l;
    const i = e * t;
    let s = Rd[i];
    if (s === void 0 && (s = new Float32Array(i), Rd[i] = s), e !== 0) {
      n.toArray(s, 0);
      for (let r = 1, a = 0; r !== e; ++r) a += t, l[r].toArray(s, a);
    }
    return s;
  }
  function Ut(l, e) {
    if (l.length !== e.length) return false;
    for (let t = 0, n = l.length; t < n; t++) if (l[t] !== e[t]) return false;
    return true;
  }
  function zt(l, e) {
    for (let t = 0, n = e.length; t < n; t++) l[t] = e[t];
  }
  function el(l, e) {
    let t = Id[e];
    t === void 0 && (t = new Int32Array(e), Id[e] = t);
    for (let n = 0; n !== e; ++n) t[n] = l.allocateTextureUnit();
    return t;
  }
  function hw(l, e) {
    const t = this.cache;
    t[0] !== e && (l.uniform1f(this.addr, e), t[0] = e);
  }
  function uw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (l.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Ut(t, e)) return;
      l.uniform2fv(this.addr, e), zt(t, e);
    }
  }
  function dw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (l.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (l.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
      if (Ut(t, e)) return;
      l.uniform3fv(this.addr, e), zt(t, e);
    }
  }
  function pw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (l.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Ut(t, e)) return;
      l.uniform4fv(this.addr, e), zt(t, e);
    }
  }
  function fw(l, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Ut(t, e)) return;
      l.uniformMatrix2fv(this.addr, false, e), zt(t, e);
    } else {
      if (Ut(t, n)) return;
      Nd.set(n), l.uniformMatrix2fv(this.addr, false, Nd), zt(t, n);
    }
  }
  function mw(l, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Ut(t, e)) return;
      l.uniformMatrix3fv(this.addr, false, e), zt(t, e);
    } else {
      if (Ut(t, n)) return;
      kd.set(n), l.uniformMatrix3fv(this.addr, false, kd), zt(t, n);
    }
  }
  function gw(l, e) {
    const t = this.cache, n = e.elements;
    if (n === void 0) {
      if (Ut(t, e)) return;
      l.uniformMatrix4fv(this.addr, false, e), zt(t, e);
    } else {
      if (Ut(t, n)) return;
      Dd.set(n), l.uniformMatrix4fv(this.addr, false, Dd), zt(t, n);
    }
  }
  function vw(l, e) {
    const t = this.cache;
    t[0] !== e && (l.uniform1i(this.addr, e), t[0] = e);
  }
  function _w(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (l.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Ut(t, e)) return;
      l.uniform2iv(this.addr, e), zt(t, e);
    }
  }
  function xw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (l.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (Ut(t, e)) return;
      l.uniform3iv(this.addr, e), zt(t, e);
    }
  }
  function bw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (l.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Ut(t, e)) return;
      l.uniform4iv(this.addr, e), zt(t, e);
    }
  }
  function yw(l, e) {
    const t = this.cache;
    t[0] !== e && (l.uniform1ui(this.addr, e), t[0] = e);
  }
  function ww(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (l.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
      if (Ut(t, e)) return;
      l.uniform2uiv(this.addr, e), zt(t, e);
    }
  }
  function Mw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (l.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
      if (Ut(t, e)) return;
      l.uniform3uiv(this.addr, e), zt(t, e);
    }
  }
  function Sw(l, e) {
    const t = this.cache;
    if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (l.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
      if (Ut(t, e)) return;
      l.uniform4uiv(this.addr, e), zt(t, e);
    }
  }
  function Ew(l, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (l.uniform1i(this.addr, i), n[0] = i), t.setTexture2D(e || nm, i);
  }
  function Tw(l, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (l.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || sm, i);
  }
  function Cw(l, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (l.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || rm, i);
  }
  function Aw(l, e, t) {
    const n = this.cache, i = t.allocateTextureUnit();
    n[0] !== i && (l.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || im, i);
  }
  function Pw(l) {
    switch (l) {
      case 5126:
        return hw;
      case 35664:
        return uw;
      case 35665:
        return dw;
      case 35666:
        return pw;
      case 35674:
        return fw;
      case 35675:
        return mw;
      case 35676:
        return gw;
      case 5124:
      case 35670:
        return vw;
      case 35667:
      case 35671:
        return _w;
      case 35668:
      case 35672:
        return xw;
      case 35669:
      case 35673:
        return bw;
      case 5125:
        return yw;
      case 36294:
        return ww;
      case 36295:
        return Mw;
      case 36296:
        return Sw;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Ew;
      case 35679:
      case 36299:
      case 36307:
        return Tw;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Cw;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Aw;
    }
  }
  function Lw(l, e) {
    l.uniform1fv(this.addr, e);
  }
  function Rw(l, e) {
    const t = dr(e, this.size, 2);
    l.uniform2fv(this.addr, t);
  }
  function Iw(l, e) {
    const t = dr(e, this.size, 3);
    l.uniform3fv(this.addr, t);
  }
  function Dw(l, e) {
    const t = dr(e, this.size, 4);
    l.uniform4fv(this.addr, t);
  }
  function kw(l, e) {
    const t = dr(e, this.size, 4);
    l.uniformMatrix2fv(this.addr, false, t);
  }
  function Nw(l, e) {
    const t = dr(e, this.size, 9);
    l.uniformMatrix3fv(this.addr, false, t);
  }
  function Ow(l, e) {
    const t = dr(e, this.size, 16);
    l.uniformMatrix4fv(this.addr, false, t);
  }
  function Fw(l, e) {
    l.uniform1iv(this.addr, e);
  }
  function Bw(l, e) {
    l.uniform2iv(this.addr, e);
  }
  function Uw(l, e) {
    l.uniform3iv(this.addr, e);
  }
  function zw(l, e) {
    l.uniform4iv(this.addr, e);
  }
  function Vw(l, e) {
    l.uniform1uiv(this.addr, e);
  }
  function Gw(l, e) {
    l.uniform2uiv(this.addr, e);
  }
  function Hw(l, e) {
    l.uniform3uiv(this.addr, e);
  }
  function Ww(l, e) {
    l.uniform4uiv(this.addr, e);
  }
  function qw(l, e, t) {
    const n = this.cache, i = e.length, s = el(t, i);
    Ut(n, s) || (l.uniform1iv(this.addr, s), zt(n, s));
    for (let r = 0; r !== i; ++r) t.setTexture2D(e[r] || nm, s[r]);
  }
  function Xw(l, e, t) {
    const n = this.cache, i = e.length, s = el(t, i);
    Ut(n, s) || (l.uniform1iv(this.addr, s), zt(n, s));
    for (let r = 0; r !== i; ++r) t.setTexture3D(e[r] || sm, s[r]);
  }
  function jw(l, e, t) {
    const n = this.cache, i = e.length, s = el(t, i);
    Ut(n, s) || (l.uniform1iv(this.addr, s), zt(n, s));
    for (let r = 0; r !== i; ++r) t.setTextureCube(e[r] || rm, s[r]);
  }
  function Kw(l, e, t) {
    const n = this.cache, i = e.length, s = el(t, i);
    Ut(n, s) || (l.uniform1iv(this.addr, s), zt(n, s));
    for (let r = 0; r !== i; ++r) t.setTexture2DArray(e[r] || im, s[r]);
  }
  function Yw(l) {
    switch (l) {
      case 5126:
        return Lw;
      case 35664:
        return Rw;
      case 35665:
        return Iw;
      case 35666:
        return Dw;
      case 35674:
        return kw;
      case 35675:
        return Nw;
      case 35676:
        return Ow;
      case 5124:
      case 35670:
        return Fw;
      case 35667:
      case 35671:
        return Bw;
      case 35668:
      case 35672:
        return Uw;
      case 35669:
      case 35673:
        return zw;
      case 5125:
        return Vw;
      case 36294:
        return Gw;
      case 36295:
        return Hw;
      case 36296:
        return Ww;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return qw;
      case 35679:
      case 36299:
      case 36307:
        return Xw;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return jw;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Kw;
    }
  }
  class $w {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.setValue = Pw(t.type);
    }
  }
  class Zw {
    constructor(e, t, n) {
      this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = Yw(t.type);
    }
  }
  class Jw {
    constructor(e) {
      this.id = e, this.seq = [], this.map = {};
    }
    setValue(e, t, n) {
      const i = this.seq;
      for (let s = 0, r = i.length; s !== r; ++s) {
        const a = i[s];
        a.setValue(e, t[a.id], n);
      }
    }
  }
  const ac = /(\w+)(\])?(\[|\.)?/g;
  function Od(l, e) {
    l.seq.push(e), l.map[e.id] = e;
  }
  function Qw(l, e, t) {
    const n = l.name, i = n.length;
    for (ac.lastIndex = 0; ; ) {
      const s = ac.exec(n), r = ac.lastIndex;
      let a = s[1];
      const c = s[2] === "]", u = s[3];
      if (c && (a = a | 0), u === void 0 || u === "[" && r + 2 === i) {
        Od(t, u === void 0 ? new $w(a, l, e) : new Zw(a, l, e));
        break;
      } else {
        let f = t.map[a];
        f === void 0 && (f = new Jw(a), Od(t, f)), t = f;
      }
    }
  }
  class Ba {
    constructor(e, t) {
      this.seq = [], this.map = {};
      const n = e.getProgramParameter(t, 35718);
      for (let i = 0; i < n; ++i) {
        const s = e.getActiveUniform(t, i), r = e.getUniformLocation(t, s.name);
        Qw(s, r, this);
      }
    }
    setValue(e, t, n, i) {
      const s = this.map[t];
      s !== void 0 && s.setValue(e, n, i);
    }
    setOptional(e, t, n) {
      const i = t[n];
      i !== void 0 && this.setValue(e, n, i);
    }
    static upload(e, t, n, i) {
      for (let s = 0, r = t.length; s !== r; ++s) {
        const a = t[s], c = n[a.id];
        c.needsUpdate !== false && a.setValue(e, c.value, i);
      }
    }
    static seqWithValue(e, t) {
      const n = [];
      for (let i = 0, s = e.length; i !== s; ++i) {
        const r = e[i];
        r.id in t && n.push(r);
      }
      return n;
    }
  }
  function Fd(l, e, t) {
    const n = l.createShader(e);
    return l.shaderSource(n, t), l.compileShader(n), n;
  }
  let eM = 0;
  function tM(l, e) {
    const t = l.split(`
`), n = [], i = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
    for (let r = i; r < s; r++) {
      const a = r + 1;
      n.push(`${a === e ? ">" : " "} ${a}: ${t[r]}`);
    }
    return n.join(`
`);
  }
  function nM(l) {
    switch (l) {
      case Ai:
        return [
          "Linear",
          "( value )"
        ];
      case ct:
        return [
          "sRGB",
          "( value )"
        ];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", l), [
          "Linear",
          "( value )"
        ];
    }
  }
  function Bd(l, e, t) {
    const n = l.getShaderParameter(e, 35713), i = l.getShaderInfoLog(e).trim();
    if (n && i === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
      const r = parseInt(s[1]);
      return t.toUpperCase() + `

` + i + `

` + tM(l.getShaderSource(e), r);
    } else return i;
  }
  function iM(l, e) {
    const t = nM(e);
    return "vec4 " + l + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
  }
  function sM(l, e) {
    let t;
    switch (e) {
      case bf:
        t = "Linear";
        break;
      case yf:
        t = "Reinhard";
        break;
      case wf:
        t = "OptimizedCineon";
        break;
      case bh:
        t = "ACESFilmic";
        break;
      case Mf:
        t = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
    }
    return "vec3 " + l + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
  }
  function rM(l) {
    return [
      l.extensionDerivatives || l.envMapCubeUVHeight || l.bumpMap || l.tangentSpaceNormalMap || l.clearcoatNormalMap || l.flatShading || l.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (l.extensionFragDepth || l.logarithmicDepthBuffer) && l.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      l.extensionDrawBuffers && l.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (l.extensionShaderTextureLOD || l.envMap || l.transmission) && l.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ].filter(jr).join(`
`);
  }
  function oM(l) {
    const e = [];
    for (const t in l) {
      const n = l[t];
      n !== false && e.push("#define " + t + " " + n);
    }
    return e.join(`
`);
  }
  function aM(l, e) {
    const t = {}, n = l.getProgramParameter(e, 35721);
    for (let i = 0; i < n; i++) {
      const s = l.getActiveAttrib(e, i), r = s.name;
      let a = 1;
      s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[r] = {
        type: s.type,
        location: l.getAttribLocation(e, r),
        locationSize: a
      };
    }
    return t;
  }
  function jr(l) {
    return l !== "";
  }
  function Ud(l, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return l.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function zd(l, e) {
    return l.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
  }
  const lM = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function rh(l) {
    return l.replace(lM, cM);
  }
  function cM(l, e) {
    const t = Ye[e];
    if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
    return rh(t);
  }
  const hM = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Vd(l) {
    return l.replace(hM, uM);
  }
  function uM(l, e, t, n) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i;
  }
  function Gd(l) {
    let e = "precision " + l.precision + ` float;
precision ` + l.precision + " int;";
    return l.precision === "highp" ? e += `
#define HIGH_PRECISION` : l.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : l.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
  }
  function dM(l) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return l.shadowMapType === gh ? e = "SHADOWMAP_TYPE_PCF" : l.shadowMapType === vh ? e = "SHADOWMAP_TYPE_PCF_SOFT" : l.shadowMapType === Xs && (e = "SHADOWMAP_TYPE_VSM"), e;
  }
  function pM(l) {
    let e = "ENVMAP_TYPE_CUBE";
    if (l.envMap) switch (l.envMapMode) {
      case Si:
      case Ei:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case hr:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
    return e;
  }
  function fM(l) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (l.envMap) switch (l.envMapMode) {
      case Ei:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
    return e;
  }
  function mM(l) {
    let e = "ENVMAP_BLENDING_NONE";
    if (l.envMap) switch (l.combine) {
      case po:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case _f:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case xf:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
    return e;
  }
  function gM(l) {
    const e = l.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2, n = 1 / e;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)),
      texelHeight: n,
      maxMip: t
    };
  }
  function vM(l, e, t, n) {
    const i = l.getContext(), s = t.defines;
    let r = t.vertexShader, a = t.fragmentShader;
    const c = dM(t), u = pM(t), p = fM(t), f = mM(t), m = gM(t), v = t.isWebGL2 ? "" : rM(t), b = oM(s), _ = i.createProgram();
    let x, w, S = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (x = [
      b
    ].filter(jr).join(`
`), x.length > 0 && (x += `
`), w = [
      v,
      b
    ].filter(jr).join(`
`), w.length > 0 && (w += `
`)) : (x = [
      Gd(t),
      "#define SHADER_NAME " + t.shaderName,
      b,
      t.instancing ? "#define USE_INSTANCING" : "",
      t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.map ? "#define USE_MAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + p : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      t.vertexTangents ? "#define USE_TANGENT" : "",
      t.vertexColors ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUvs ? "#define USE_UV" : "",
      t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.skinning ? "#define USE_SKINNING" : "",
      t.morphTargets ? "#define USE_MORPHTARGETS" : "",
      t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
      t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + c : "",
      t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      `
`
    ].filter(jr).join(`
`), w = [
      v,
      Gd(t),
      "#define SHADER_NAME " + t.shaderName,
      b,
      t.useFog && t.fog ? "#define USE_FOG" : "",
      t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
      t.map ? "#define USE_MAP" : "",
      t.matcap ? "#define USE_MATCAP" : "",
      t.envMap ? "#define USE_ENVMAP" : "",
      t.envMap ? "#define " + u : "",
      t.envMap ? "#define " + p : "",
      t.envMap ? "#define " + f : "",
      m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
      m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
      m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
      t.lightMap ? "#define USE_LIGHTMAP" : "",
      t.aoMap ? "#define USE_AOMAP" : "",
      t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      t.bumpMap ? "#define USE_BUMPMAP" : "",
      t.normalMap ? "#define USE_NORMALMAP" : "",
      t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      t.clearcoat ? "#define USE_CLEARCOAT" : "",
      t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      t.iridescence ? "#define USE_IRIDESCENCE" : "",
      t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      t.specularMap ? "#define USE_SPECULARMAP" : "",
      t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      t.metalnessMap ? "#define USE_METALNESSMAP" : "",
      t.alphaMap ? "#define USE_ALPHAMAP" : "",
      t.alphaTest ? "#define USE_ALPHATEST" : "",
      t.sheen ? "#define USE_SHEEN" : "",
      t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      t.transmission ? "#define USE_TRANSMISSION" : "",
      t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      t.vertexTangents ? "#define USE_TANGENT" : "",
      t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
      t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      t.vertexUvs ? "#define USE_UV" : "",
      t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      t.gradientMap ? "#define USE_GRADIENTMAP" : "",
      t.flatShading ? "#define FLAT_SHADED" : "",
      t.doubleSided ? "#define DOUBLE_SIDED" : "",
      t.flipSided ? "#define FLIP_SIDED" : "",
      t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      t.shadowMapEnabled ? "#define " + c : "",
      t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      t.toneMapping !== kn ? "#define TONE_MAPPING" : "",
      t.toneMapping !== kn ? Ye.tonemapping_pars_fragment : "",
      t.toneMapping !== kn ? sM("toneMapping", t.toneMapping) : "",
      t.dithering ? "#define DITHERING" : "",
      t.opaque ? "#define OPAQUE" : "",
      Ye.encodings_pars_fragment,
      iM("linearToOutputTexel", t.outputEncoding),
      t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
      `
`
    ].filter(jr).join(`
`)), r = rh(r), r = Ud(r, t), r = zd(r, t), a = rh(a), a = Ud(a, t), a = zd(a, t), r = Vd(r), a = Vd(a), t.isWebGL2 && t.isRawShaderMaterial !== true && (S = `#version 300 es
`, x = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join(`
`) + `
` + x, w = [
      "#define varying in",
      t.glslVersion === nh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      t.glslVersion === nh ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join(`
`) + `
` + w);
    const y = S + x + r, M = S + w + a, C = Fd(i, 35633, y), R = Fd(i, 35632, M);
    if (i.attachShader(_, C), i.attachShader(_, R), t.index0AttributeName !== void 0 ? i.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === true && i.bindAttribLocation(_, 0, "position"), i.linkProgram(_), l.debug.checkShaderErrors) {
      const L = i.getProgramInfoLog(_).trim(), F = i.getShaderInfoLog(C).trim(), j = i.getShaderInfoLog(R).trim();
      let Y = true, z = true;
      if (i.getProgramParameter(_, 35714) === false) {
        Y = false;
        const B = Bd(i, C, "vertex"), Z = Bd(i, R, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(_, 35715) + `

Program Info Log: ` + L + `
` + B + `
` + Z);
      } else L !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", L) : (F === "" || j === "") && (z = false);
      z && (this.diagnostics = {
        runnable: Y,
        programLog: L,
        vertexShader: {
          log: F,
          prefix: x
        },
        fragmentShader: {
          log: j,
          prefix: w
        }
      });
    }
    i.deleteShader(C), i.deleteShader(R);
    let k;
    this.getUniforms = function() {
      return k === void 0 && (k = new Ba(i, _)), k;
    };
    let T;
    return this.getAttributes = function() {
      return T === void 0 && (T = aM(i, _)), T;
    }, this.destroy = function() {
      n.releaseStatesOfProgram(this), i.deleteProgram(_), this.program = void 0;
    }, this.name = t.shaderName, this.id = eM++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = R, this;
  }
  let _M = 0;
  class xM {
    constructor() {
      this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
    }
    update(e) {
      const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), s = this._getShaderStage(n), r = this._getShaderCacheForMaterial(e);
      return r.has(i) === false && (r.add(i), i.usedTimes++), r.has(s) === false && (r.add(s), s.usedTimes++), this;
    }
    remove(e) {
      const t = this.materialCache.get(e);
      for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      const t = this.materialCache;
      let n = t.get(e);
      return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
    }
    _getShaderStage(e) {
      const t = this.shaderCache;
      let n = t.get(e);
      return n === void 0 && (n = new bM(e), t.set(e, n)), n;
    }
  }
  class bM {
    constructor(e) {
      this.id = _M++, this.code = e, this.usedTimes = 0;
    }
  }
  function yM(l, e, t, n, i, s, r) {
    const a = new Za(), c = new xM(), u = [], p = i.isWebGL2, f = i.logarithmicDepthBuffer, m = i.vertexTextures;
    let v = i.precision;
    const b = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    function _(T, L, F, j, Y) {
      const z = j.fog, B = Y.geometry, Z = T.isMeshStandardMaterial ? j.environment : null, ie = (T.isMeshStandardMaterial ? t : e).get(T.envMap || Z), re = ie && ie.mapping === hr ? ie.image.height : null, W = b[T.type];
      T.precision !== null && (v = i.getMaxPrecision(T.precision), v !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", v, "instead."));
      const pe = B.morphAttributes.position || B.morphAttributes.normal || B.morphAttributes.color, ae = pe !== void 0 ? pe.length : 0;
      let Te = 0;
      B.morphAttributes.position !== void 0 && (Te = 1), B.morphAttributes.normal !== void 0 && (Te = 2), B.morphAttributes.color !== void 0 && (Te = 3);
      let q, le, oe, ce;
      if (W) {
        const Ve = En[W];
        q = Ve.vertexShader, le = Ve.fragmentShader;
      } else q = T.vertexShader, le = T.fragmentShader, c.update(T), oe = c.getVertexShaderID(T), ce = c.getFragmentShaderID(T);
      const K = l.getRenderTarget(), ke = T.alphaTest > 0, Ce = T.clearcoat > 0, Le = T.iridescence > 0;
      return {
        isWebGL2: p,
        shaderID: W,
        shaderName: T.type,
        vertexShader: q,
        fragmentShader: le,
        defines: T.defines,
        customVertexShaderID: oe,
        customFragmentShaderID: ce,
        isRawShaderMaterial: T.isRawShaderMaterial === true,
        glslVersion: T.glslVersion,
        precision: v,
        instancing: Y.isInstancedMesh === true,
        instancingColor: Y.isInstancedMesh === true && Y.instanceColor !== null,
        supportsVertexTextures: m,
        outputEncoding: K === null ? l.outputEncoding : K.isXRRenderTarget === true ? K.texture.encoding : Ai,
        map: !!T.map,
        matcap: !!T.matcap,
        envMap: !!ie,
        envMapMode: ie && ie.mapping,
        envMapCubeUVHeight: re,
        lightMap: !!T.lightMap,
        aoMap: !!T.aoMap,
        emissiveMap: !!T.emissiveMap,
        bumpMap: !!T.bumpMap,
        normalMap: !!T.normalMap,
        objectSpaceNormalMap: T.normalMapType === qf,
        tangentSpaceNormalMap: T.normalMapType === Ri,
        decodeVideoTexture: !!T.map && T.map.isVideoTexture === true && T.map.encoding === ct,
        clearcoat: Ce,
        clearcoatMap: Ce && !!T.clearcoatMap,
        clearcoatRoughnessMap: Ce && !!T.clearcoatRoughnessMap,
        clearcoatNormalMap: Ce && !!T.clearcoatNormalMap,
        iridescence: Le,
        iridescenceMap: Le && !!T.iridescenceMap,
        iridescenceThicknessMap: Le && !!T.iridescenceThicknessMap,
        displacementMap: !!T.displacementMap,
        roughnessMap: !!T.roughnessMap,
        metalnessMap: !!T.metalnessMap,
        specularMap: !!T.specularMap,
        specularIntensityMap: !!T.specularIntensityMap,
        specularColorMap: !!T.specularColorMap,
        opaque: T.transparent === false && T.blending === rs,
        alphaMap: !!T.alphaMap,
        alphaTest: ke,
        gradientMap: !!T.gradientMap,
        sheen: T.sheen > 0,
        sheenColorMap: !!T.sheenColorMap,
        sheenRoughnessMap: !!T.sheenRoughnessMap,
        transmission: T.transmission > 0,
        transmissionMap: !!T.transmissionMap,
        thicknessMap: !!T.thicknessMap,
        combine: T.combine,
        vertexTangents: !!T.normalMap && !!B.attributes.tangent,
        vertexColors: T.vertexColors,
        vertexAlphas: T.vertexColors === true && !!B.attributes.color && B.attributes.color.itemSize === 4,
        vertexUvs: !!T.map || !!T.bumpMap || !!T.normalMap || !!T.specularMap || !!T.alphaMap || !!T.emissiveMap || !!T.roughnessMap || !!T.metalnessMap || !!T.clearcoatMap || !!T.clearcoatRoughnessMap || !!T.clearcoatNormalMap || !!T.iridescenceMap || !!T.iridescenceThicknessMap || !!T.displacementMap || !!T.transmissionMap || !!T.thicknessMap || !!T.specularIntensityMap || !!T.specularColorMap || !!T.sheenColorMap || !!T.sheenRoughnessMap,
        uvsVertexOnly: !(T.map || T.bumpMap || T.normalMap || T.specularMap || T.alphaMap || T.emissiveMap || T.roughnessMap || T.metalnessMap || T.clearcoatNormalMap || T.iridescenceMap || T.iridescenceThicknessMap || T.transmission > 0 || T.transmissionMap || T.thicknessMap || T.specularIntensityMap || T.specularColorMap || T.sheen > 0 || T.sheenColorMap || T.sheenRoughnessMap) && !!T.displacementMap,
        fog: !!z,
        useFog: T.fog === true,
        fogExp2: z && z.isFogExp2,
        flatShading: !!T.flatShading,
        sizeAttenuation: T.sizeAttenuation,
        logarithmicDepthBuffer: f,
        skinning: Y.isSkinnedMesh === true,
        morphTargets: B.morphAttributes.position !== void 0,
        morphNormals: B.morphAttributes.normal !== void 0,
        morphColors: B.morphAttributes.color !== void 0,
        morphTargetsCount: ae,
        morphTextureStride: Te,
        numDirLights: L.directional.length,
        numPointLights: L.point.length,
        numSpotLights: L.spot.length,
        numSpotLightMaps: L.spotLightMap.length,
        numRectAreaLights: L.rectArea.length,
        numHemiLights: L.hemi.length,
        numDirLightShadows: L.directionalShadowMap.length,
        numPointLightShadows: L.pointShadowMap.length,
        numSpotLightShadows: L.spotShadowMap.length,
        numSpotLightShadowsWithMaps: L.numSpotLightShadowsWithMaps,
        numClippingPlanes: r.numPlanes,
        numClipIntersection: r.numIntersection,
        dithering: T.dithering,
        shadowMapEnabled: l.shadowMap.enabled && F.length > 0,
        shadowMapType: l.shadowMap.type,
        toneMapping: T.toneMapped ? l.toneMapping : kn,
        physicallyCorrectLights: l.physicallyCorrectLights,
        premultipliedAlpha: T.premultipliedAlpha,
        doubleSided: T.side === Dn,
        flipSided: T.side === on,
        useDepthPacking: !!T.depthPacking,
        depthPacking: T.depthPacking || 0,
        index0AttributeName: T.index0AttributeName,
        extensionDerivatives: T.extensions && T.extensions.derivatives,
        extensionFragDepth: T.extensions && T.extensions.fragDepth,
        extensionDrawBuffers: T.extensions && T.extensions.drawBuffers,
        extensionShaderTextureLOD: T.extensions && T.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: p || n.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: p || n.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: p || n.has("EXT_shader_texture_lod"),
        customProgramCacheKey: T.customProgramCacheKey()
      };
    }
    function x(T) {
      const L = [];
      if (T.shaderID ? L.push(T.shaderID) : (L.push(T.customVertexShaderID), L.push(T.customFragmentShaderID)), T.defines !== void 0) for (const F in T.defines) L.push(F), L.push(T.defines[F]);
      return T.isRawShaderMaterial === false && (w(L, T), S(L, T), L.push(l.outputEncoding)), L.push(T.customProgramCacheKey), L.join();
    }
    function w(T, L) {
      T.push(L.precision), T.push(L.outputEncoding), T.push(L.envMapMode), T.push(L.envMapCubeUVHeight), T.push(L.combine), T.push(L.vertexUvs), T.push(L.fogExp2), T.push(L.sizeAttenuation), T.push(L.morphTargetsCount), T.push(L.morphAttributeCount), T.push(L.numDirLights), T.push(L.numPointLights), T.push(L.numSpotLights), T.push(L.numSpotLightMaps), T.push(L.numHemiLights), T.push(L.numRectAreaLights), T.push(L.numDirLightShadows), T.push(L.numPointLightShadows), T.push(L.numSpotLightShadows), T.push(L.numSpotLightShadowsWithMaps), T.push(L.shadowMapType), T.push(L.toneMapping), T.push(L.numClippingPlanes), T.push(L.numClipIntersection), T.push(L.depthPacking);
    }
    function S(T, L) {
      a.disableAll(), L.isWebGL2 && a.enable(0), L.supportsVertexTextures && a.enable(1), L.instancing && a.enable(2), L.instancingColor && a.enable(3), L.map && a.enable(4), L.matcap && a.enable(5), L.envMap && a.enable(6), L.lightMap && a.enable(7), L.aoMap && a.enable(8), L.emissiveMap && a.enable(9), L.bumpMap && a.enable(10), L.normalMap && a.enable(11), L.objectSpaceNormalMap && a.enable(12), L.tangentSpaceNormalMap && a.enable(13), L.clearcoat && a.enable(14), L.clearcoatMap && a.enable(15), L.clearcoatRoughnessMap && a.enable(16), L.clearcoatNormalMap && a.enable(17), L.iridescence && a.enable(18), L.iridescenceMap && a.enable(19), L.iridescenceThicknessMap && a.enable(20), L.displacementMap && a.enable(21), L.specularMap && a.enable(22), L.roughnessMap && a.enable(23), L.metalnessMap && a.enable(24), L.gradientMap && a.enable(25), L.alphaMap && a.enable(26), L.alphaTest && a.enable(27), L.vertexColors && a.enable(28), L.vertexAlphas && a.enable(29), L.vertexUvs && a.enable(30), L.vertexTangents && a.enable(31), L.uvsVertexOnly && a.enable(32), T.push(a.mask), a.disableAll(), L.fog && a.enable(0), L.useFog && a.enable(1), L.flatShading && a.enable(2), L.logarithmicDepthBuffer && a.enable(3), L.skinning && a.enable(4), L.morphTargets && a.enable(5), L.morphNormals && a.enable(6), L.morphColors && a.enable(7), L.premultipliedAlpha && a.enable(8), L.shadowMapEnabled && a.enable(9), L.physicallyCorrectLights && a.enable(10), L.doubleSided && a.enable(11), L.flipSided && a.enable(12), L.useDepthPacking && a.enable(13), L.dithering && a.enable(14), L.specularIntensityMap && a.enable(15), L.specularColorMap && a.enable(16), L.transmission && a.enable(17), L.transmissionMap && a.enable(18), L.thicknessMap && a.enable(19), L.sheen && a.enable(20), L.sheenColorMap && a.enable(21), L.sheenRoughnessMap && a.enable(22), L.decodeVideoTexture && a.enable(23), L.opaque && a.enable(24), T.push(a.mask);
    }
    function y(T) {
      const L = b[T.type];
      let F;
      if (L) {
        const j = En[L];
        F = Jf.clone(j.uniforms);
      } else F = T.uniforms;
      return F;
    }
    function M(T, L) {
      let F;
      for (let j = 0, Y = u.length; j < Y; j++) {
        const z = u[j];
        if (z.cacheKey === L) {
          F = z, ++F.usedTimes;
          break;
        }
      }
      return F === void 0 && (F = new vM(l, L, T, s), u.push(F)), F;
    }
    function C(T) {
      if (--T.usedTimes === 0) {
        const L = u.indexOf(T);
        u[L] = u[u.length - 1], u.pop(), T.destroy();
      }
    }
    function R(T) {
      c.remove(T);
    }
    function k() {
      c.dispose();
    }
    return {
      getParameters: _,
      getProgramCacheKey: x,
      getUniforms: y,
      acquireProgram: M,
      releaseProgram: C,
      releaseShaderCache: R,
      programs: u,
      dispose: k
    };
  }
  function wM() {
    let l = /* @__PURE__ */ new WeakMap();
    function e(s) {
      let r = l.get(s);
      return r === void 0 && (r = {}, l.set(s, r)), r;
    }
    function t(s) {
      l.delete(s);
    }
    function n(s, r, a) {
      l.get(s)[r] = a;
    }
    function i() {
      l = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      remove: t,
      update: n,
      dispose: i
    };
  }
  function MM(l, e) {
    return l.groupOrder !== e.groupOrder ? l.groupOrder - e.groupOrder : l.renderOrder !== e.renderOrder ? l.renderOrder - e.renderOrder : l.material.id !== e.material.id ? l.material.id - e.material.id : l.z !== e.z ? l.z - e.z : l.id - e.id;
  }
  function Hd(l, e) {
    return l.groupOrder !== e.groupOrder ? l.groupOrder - e.groupOrder : l.renderOrder !== e.renderOrder ? l.renderOrder - e.renderOrder : l.z !== e.z ? e.z - l.z : l.id - e.id;
  }
  function Wd() {
    const l = [];
    let e = 0;
    const t = [], n = [], i = [];
    function s() {
      e = 0, t.length = 0, n.length = 0, i.length = 0;
    }
    function r(f, m, v, b, _, x) {
      let w = l[e];
      return w === void 0 ? (w = {
        id: f.id,
        object: f,
        geometry: m,
        material: v,
        groupOrder: b,
        renderOrder: f.renderOrder,
        z: _,
        group: x
      }, l[e] = w) : (w.id = f.id, w.object = f, w.geometry = m, w.material = v, w.groupOrder = b, w.renderOrder = f.renderOrder, w.z = _, w.group = x), e++, w;
    }
    function a(f, m, v, b, _, x) {
      const w = r(f, m, v, b, _, x);
      v.transmission > 0 ? n.push(w) : v.transparent === true ? i.push(w) : t.push(w);
    }
    function c(f, m, v, b, _, x) {
      const w = r(f, m, v, b, _, x);
      v.transmission > 0 ? n.unshift(w) : v.transparent === true ? i.unshift(w) : t.unshift(w);
    }
    function u(f, m) {
      t.length > 1 && t.sort(f || MM), n.length > 1 && n.sort(m || Hd), i.length > 1 && i.sort(m || Hd);
    }
    function p() {
      for (let f = e, m = l.length; f < m; f++) {
        const v = l[f];
        if (v.id === null) break;
        v.id = null, v.object = null, v.geometry = null, v.material = null, v.group = null;
      }
    }
    return {
      opaque: t,
      transmissive: n,
      transparent: i,
      init: s,
      push: a,
      unshift: c,
      finish: p,
      sort: u
    };
  }
  function SM() {
    let l = /* @__PURE__ */ new WeakMap();
    function e(n, i) {
      const s = l.get(n);
      let r;
      return s === void 0 ? (r = new Wd(), l.set(n, [
        r
      ])) : i >= s.length ? (r = new Wd(), s.push(r)) : r = s[i], r;
    }
    function t() {
      l = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: e,
      dispose: t
    };
  }
  function EM() {
    const l = {};
    return {
      get: function(e) {
        if (l[e.id] !== void 0) return l[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              direction: new P(),
              color: new we()
            };
            break;
          case "SpotLight":
            t = {
              position: new P(),
              direction: new P(),
              color: new we(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            t = {
              position: new P(),
              color: new we(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            t = {
              direction: new P(),
              skyColor: new we(),
              groundColor: new we()
            };
            break;
          case "RectAreaLight":
            t = {
              color: new we(),
              position: new P(),
              halfWidth: new P(),
              halfHeight: new P()
            };
            break;
        }
        return l[e.id] = t, t;
      }
    };
  }
  function TM() {
    const l = {};
    return {
      get: function(e) {
        if (l[e.id] !== void 0) return l[e.id];
        let t;
        switch (e.type) {
          case "DirectionalLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new te()
            };
            break;
          case "SpotLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new te()
            };
            break;
          case "PointLight":
            t = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new te(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        return l[e.id] = t, t;
      }
    };
  }
  let CM = 0;
  function AM(l, e) {
    return (e.castShadow ? 2 : 0) - (l.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (l.map ? 1 : 0);
  }
  function PM(l, e) {
    const t = new EM(), n = TM(), i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1
      },
      ambient: [
        0,
        0,
        0
      ],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0
    };
    for (let p = 0; p < 9; p++) i.probe.push(new P());
    const s = new P(), r = new ze(), a = new ze();
    function c(p, f) {
      let m = 0, v = 0, b = 0;
      for (let j = 0; j < 9; j++) i.probe[j].set(0, 0, 0);
      let _ = 0, x = 0, w = 0, S = 0, y = 0, M = 0, C = 0, R = 0, k = 0, T = 0;
      p.sort(AM);
      const L = f !== true ? Math.PI : 1;
      for (let j = 0, Y = p.length; j < Y; j++) {
        const z = p[j], B = z.color, Z = z.intensity, ie = z.distance, re = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
        if (z.isAmbientLight) m += B.r * Z * L, v += B.g * Z * L, b += B.b * Z * L;
        else if (z.isLightProbe) for (let W = 0; W < 9; W++) i.probe[W].addScaledVector(z.sh.coefficients[W], Z);
        else if (z.isDirectionalLight) {
          const W = t.get(z);
          if (W.color.copy(z.color).multiplyScalar(z.intensity * L), z.castShadow) {
            const pe = z.shadow, ae = n.get(z);
            ae.shadowBias = pe.bias, ae.shadowNormalBias = pe.normalBias, ae.shadowRadius = pe.radius, ae.shadowMapSize = pe.mapSize, i.directionalShadow[_] = ae, i.directionalShadowMap[_] = re, i.directionalShadowMatrix[_] = z.shadow.matrix, M++;
          }
          i.directional[_] = W, _++;
        } else if (z.isSpotLight) {
          const W = t.get(z);
          W.position.setFromMatrixPosition(z.matrixWorld), W.color.copy(B).multiplyScalar(Z * L), W.distance = ie, W.coneCos = Math.cos(z.angle), W.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)), W.decay = z.decay, i.spot[w] = W;
          const pe = z.shadow;
          if (z.map && (i.spotLightMap[k] = z.map, k++, pe.updateMatrices(z), z.castShadow && T++), i.spotLightMatrix[w] = pe.matrix, z.castShadow) {
            const ae = n.get(z);
            ae.shadowBias = pe.bias, ae.shadowNormalBias = pe.normalBias, ae.shadowRadius = pe.radius, ae.shadowMapSize = pe.mapSize, i.spotShadow[w] = ae, i.spotShadowMap[w] = re, R++;
          }
          w++;
        } else if (z.isRectAreaLight) {
          const W = t.get(z);
          W.color.copy(B).multiplyScalar(Z), W.halfWidth.set(z.width * 0.5, 0, 0), W.halfHeight.set(0, z.height * 0.5, 0), i.rectArea[S] = W, S++;
        } else if (z.isPointLight) {
          const W = t.get(z);
          if (W.color.copy(z.color).multiplyScalar(z.intensity * L), W.distance = z.distance, W.decay = z.decay, z.castShadow) {
            const pe = z.shadow, ae = n.get(z);
            ae.shadowBias = pe.bias, ae.shadowNormalBias = pe.normalBias, ae.shadowRadius = pe.radius, ae.shadowMapSize = pe.mapSize, ae.shadowCameraNear = pe.camera.near, ae.shadowCameraFar = pe.camera.far, i.pointShadow[x] = ae, i.pointShadowMap[x] = re, i.pointShadowMatrix[x] = z.shadow.matrix, C++;
          }
          i.point[x] = W, x++;
        } else if (z.isHemisphereLight) {
          const W = t.get(z);
          W.skyColor.copy(z.color).multiplyScalar(Z * L), W.groundColor.copy(z.groundColor).multiplyScalar(Z * L), i.hemi[y] = W, y++;
        }
      }
      S > 0 && (e.isWebGL2 || l.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = _e.LTC_FLOAT_1, i.rectAreaLTC2 = _e.LTC_FLOAT_2) : l.has("OES_texture_half_float_linear") === true ? (i.rectAreaLTC1 = _e.LTC_HALF_1, i.rectAreaLTC2 = _e.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = m, i.ambient[1] = v, i.ambient[2] = b;
      const F = i.hash;
      (F.directionalLength !== _ || F.pointLength !== x || F.spotLength !== w || F.rectAreaLength !== S || F.hemiLength !== y || F.numDirectionalShadows !== M || F.numPointShadows !== C || F.numSpotShadows !== R || F.numSpotMaps !== k) && (i.directional.length = _, i.spot.length = w, i.rectArea.length = S, i.point.length = x, i.hemi.length = y, i.directionalShadow.length = M, i.directionalShadowMap.length = M, i.pointShadow.length = C, i.pointShadowMap.length = C, i.spotShadow.length = R, i.spotShadowMap.length = R, i.directionalShadowMatrix.length = M, i.pointShadowMatrix.length = C, i.spotLightMatrix.length = R + k - T, i.spotLightMap.length = k, i.numSpotLightShadowsWithMaps = T, F.directionalLength = _, F.pointLength = x, F.spotLength = w, F.rectAreaLength = S, F.hemiLength = y, F.numDirectionalShadows = M, F.numPointShadows = C, F.numSpotShadows = R, F.numSpotMaps = k, i.version = CM++);
    }
    function u(p, f) {
      let m = 0, v = 0, b = 0, _ = 0, x = 0;
      const w = f.matrixWorldInverse;
      for (let S = 0, y = p.length; S < y; S++) {
        const M = p[S];
        if (M.isDirectionalLight) {
          const C = i.directional[m];
          C.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(w), m++;
        } else if (M.isSpotLight) {
          const C = i.spot[b];
          C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(w), C.direction.setFromMatrixPosition(M.matrixWorld), s.setFromMatrixPosition(M.target.matrixWorld), C.direction.sub(s), C.direction.transformDirection(w), b++;
        } else if (M.isRectAreaLight) {
          const C = i.rectArea[_];
          C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(w), a.identity(), r.copy(M.matrixWorld), r.premultiply(w), a.extractRotation(r), C.halfWidth.set(M.width * 0.5, 0, 0), C.halfHeight.set(0, M.height * 0.5, 0), C.halfWidth.applyMatrix4(a), C.halfHeight.applyMatrix4(a), _++;
        } else if (M.isPointLight) {
          const C = i.point[v];
          C.position.setFromMatrixPosition(M.matrixWorld), C.position.applyMatrix4(w), v++;
        } else if (M.isHemisphereLight) {
          const C = i.hemi[x];
          C.direction.setFromMatrixPosition(M.matrixWorld), C.direction.transformDirection(w), x++;
        }
      }
    }
    return {
      setup: c,
      setupView: u,
      state: i
    };
  }
  function qd(l, e) {
    const t = new PM(l, e), n = [], i = [];
    function s() {
      n.length = 0, i.length = 0;
    }
    function r(f) {
      n.push(f);
    }
    function a(f) {
      i.push(f);
    }
    function c(f) {
      t.setup(n, f);
    }
    function u(f) {
      t.setupView(n, f);
    }
    return {
      init: s,
      state: {
        lightsArray: n,
        shadowsArray: i,
        lights: t
      },
      setupLights: c,
      setupLightsView: u,
      pushLight: r,
      pushShadow: a
    };
  }
  function LM(l, e) {
    let t = /* @__PURE__ */ new WeakMap();
    function n(s, r = 0) {
      const a = t.get(s);
      let c;
      return a === void 0 ? (c = new qd(l, e), t.set(s, [
        c
      ])) : r >= a.length ? (c = new qd(l, e), a.push(c)) : c = a[r], c;
    }
    function i() {
      t = /* @__PURE__ */ new WeakMap();
    }
    return {
      get: n,
      dispose: i
    };
  }
  class Lh extends Bt {
    constructor(e) {
      super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Hf, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
    }
  }
  class Rh extends Bt {
    constructor(e) {
      super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new P(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
    }
  }
  const RM = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, IM = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function DM(l, e, t) {
    let n = new Qa();
    const i = new te(), s = new te(), r = new ft(), a = new Lh({
      depthPacking: Wf
    }), c = new Rh(), u = {}, p = t.maxTextureSize, f = {
      [On]: on,
      [on]: On,
      [Dn]: Dn
    }, m = new Un({
      defines: {
        VSM_SAMPLES: 8
      },
      uniforms: {
        shadow_pass: {
          value: null
        },
        resolution: {
          value: new te()
        },
        radius: {
          value: 4
        }
      },
      vertexShader: RM,
      fragmentShader: IM
    }), v = m.clone();
    v.defines.HORIZONTAL_PASS = 1;
    const b = new Xe();
    b.setAttribute("position", new ht(new Float32Array([
      -1,
      -1,
      0.5,
      3,
      -1,
      0.5,
      -1,
      3,
      0.5
    ]), 3));
    const _ = new kt(b, m), x = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = gh, this.render = function(M, C, R) {
      if (x.enabled === false || x.autoUpdate === false && x.needsUpdate === false || M.length === 0) return;
      const k = l.getRenderTarget(), T = l.getActiveCubeFace(), L = l.getActiveMipmapLevel(), F = l.state;
      F.setBlending(ii), F.buffers.color.setClear(1, 1, 1, 1), F.buffers.depth.setTest(true), F.setScissorTest(false);
      for (let j = 0, Y = M.length; j < Y; j++) {
        const z = M[j], B = z.shadow;
        if (B === void 0) {
          console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
          continue;
        }
        if (B.autoUpdate === false && B.needsUpdate === false) continue;
        i.copy(B.mapSize);
        const Z = B.getFrameExtents();
        if (i.multiply(Z), s.copy(B.mapSize), (i.x > p || i.y > p) && (i.x > p && (s.x = Math.floor(p / Z.x), i.x = s.x * Z.x, B.mapSize.x = s.x), i.y > p && (s.y = Math.floor(p / Z.y), i.y = s.y * Z.y, B.mapSize.y = s.y)), B.map === null) {
          const re = this.type !== Xs ? {
            minFilter: Et,
            magFilter: Et
          } : {};
          B.map = new Tn(i.x, i.y, re), B.map.texture.name = z.name + ".shadowMap", B.camera.updateProjectionMatrix();
        }
        l.setRenderTarget(B.map), l.clear();
        const ie = B.getViewportCount();
        for (let re = 0; re < ie; re++) {
          const W = B.getViewport(re);
          r.set(s.x * W.x, s.y * W.y, s.x * W.z, s.y * W.w), F.viewport(r), B.updateMatrices(z, re), n = B.getFrustum(), y(C, R, B.camera, z, this.type);
        }
        B.isPointLightShadow !== true && this.type === Xs && w(B, R), B.needsUpdate = false;
      }
      x.needsUpdate = false, l.setRenderTarget(k, T, L);
    };
    function w(M, C) {
      const R = e.update(_);
      m.defines.VSM_SAMPLES !== M.blurSamples && (m.defines.VSM_SAMPLES = M.blurSamples, v.defines.VSM_SAMPLES = M.blurSamples, m.needsUpdate = true, v.needsUpdate = true), M.mapPass === null && (M.mapPass = new Tn(i.x, i.y)), m.uniforms.shadow_pass.value = M.map.texture, m.uniforms.resolution.value = M.mapSize, m.uniforms.radius.value = M.radius, l.setRenderTarget(M.mapPass), l.clear(), l.renderBufferDirect(C, null, R, m, _, null), v.uniforms.shadow_pass.value = M.mapPass.texture, v.uniforms.resolution.value = M.mapSize, v.uniforms.radius.value = M.radius, l.setRenderTarget(M.map), l.clear(), l.renderBufferDirect(C, null, R, v, _, null);
    }
    function S(M, C, R, k, T, L) {
      let F = null;
      const j = R.isPointLight === true ? M.customDistanceMaterial : M.customDepthMaterial;
      if (j !== void 0) F = j;
      else if (F = R.isPointLight === true ? c : a, l.localClippingEnabled && C.clipShadows === true && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0 || C.displacementMap && C.displacementScale !== 0 || C.alphaMap && C.alphaTest > 0 || C.map && C.alphaTest > 0) {
        const Y = F.uuid, z = C.uuid;
        let B = u[Y];
        B === void 0 && (B = {}, u[Y] = B);
        let Z = B[z];
        Z === void 0 && (Z = F.clone(), B[z] = Z), F = Z;
      }
      return F.visible = C.visible, F.wireframe = C.wireframe, L === Xs ? F.side = C.shadowSide !== null ? C.shadowSide : C.side : F.side = C.shadowSide !== null ? C.shadowSide : f[C.side], F.alphaMap = C.alphaMap, F.alphaTest = C.alphaTest, F.map = C.map, F.clipShadows = C.clipShadows, F.clippingPlanes = C.clippingPlanes, F.clipIntersection = C.clipIntersection, F.displacementMap = C.displacementMap, F.displacementScale = C.displacementScale, F.displacementBias = C.displacementBias, F.wireframeLinewidth = C.wireframeLinewidth, F.linewidth = C.linewidth, R.isPointLight === true && F.isMeshDistanceMaterial === true && (F.referencePosition.setFromMatrixPosition(R.matrixWorld), F.nearDistance = k, F.farDistance = T), F;
    }
    function y(M, C, R, k, T) {
      if (M.visible === false) return;
      if (M.layers.test(C.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && T === Xs) && (!M.frustumCulled || n.intersectsObject(M))) {
        M.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, M.matrixWorld);
        const j = e.update(M), Y = M.material;
        if (Array.isArray(Y)) {
          const z = j.groups;
          for (let B = 0, Z = z.length; B < Z; B++) {
            const ie = z[B], re = Y[ie.materialIndex];
            if (re && re.visible) {
              const W = S(M, re, k, R.near, R.far, T);
              l.renderBufferDirect(R, null, j, W, M, ie);
            }
          }
        } else if (Y.visible) {
          const z = S(M, Y, k, R.near, R.far, T);
          l.renderBufferDirect(R, null, j, z, M, null);
        }
      }
      const F = M.children;
      for (let j = 0, Y = F.length; j < Y; j++) y(F[j], C, R, k, T);
    }
  }
  function kM(l, e, t) {
    const n = t.isWebGL2;
    function i() {
      let U = false;
      const J = new ft();
      let ue = null;
      const Se = new ft(0, 0, 0, 0);
      return {
        setMask: function(De) {
          ue !== De && !U && (l.colorMask(De, De, De, De), ue = De);
        },
        setLocked: function(De) {
          U = De;
        },
        setClear: function(De, at, Lt, Rt, bn) {
          bn === true && (De *= Rt, at *= Rt, Lt *= Rt), J.set(De, at, Lt, Rt), Se.equals(J) === false && (l.clearColor(De, at, Lt, Rt), Se.copy(J));
        },
        reset: function() {
          U = false, ue = null, Se.set(-1, 0, 0, 0);
        }
      };
    }
    function s() {
      let U = false, J = null, ue = null, Se = null;
      return {
        setTest: function(De) {
          De ? ke(2929) : Ce(2929);
        },
        setMask: function(De) {
          J !== De && !U && (l.depthMask(De), J = De);
        },
        setFunc: function(De) {
          if (ue !== De) {
            switch (De) {
              case uf:
                l.depthFunc(512);
                break;
              case df:
                l.depthFunc(519);
                break;
              case pf:
                l.depthFunc(513);
                break;
              case Va:
                l.depthFunc(515);
                break;
              case ff:
                l.depthFunc(514);
                break;
              case mf:
                l.depthFunc(518);
                break;
              case gf:
                l.depthFunc(516);
                break;
              case vf:
                l.depthFunc(517);
                break;
              default:
                l.depthFunc(515);
            }
            ue = De;
          }
        },
        setLocked: function(De) {
          U = De;
        },
        setClear: function(De) {
          Se !== De && (l.clearDepth(De), Se = De);
        },
        reset: function() {
          U = false, J = null, ue = null, Se = null;
        }
      };
    }
    function r() {
      let U = false, J = null, ue = null, Se = null, De = null, at = null, Lt = null, Rt = null, bn = null;
      return {
        setTest: function(nt) {
          U || (nt ? ke(2960) : Ce(2960));
        },
        setMask: function(nt) {
          J !== nt && !U && (l.stencilMask(nt), J = nt);
        },
        setFunc: function(nt, an, Tt) {
          (ue !== nt || Se !== an || De !== Tt) && (l.stencilFunc(nt, an, Tt), ue = nt, Se = an, De = Tt);
        },
        setOp: function(nt, an, Tt) {
          (at !== nt || Lt !== an || Rt !== Tt) && (l.stencilOp(nt, an, Tt), at = nt, Lt = an, Rt = Tt);
        },
        setLocked: function(nt) {
          U = nt;
        },
        setClear: function(nt) {
          bn !== nt && (l.clearStencil(nt), bn = nt);
        },
        reset: function() {
          U = false, J = null, ue = null, Se = null, De = null, at = null, Lt = null, Rt = null, bn = null;
        }
      };
    }
    const a = new i(), c = new s(), u = new r(), p = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
    let m = {}, v = {}, b = /* @__PURE__ */ new WeakMap(), _ = [], x = null, w = false, S = null, y = null, M = null, C = null, R = null, k = null, T = null, L = false, F = null, j = null, Y = null, z = null, B = null;
    const Z = l.getParameter(35661);
    let ie = false, re = 0;
    const W = l.getParameter(7938);
    W.indexOf("WebGL") !== -1 ? (re = parseFloat(/^WebGL (\d)/.exec(W)[1]), ie = re >= 1) : W.indexOf("OpenGL ES") !== -1 && (re = parseFloat(/^OpenGL ES (\d)/.exec(W)[1]), ie = re >= 2);
    let pe = null, ae = {};
    const Te = l.getParameter(3088), q = l.getParameter(2978), le = new ft().fromArray(Te), oe = new ft().fromArray(q);
    function ce(U, J, ue) {
      const Se = new Uint8Array(4), De = l.createTexture();
      l.bindTexture(U, De), l.texParameteri(U, 10241, 9728), l.texParameteri(U, 10240, 9728);
      for (let at = 0; at < ue; at++) l.texImage2D(J + at, 0, 6408, 1, 1, 0, 6408, 5121, Se);
      return De;
    }
    const K = {};
    K[3553] = ce(3553, 3553, 1), K[34067] = ce(34067, 34069, 6), a.setClear(0, 0, 0, 1), c.setClear(1), u.setClear(0), ke(2929), c.setFunc(Va), fe(false), Fe(Cc), ke(2884), ge(ii);
    function ke(U) {
      m[U] !== true && (l.enable(U), m[U] = true);
    }
    function Ce(U) {
      m[U] !== false && (l.disable(U), m[U] = false);
    }
    function Le(U, J) {
      return v[U] !== J ? (l.bindFramebuffer(U, J), v[U] = J, n && (U === 36009 && (v[36160] = J), U === 36160 && (v[36009] = J)), true) : false;
    }
    function ve(U, J) {
      let ue = _, Se = false;
      if (U) if (ue = b.get(J), ue === void 0 && (ue = [], b.set(J, ue)), U.isWebGLMultipleRenderTargets) {
        const De = U.texture;
        if (ue.length !== De.length || ue[0] !== 36064) {
          for (let at = 0, Lt = De.length; at < Lt; at++) ue[at] = 36064 + at;
          ue.length = De.length, Se = true;
        }
      } else ue[0] !== 36064 && (ue[0] = 36064, Se = true);
      else ue[0] !== 1029 && (ue[0] = 1029, Se = true);
      Se && (t.isWebGL2 ? l.drawBuffers(ue) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ue));
    }
    function Ve(U) {
      return x !== U ? (l.useProgram(U), x = U, true) : false;
    }
    const se = {
      [Qi]: 32774,
      [Qp]: 32778,
      [ef]: 32779
    };
    if (n) se[Rc] = 32775, se[Ic] = 32776;
    else {
      const U = e.get("EXT_blend_minmax");
      U !== null && (se[Rc] = U.MIN_EXT, se[Ic] = U.MAX_EXT);
    }
    const ne = {
      [tf]: 0,
      [nf]: 1,
      [sf]: 768,
      [_h]: 770,
      [hf]: 776,
      [lf]: 774,
      [of]: 772,
      [rf]: 769,
      [xh]: 771,
      [cf]: 775,
      [af]: 773
    };
    function ge(U, J, ue, Se, De, at, Lt, Rt) {
      if (U === ii) {
        w === true && (Ce(3042), w = false);
        return;
      }
      if (w === false && (ke(3042), w = true), U !== Jp) {
        if (U !== S || Rt !== L) {
          if ((y !== Qi || R !== Qi) && (l.blendEquation(32774), y = Qi, R = Qi), Rt) switch (U) {
            case rs:
              l.blendFuncSeparate(1, 771, 1, 771);
              break;
            case Ac:
              l.blendFunc(1, 1);
              break;
            case Pc:
              l.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Lc:
              l.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", U);
              break;
          }
          else switch (U) {
            case rs:
              l.blendFuncSeparate(770, 771, 1, 771);
              break;
            case Ac:
              l.blendFunc(770, 1);
              break;
            case Pc:
              l.blendFuncSeparate(0, 769, 0, 1);
              break;
            case Lc:
              l.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", U);
              break;
          }
          M = null, C = null, k = null, T = null, S = U, L = Rt;
        }
        return;
      }
      De = De || J, at = at || ue, Lt = Lt || Se, (J !== y || De !== R) && (l.blendEquationSeparate(se[J], se[De]), y = J, R = De), (ue !== M || Se !== C || at !== k || Lt !== T) && (l.blendFuncSeparate(ne[ue], ne[Se], ne[at], ne[Lt]), M = ue, C = Se, k = at, T = Lt), S = U, L = false;
    }
    function Ee(U, J) {
      U.side === Dn ? Ce(2884) : ke(2884);
      let ue = U.side === on;
      J && (ue = !ue), fe(ue), U.blending === rs && U.transparent === false ? ge(ii) : ge(U.blending, U.blendEquation, U.blendSrc, U.blendDst, U.blendEquationAlpha, U.blendSrcAlpha, U.blendDstAlpha, U.premultipliedAlpha), c.setFunc(U.depthFunc), c.setTest(U.depthTest), c.setMask(U.depthWrite), a.setMask(U.colorWrite);
      const Se = U.stencilWrite;
      u.setTest(Se), Se && (u.setMask(U.stencilWriteMask), u.setFunc(U.stencilFunc, U.stencilRef, U.stencilFuncMask), u.setOp(U.stencilFail, U.stencilZFail, U.stencilZPass)), Re(U.polygonOffset, U.polygonOffsetFactor, U.polygonOffsetUnits), U.alphaToCoverage === true ? ke(32926) : Ce(32926);
    }
    function fe(U) {
      F !== U && (U ? l.frontFace(2304) : l.frontFace(2305), F = U);
    }
    function Fe(U) {
      U !== $p ? (ke(2884), U !== j && (U === Cc ? l.cullFace(1029) : U === Zp ? l.cullFace(1028) : l.cullFace(1032))) : Ce(2884), j = U;
    }
    function Ne(U) {
      U !== Y && (ie && l.lineWidth(U), Y = U);
    }
    function Re(U, J, ue) {
      U ? (ke(32823), (z !== J || B !== ue) && (l.polygonOffset(J, ue), z = J, B = ue)) : Ce(32823);
    }
    function dt(U) {
      U ? ke(3089) : Ce(3089);
    }
    function it(U) {
      U === void 0 && (U = 33984 + Z - 1), pe !== U && (l.activeTexture(U), pe = U);
    }
    function D(U, J, ue) {
      ue === void 0 && (pe === null ? ue = 33984 + Z - 1 : ue = pe);
      let Se = ae[ue];
      Se === void 0 && (Se = {
        type: void 0,
        texture: void 0
      }, ae[ue] = Se), (Se.type !== U || Se.texture !== J) && (pe !== ue && (l.activeTexture(ue), pe = ue), l.bindTexture(U, J || K[U]), Se.type = U, Se.texture = J);
    }
    function A() {
      const U = ae[pe];
      U !== void 0 && U.type !== void 0 && (l.bindTexture(U.type, null), U.type = void 0, U.texture = void 0);
    }
    function $() {
      try {
        l.compressedTexImage2D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function he() {
      try {
        l.compressedTexImage3D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function me() {
      try {
        l.texSubImage2D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function xe() {
      try {
        l.texSubImage3D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function Be() {
      try {
        l.compressedTexSubImage2D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function O() {
      try {
        l.compressedTexSubImage3D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function G() {
      try {
        l.texStorage2D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function ye() {
      try {
        l.texStorage3D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function Me() {
      try {
        l.texImage2D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function be() {
      try {
        l.texImage3D.apply(l, arguments);
      } catch (U) {
        console.error("THREE.WebGLState:", U);
      }
    }
    function Ie(U) {
      le.equals(U) === false && (l.scissor(U.x, U.y, U.z, U.w), le.copy(U));
    }
    function Ae(U) {
      oe.equals(U) === false && (l.viewport(U.x, U.y, U.z, U.w), oe.copy(U));
    }
    function qe(U, J) {
      let ue = f.get(J);
      ue === void 0 && (ue = /* @__PURE__ */ new WeakMap(), f.set(J, ue));
      let Se = ue.get(U);
      Se === void 0 && (Se = l.getUniformBlockIndex(J, U.name), ue.set(U, Se));
    }
    function je(U, J) {
      const Se = f.get(J).get(U);
      p.get(J) !== Se && (l.uniformBlockBinding(J, Se, U.__bindingPointIndex), p.set(J, Se));
    }
    function pt() {
      l.disable(3042), l.disable(2884), l.disable(2929), l.disable(32823), l.disable(3089), l.disable(2960), l.disable(32926), l.blendEquation(32774), l.blendFunc(1, 0), l.blendFuncSeparate(1, 0, 1, 0), l.colorMask(true, true, true, true), l.clearColor(0, 0, 0, 0), l.depthMask(true), l.depthFunc(513), l.clearDepth(1), l.stencilMask(4294967295), l.stencilFunc(519, 0, 4294967295), l.stencilOp(7680, 7680, 7680), l.clearStencil(0), l.cullFace(1029), l.frontFace(2305), l.polygonOffset(0, 0), l.activeTexture(33984), l.bindFramebuffer(36160, null), n === true && (l.bindFramebuffer(36009, null), l.bindFramebuffer(36008, null)), l.useProgram(null), l.lineWidth(1), l.scissor(0, 0, l.canvas.width, l.canvas.height), l.viewport(0, 0, l.canvas.width, l.canvas.height), m = {}, pe = null, ae = {}, v = {}, b = /* @__PURE__ */ new WeakMap(), _ = [], x = null, w = false, S = null, y = null, M = null, C = null, R = null, k = null, T = null, L = false, F = null, j = null, Y = null, z = null, B = null, le.set(0, 0, l.canvas.width, l.canvas.height), oe.set(0, 0, l.canvas.width, l.canvas.height), a.reset(), c.reset(), u.reset();
    }
    return {
      buffers: {
        color: a,
        depth: c,
        stencil: u
      },
      enable: ke,
      disable: Ce,
      bindFramebuffer: Le,
      drawBuffers: ve,
      useProgram: Ve,
      setBlending: ge,
      setMaterial: Ee,
      setFlipSided: fe,
      setCullFace: Fe,
      setLineWidth: Ne,
      setPolygonOffset: Re,
      setScissorTest: dt,
      activeTexture: it,
      bindTexture: D,
      unbindTexture: A,
      compressedTexImage2D: $,
      compressedTexImage3D: he,
      texImage2D: Me,
      texImage3D: be,
      updateUBOMapping: qe,
      uniformBlockBinding: je,
      texStorage2D: G,
      texStorage3D: ye,
      texSubImage2D: me,
      texSubImage3D: xe,
      compressedTexSubImage2D: Be,
      compressedTexSubImage3D: O,
      scissor: Ie,
      viewport: Ae,
      reset: pt
    };
  }
  function NM(l, e, t, n, i, s, r) {
    const a = i.isWebGL2, c = i.maxTextures, u = i.maxCubemapSize, p = i.maxTextureSize, f = i.maxSamples, m = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, v = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), b = /* @__PURE__ */ new WeakMap();
    let _;
    const x = /* @__PURE__ */ new WeakMap();
    let w = false;
    try {
      w = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {
    }
    function S(D, A) {
      return w ? new OffscreenCanvas(D, A) : so("canvas");
    }
    function y(D, A, $, he) {
      let me = 1;
      if ((D.width > he || D.height > he) && (me = he / Math.max(D.width, D.height)), me < 1 || A === true) if (typeof HTMLImageElement < "u" && D instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && D instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && D instanceof ImageBitmap) {
        const xe = A ? Wa : Math.floor, Be = xe(me * D.width), O = xe(me * D.height);
        _ === void 0 && (_ = S(Be, O));
        const G = $ ? S(Be, O) : _;
        return G.width = Be, G.height = O, G.getContext("2d").drawImage(D, 0, 0, Be, O), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + D.width + "x" + D.height + ") to (" + Be + "x" + O + ")."), G;
      } else return "data" in D && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + D.width + "x" + D.height + ")."), D;
      return D;
    }
    function M(D) {
      return ih(D.width) && ih(D.height);
    }
    function C(D) {
      return a ? false : D.wrapS !== Xt || D.wrapT !== Xt || D.minFilter !== Et && D.minFilter !== yt;
    }
    function R(D, A) {
      return D.generateMipmaps && A && D.minFilter !== Et && D.minFilter !== yt;
    }
    function k(D) {
      l.generateMipmap(D);
    }
    function T(D, A, $, he, me = false) {
      if (a === false) return A;
      if (D !== null) {
        if (l[D] !== void 0) return l[D];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + D + "'");
      }
      let xe = A;
      return A === 6403 && ($ === 5126 && (xe = 33326), $ === 5131 && (xe = 33325), $ === 5121 && (xe = 33321)), A === 33319 && ($ === 5126 && (xe = 33328), $ === 5131 && (xe = 33327), $ === 5121 && (xe = 33323)), A === 6408 && ($ === 5126 && (xe = 34836), $ === 5131 && (xe = 34842), $ === 5121 && (xe = he === ct && me === false ? 35907 : 32856), $ === 32819 && (xe = 32854), $ === 32820 && (xe = 32855)), (xe === 33325 || xe === 33326 || xe === 33327 || xe === 33328 || xe === 34842 || xe === 34836) && e.get("EXT_color_buffer_float"), xe;
    }
    function L(D, A, $) {
      return R(D, $) === true || D.isFramebufferTexture && D.minFilter !== Et && D.minFilter !== yt ? Math.log2(Math.max(A.width, A.height)) + 1 : D.mipmaps !== void 0 && D.mipmaps.length > 0 ? D.mipmaps.length : D.isCompressedTexture && Array.isArray(D.image) ? A.mipmaps.length : 1;
    }
    function F(D) {
      return D === Et || D === eo || D === Zs ? 9728 : 9729;
    }
    function j(D) {
      const A = D.target;
      A.removeEventListener("dispose", j), z(A), A.isVideoTexture && b.delete(A);
    }
    function Y(D) {
      const A = D.target;
      A.removeEventListener("dispose", Y), Z(A);
    }
    function z(D) {
      const A = n.get(D);
      if (A.__webglInit === void 0) return;
      const $ = D.source, he = x.get($);
      if (he) {
        const me = he[A.__cacheKey];
        me.usedTimes--, me.usedTimes === 0 && B(D), Object.keys(he).length === 0 && x.delete($);
      }
      n.remove(D);
    }
    function B(D) {
      const A = n.get(D);
      l.deleteTexture(A.__webglTexture);
      const $ = D.source, he = x.get($);
      delete he[A.__cacheKey], r.memory.textures--;
    }
    function Z(D) {
      const A = D.texture, $ = n.get(D), he = n.get(A);
      if (he.__webglTexture !== void 0 && (l.deleteTexture(he.__webglTexture), r.memory.textures--), D.depthTexture && D.depthTexture.dispose(), D.isWebGLCubeRenderTarget) for (let me = 0; me < 6; me++) l.deleteFramebuffer($.__webglFramebuffer[me]), $.__webglDepthbuffer && l.deleteRenderbuffer($.__webglDepthbuffer[me]);
      else {
        if (l.deleteFramebuffer($.__webglFramebuffer), $.__webglDepthbuffer && l.deleteRenderbuffer($.__webglDepthbuffer), $.__webglMultisampledFramebuffer && l.deleteFramebuffer($.__webglMultisampledFramebuffer), $.__webglColorRenderbuffer) for (let me = 0; me < $.__webglColorRenderbuffer.length; me++) $.__webglColorRenderbuffer[me] && l.deleteRenderbuffer($.__webglColorRenderbuffer[me]);
        $.__webglDepthRenderbuffer && l.deleteRenderbuffer($.__webglDepthRenderbuffer);
      }
      if (D.isWebGLMultipleRenderTargets) for (let me = 0, xe = A.length; me < xe; me++) {
        const Be = n.get(A[me]);
        Be.__webglTexture && (l.deleteTexture(Be.__webglTexture), r.memory.textures--), n.remove(A[me]);
      }
      n.remove(A), n.remove(D);
    }
    let ie = 0;
    function re() {
      ie = 0;
    }
    function W() {
      const D = ie;
      return D >= c && console.warn("THREE.WebGLTextures: Trying to use " + D + " texture units while this GPU supports only " + c), ie += 1, D;
    }
    function pe(D) {
      const A = [];
      return A.push(D.wrapS), A.push(D.wrapT), A.push(D.wrapR || 0), A.push(D.magFilter), A.push(D.minFilter), A.push(D.anisotropy), A.push(D.internalFormat), A.push(D.format), A.push(D.type), A.push(D.generateMipmaps), A.push(D.premultiplyAlpha), A.push(D.flipY), A.push(D.unpackAlignment), A.push(D.encoding), A.join();
    }
    function ae(D, A) {
      const $ = n.get(D);
      if (D.isVideoTexture && dt(D), D.isRenderTargetTexture === false && D.version > 0 && $.__version !== D.version) {
        const he = D.image;
        if (he === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
        else if (he.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
          Ce($, D, A);
          return;
        }
      }
      t.bindTexture(3553, $.__webglTexture, 33984 + A);
    }
    function Te(D, A) {
      const $ = n.get(D);
      if (D.version > 0 && $.__version !== D.version) {
        Ce($, D, A);
        return;
      }
      t.bindTexture(35866, $.__webglTexture, 33984 + A);
    }
    function q(D, A) {
      const $ = n.get(D);
      if (D.version > 0 && $.__version !== D.version) {
        Ce($, D, A);
        return;
      }
      t.bindTexture(32879, $.__webglTexture, 33984 + A);
    }
    function le(D, A) {
      const $ = n.get(D);
      if (D.version > 0 && $.__version !== D.version) {
        Le($, D, A);
        return;
      }
      t.bindTexture(34067, $.__webglTexture, 33984 + A);
    }
    const oe = {
      [Ti]: 10497,
      [Xt]: 33071,
      [er]: 33648
    }, ce = {
      [Et]: 9728,
      [eo]: 9984,
      [Zs]: 9986,
      [yt]: 9729,
      [Ka]: 9985,
      [Fn]: 9987
    };
    function K(D, A, $) {
      if ($ ? (l.texParameteri(D, 10242, oe[A.wrapS]), l.texParameteri(D, 10243, oe[A.wrapT]), (D === 32879 || D === 35866) && l.texParameteri(D, 32882, oe[A.wrapR]), l.texParameteri(D, 10240, ce[A.magFilter]), l.texParameteri(D, 10241, ce[A.minFilter])) : (l.texParameteri(D, 10242, 33071), l.texParameteri(D, 10243, 33071), (D === 32879 || D === 35866) && l.texParameteri(D, 32882, 33071), (A.wrapS !== Xt || A.wrapT !== Xt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), l.texParameteri(D, 10240, F(A.magFilter)), l.texParameteri(D, 10241, F(A.minFilter)), A.minFilter !== Et && A.minFilter !== yt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === true) {
        const he = e.get("EXT_texture_filter_anisotropic");
        if (A.magFilter === Et || A.minFilter !== Zs && A.minFilter !== Fn || A.type === ei && e.has("OES_texture_float_linear") === false || a === false && A.type === tr && e.has("OES_texture_half_float_linear") === false) return;
        (A.anisotropy > 1 || n.get(A).__currentAnisotropy) && (l.texParameterf(D, he.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(A.anisotropy, i.getMaxAnisotropy())), n.get(A).__currentAnisotropy = A.anisotropy);
      }
    }
    function ke(D, A) {
      let $ = false;
      D.__webglInit === void 0 && (D.__webglInit = true, A.addEventListener("dispose", j));
      const he = A.source;
      let me = x.get(he);
      me === void 0 && (me = {}, x.set(he, me));
      const xe = pe(A);
      if (xe !== D.__cacheKey) {
        me[xe] === void 0 && (me[xe] = {
          texture: l.createTexture(),
          usedTimes: 0
        }, r.memory.textures++, $ = true), me[xe].usedTimes++;
        const Be = me[D.__cacheKey];
        Be !== void 0 && (me[D.__cacheKey].usedTimes--, Be.usedTimes === 0 && B(A)), D.__cacheKey = xe, D.__webglTexture = me[xe].texture;
      }
      return $;
    }
    function Ce(D, A, $) {
      let he = 3553;
      (A.isDataArrayTexture || A.isCompressedArrayTexture) && (he = 35866), A.isData3DTexture && (he = 32879);
      const me = ke(D, A), xe = A.source;
      t.bindTexture(he, D.__webglTexture, 33984 + $);
      const Be = n.get(xe);
      if (xe.version !== Be.__version || me === true) {
        t.activeTexture(33984 + $), l.pixelStorei(37440, A.flipY), l.pixelStorei(37441, A.premultiplyAlpha), l.pixelStorei(3317, A.unpackAlignment), l.pixelStorei(37443, 0);
        const O = C(A) && M(A.image) === false;
        let G = y(A.image, O, false, p);
        G = it(A, G);
        const ye = M(G) || a, Me = s.convert(A.format, A.encoding);
        let be = s.convert(A.type), Ie = T(A.internalFormat, Me, be, A.encoding, A.isVideoTexture);
        K(he, A, ye);
        let Ae;
        const qe = A.mipmaps, je = a && A.isVideoTexture !== true, pt = Be.__version === void 0 || me === true, U = L(A, G, ye);
        if (A.isDepthTexture) Ie = 6402, a ? A.type === ei ? Ie = 36012 : A.type === wi ? Ie = 33190 : A.type === os ? Ie = 35056 : Ie = 33189 : A.type === ei && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), A.format === Mi && Ie === 6402 && A.type !== yh && A.type !== wi && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), A.type = wi, be = s.convert(A.type)), A.format === hs && Ie === 6402 && (Ie = 34041, A.type !== os && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), A.type = os, be = s.convert(A.type))), pt && (je ? t.texStorage2D(3553, 1, Ie, G.width, G.height) : t.texImage2D(3553, 0, Ie, G.width, G.height, 0, Me, be, null));
        else if (A.isDataTexture) if (qe.length > 0 && ye) {
          je && pt && t.texStorage2D(3553, U, Ie, qe[0].width, qe[0].height);
          for (let J = 0, ue = qe.length; J < ue; J++) Ae = qe[J], je ? t.texSubImage2D(3553, J, 0, 0, Ae.width, Ae.height, Me, be, Ae.data) : t.texImage2D(3553, J, Ie, Ae.width, Ae.height, 0, Me, be, Ae.data);
          A.generateMipmaps = false;
        } else je ? (pt && t.texStorage2D(3553, U, Ie, G.width, G.height), t.texSubImage2D(3553, 0, 0, 0, G.width, G.height, Me, be, G.data)) : t.texImage2D(3553, 0, Ie, G.width, G.height, 0, Me, be, G.data);
        else if (A.isCompressedTexture) if (A.isCompressedArrayTexture) {
          je && pt && t.texStorage3D(35866, U, Ie, qe[0].width, qe[0].height, G.depth);
          for (let J = 0, ue = qe.length; J < ue; J++) Ae = qe[J], A.format !== un ? Me !== null ? je ? t.compressedTexSubImage3D(35866, J, 0, 0, 0, Ae.width, Ae.height, G.depth, Me, Ae.data, 0, 0) : t.compressedTexImage3D(35866, J, Ie, Ae.width, Ae.height, G.depth, 0, Ae.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : je ? t.texSubImage3D(35866, J, 0, 0, 0, Ae.width, Ae.height, G.depth, Me, be, Ae.data) : t.texImage3D(35866, J, Ie, Ae.width, Ae.height, G.depth, 0, Me, be, Ae.data);
        } else {
          je && pt && t.texStorage2D(3553, U, Ie, qe[0].width, qe[0].height);
          for (let J = 0, ue = qe.length; J < ue; J++) Ae = qe[J], A.format !== un ? Me !== null ? je ? t.compressedTexSubImage2D(3553, J, 0, 0, Ae.width, Ae.height, Me, Ae.data) : t.compressedTexImage2D(3553, J, Ie, Ae.width, Ae.height, 0, Ae.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : je ? t.texSubImage2D(3553, J, 0, 0, Ae.width, Ae.height, Me, be, Ae.data) : t.texImage2D(3553, J, Ie, Ae.width, Ae.height, 0, Me, be, Ae.data);
        }
        else if (A.isDataArrayTexture) je ? (pt && t.texStorage3D(35866, U, Ie, G.width, G.height, G.depth), t.texSubImage3D(35866, 0, 0, 0, 0, G.width, G.height, G.depth, Me, be, G.data)) : t.texImage3D(35866, 0, Ie, G.width, G.height, G.depth, 0, Me, be, G.data);
        else if (A.isData3DTexture) je ? (pt && t.texStorage3D(32879, U, Ie, G.width, G.height, G.depth), t.texSubImage3D(32879, 0, 0, 0, 0, G.width, G.height, G.depth, Me, be, G.data)) : t.texImage3D(32879, 0, Ie, G.width, G.height, G.depth, 0, Me, be, G.data);
        else if (A.isFramebufferTexture) {
          if (pt) if (je) t.texStorage2D(3553, U, Ie, G.width, G.height);
          else {
            let J = G.width, ue = G.height;
            for (let Se = 0; Se < U; Se++) t.texImage2D(3553, Se, Ie, J, ue, 0, Me, be, null), J >>= 1, ue >>= 1;
          }
        } else if (qe.length > 0 && ye) {
          je && pt && t.texStorage2D(3553, U, Ie, qe[0].width, qe[0].height);
          for (let J = 0, ue = qe.length; J < ue; J++) Ae = qe[J], je ? t.texSubImage2D(3553, J, 0, 0, Me, be, Ae) : t.texImage2D(3553, J, Ie, Me, be, Ae);
          A.generateMipmaps = false;
        } else je ? (pt && t.texStorage2D(3553, U, Ie, G.width, G.height), t.texSubImage2D(3553, 0, 0, 0, Me, be, G)) : t.texImage2D(3553, 0, Ie, Me, be, G);
        R(A, ye) && k(he), Be.__version = xe.version, A.onUpdate && A.onUpdate(A);
      }
      D.__version = A.version;
    }
    function Le(D, A, $) {
      if (A.image.length !== 6) return;
      const he = ke(D, A), me = A.source;
      t.bindTexture(34067, D.__webglTexture, 33984 + $);
      const xe = n.get(me);
      if (me.version !== xe.__version || he === true) {
        t.activeTexture(33984 + $), l.pixelStorei(37440, A.flipY), l.pixelStorei(37441, A.premultiplyAlpha), l.pixelStorei(3317, A.unpackAlignment), l.pixelStorei(37443, 0);
        const Be = A.isCompressedTexture || A.image[0].isCompressedTexture, O = A.image[0] && A.image[0].isDataTexture, G = [];
        for (let J = 0; J < 6; J++) !Be && !O ? G[J] = y(A.image[J], false, true, u) : G[J] = O ? A.image[J].image : A.image[J], G[J] = it(A, G[J]);
        const ye = G[0], Me = M(ye) || a, be = s.convert(A.format, A.encoding), Ie = s.convert(A.type), Ae = T(A.internalFormat, be, Ie, A.encoding), qe = a && A.isVideoTexture !== true, je = xe.__version === void 0 || he === true;
        let pt = L(A, ye, Me);
        K(34067, A, Me);
        let U;
        if (Be) {
          qe && je && t.texStorage2D(34067, pt, Ae, ye.width, ye.height);
          for (let J = 0; J < 6; J++) {
            U = G[J].mipmaps;
            for (let ue = 0; ue < U.length; ue++) {
              const Se = U[ue];
              A.format !== un ? be !== null ? qe ? t.compressedTexSubImage2D(34069 + J, ue, 0, 0, Se.width, Se.height, be, Se.data) : t.compressedTexImage2D(34069 + J, ue, Ae, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : qe ? t.texSubImage2D(34069 + J, ue, 0, 0, Se.width, Se.height, be, Ie, Se.data) : t.texImage2D(34069 + J, ue, Ae, Se.width, Se.height, 0, be, Ie, Se.data);
            }
          }
        } else {
          U = A.mipmaps, qe && je && (U.length > 0 && pt++, t.texStorage2D(34067, pt, Ae, G[0].width, G[0].height));
          for (let J = 0; J < 6; J++) if (O) {
            qe ? t.texSubImage2D(34069 + J, 0, 0, 0, G[J].width, G[J].height, be, Ie, G[J].data) : t.texImage2D(34069 + J, 0, Ae, G[J].width, G[J].height, 0, be, Ie, G[J].data);
            for (let ue = 0; ue < U.length; ue++) {
              const De = U[ue].image[J].image;
              qe ? t.texSubImage2D(34069 + J, ue + 1, 0, 0, De.width, De.height, be, Ie, De.data) : t.texImage2D(34069 + J, ue + 1, Ae, De.width, De.height, 0, be, Ie, De.data);
            }
          } else {
            qe ? t.texSubImage2D(34069 + J, 0, 0, 0, be, Ie, G[J]) : t.texImage2D(34069 + J, 0, Ae, be, Ie, G[J]);
            for (let ue = 0; ue < U.length; ue++) {
              const Se = U[ue];
              qe ? t.texSubImage2D(34069 + J, ue + 1, 0, 0, be, Ie, Se.image[J]) : t.texImage2D(34069 + J, ue + 1, Ae, be, Ie, Se.image[J]);
            }
          }
        }
        R(A, Me) && k(34067), xe.__version = me.version, A.onUpdate && A.onUpdate(A);
      }
      D.__version = A.version;
    }
    function ve(D, A, $, he, me) {
      const xe = s.convert($.format, $.encoding), Be = s.convert($.type), O = T($.internalFormat, xe, Be, $.encoding);
      n.get(A).__hasExternalTextures || (me === 32879 || me === 35866 ? t.texImage3D(me, 0, O, A.width, A.height, A.depth, 0, xe, Be, null) : t.texImage2D(me, 0, O, A.width, A.height, 0, xe, Be, null)), t.bindFramebuffer(36160, D), Re(A) ? m.framebufferTexture2DMultisampleEXT(36160, he, me, n.get($).__webglTexture, 0, Ne(A)) : (me === 3553 || me >= 34069 && me <= 34074) && l.framebufferTexture2D(36160, he, me, n.get($).__webglTexture, 0), t.bindFramebuffer(36160, null);
    }
    function Ve(D, A, $) {
      if (l.bindRenderbuffer(36161, D), A.depthBuffer && !A.stencilBuffer) {
        let he = 33189;
        if ($ || Re(A)) {
          const me = A.depthTexture;
          me && me.isDepthTexture && (me.type === ei ? he = 36012 : me.type === wi && (he = 33190));
          const xe = Ne(A);
          Re(A) ? m.renderbufferStorageMultisampleEXT(36161, xe, he, A.width, A.height) : l.renderbufferStorageMultisample(36161, xe, he, A.width, A.height);
        } else l.renderbufferStorage(36161, he, A.width, A.height);
        l.framebufferRenderbuffer(36160, 36096, 36161, D);
      } else if (A.depthBuffer && A.stencilBuffer) {
        const he = Ne(A);
        $ && Re(A) === false ? l.renderbufferStorageMultisample(36161, he, 35056, A.width, A.height) : Re(A) ? m.renderbufferStorageMultisampleEXT(36161, he, 35056, A.width, A.height) : l.renderbufferStorage(36161, 34041, A.width, A.height), l.framebufferRenderbuffer(36160, 33306, 36161, D);
      } else {
        const he = A.isWebGLMultipleRenderTargets === true ? A.texture : [
          A.texture
        ];
        for (let me = 0; me < he.length; me++) {
          const xe = he[me], Be = s.convert(xe.format, xe.encoding), O = s.convert(xe.type), G = T(xe.internalFormat, Be, O, xe.encoding), ye = Ne(A);
          $ && Re(A) === false ? l.renderbufferStorageMultisample(36161, ye, G, A.width, A.height) : Re(A) ? m.renderbufferStorageMultisampleEXT(36161, ye, G, A.width, A.height) : l.renderbufferStorage(36161, G, A.width, A.height);
        }
      }
      l.bindRenderbuffer(36161, null);
    }
    function se(D, A) {
      if (A && A.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (t.bindFramebuffer(36160, D), !(A.depthTexture && A.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      (!n.get(A.depthTexture).__webglTexture || A.depthTexture.image.width !== A.width || A.depthTexture.image.height !== A.height) && (A.depthTexture.image.width = A.width, A.depthTexture.image.height = A.height, A.depthTexture.needsUpdate = true), ae(A.depthTexture, 0);
      const he = n.get(A.depthTexture).__webglTexture, me = Ne(A);
      if (A.depthTexture.format === Mi) Re(A) ? m.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, he, 0, me) : l.framebufferTexture2D(36160, 36096, 3553, he, 0);
      else if (A.depthTexture.format === hs) Re(A) ? m.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, he, 0, me) : l.framebufferTexture2D(36160, 33306, 3553, he, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function ne(D) {
      const A = n.get(D), $ = D.isWebGLCubeRenderTarget === true;
      if (D.depthTexture && !A.__autoAllocateDepthBuffer) {
        if ($) throw new Error("target.depthTexture not supported in Cube render targets");
        se(A.__webglFramebuffer, D);
      } else if ($) {
        A.__webglDepthbuffer = [];
        for (let he = 0; he < 6; he++) t.bindFramebuffer(36160, A.__webglFramebuffer[he]), A.__webglDepthbuffer[he] = l.createRenderbuffer(), Ve(A.__webglDepthbuffer[he], D, false);
      } else t.bindFramebuffer(36160, A.__webglFramebuffer), A.__webglDepthbuffer = l.createRenderbuffer(), Ve(A.__webglDepthbuffer, D, false);
      t.bindFramebuffer(36160, null);
    }
    function ge(D, A, $) {
      const he = n.get(D);
      A !== void 0 && ve(he.__webglFramebuffer, D, D.texture, 36064, 3553), $ !== void 0 && ne(D);
    }
    function Ee(D) {
      const A = D.texture, $ = n.get(D), he = n.get(A);
      D.addEventListener("dispose", Y), D.isWebGLMultipleRenderTargets !== true && (he.__webglTexture === void 0 && (he.__webglTexture = l.createTexture()), he.__version = A.version, r.memory.textures++);
      const me = D.isWebGLCubeRenderTarget === true, xe = D.isWebGLMultipleRenderTargets === true, Be = M(D) || a;
      if (me) {
        $.__webglFramebuffer = [];
        for (let O = 0; O < 6; O++) $.__webglFramebuffer[O] = l.createFramebuffer();
      } else {
        if ($.__webglFramebuffer = l.createFramebuffer(), xe) if (i.drawBuffers) {
          const O = D.texture;
          for (let G = 0, ye = O.length; G < ye; G++) {
            const Me = n.get(O[G]);
            Me.__webglTexture === void 0 && (Me.__webglTexture = l.createTexture(), r.memory.textures++);
          }
        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        if (a && D.samples > 0 && Re(D) === false) {
          const O = xe ? A : [
            A
          ];
          $.__webglMultisampledFramebuffer = l.createFramebuffer(), $.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, $.__webglMultisampledFramebuffer);
          for (let G = 0; G < O.length; G++) {
            const ye = O[G];
            $.__webglColorRenderbuffer[G] = l.createRenderbuffer(), l.bindRenderbuffer(36161, $.__webglColorRenderbuffer[G]);
            const Me = s.convert(ye.format, ye.encoding), be = s.convert(ye.type), Ie = T(ye.internalFormat, Me, be, ye.encoding, D.isXRRenderTarget === true), Ae = Ne(D);
            l.renderbufferStorageMultisample(36161, Ae, Ie, D.width, D.height), l.framebufferRenderbuffer(36160, 36064 + G, 36161, $.__webglColorRenderbuffer[G]);
          }
          l.bindRenderbuffer(36161, null), D.depthBuffer && ($.__webglDepthRenderbuffer = l.createRenderbuffer(), Ve($.__webglDepthRenderbuffer, D, true)), t.bindFramebuffer(36160, null);
        }
      }
      if (me) {
        t.bindTexture(34067, he.__webglTexture), K(34067, A, Be);
        for (let O = 0; O < 6; O++) ve($.__webglFramebuffer[O], D, A, 36064, 34069 + O);
        R(A, Be) && k(34067), t.unbindTexture();
      } else if (xe) {
        const O = D.texture;
        for (let G = 0, ye = O.length; G < ye; G++) {
          const Me = O[G], be = n.get(Me);
          t.bindTexture(3553, be.__webglTexture), K(3553, Me, Be), ve($.__webglFramebuffer, D, Me, 36064 + G, 3553), R(Me, Be) && k(3553);
        }
        t.unbindTexture();
      } else {
        let O = 3553;
        (D.isWebGL3DRenderTarget || D.isWebGLArrayRenderTarget) && (a ? O = D.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(O, he.__webglTexture), K(O, A, Be), ve($.__webglFramebuffer, D, A, 36064, O), R(A, Be) && k(O), t.unbindTexture();
      }
      D.depthBuffer && ne(D);
    }
    function fe(D) {
      const A = M(D) || a, $ = D.isWebGLMultipleRenderTargets === true ? D.texture : [
        D.texture
      ];
      for (let he = 0, me = $.length; he < me; he++) {
        const xe = $[he];
        if (R(xe, A)) {
          const Be = D.isWebGLCubeRenderTarget ? 34067 : 3553, O = n.get(xe).__webglTexture;
          t.bindTexture(Be, O), k(Be), t.unbindTexture();
        }
      }
    }
    function Fe(D) {
      if (a && D.samples > 0 && Re(D) === false) {
        const A = D.isWebGLMultipleRenderTargets ? D.texture : [
          D.texture
        ], $ = D.width, he = D.height;
        let me = 16384;
        const xe = [], Be = D.stencilBuffer ? 33306 : 36096, O = n.get(D), G = D.isWebGLMultipleRenderTargets === true;
        if (G) for (let ye = 0; ye < A.length; ye++) t.bindFramebuffer(36160, O.__webglMultisampledFramebuffer), l.framebufferRenderbuffer(36160, 36064 + ye, 36161, null), t.bindFramebuffer(36160, O.__webglFramebuffer), l.framebufferTexture2D(36009, 36064 + ye, 3553, null, 0);
        t.bindFramebuffer(36008, O.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, O.__webglFramebuffer);
        for (let ye = 0; ye < A.length; ye++) {
          xe.push(36064 + ye), D.depthBuffer && xe.push(Be);
          const Me = O.__ignoreDepthValues !== void 0 ? O.__ignoreDepthValues : false;
          if (Me === false && (D.depthBuffer && (me |= 256), D.stencilBuffer && (me |= 1024)), G && l.framebufferRenderbuffer(36008, 36064, 36161, O.__webglColorRenderbuffer[ye]), Me === true && (l.invalidateFramebuffer(36008, [
            Be
          ]), l.invalidateFramebuffer(36009, [
            Be
          ])), G) {
            const be = n.get(A[ye]).__webglTexture;
            l.framebufferTexture2D(36009, 36064, 3553, be, 0);
          }
          l.blitFramebuffer(0, 0, $, he, 0, 0, $, he, me, 9728), v && l.invalidateFramebuffer(36008, xe);
        }
        if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), G) for (let ye = 0; ye < A.length; ye++) {
          t.bindFramebuffer(36160, O.__webglMultisampledFramebuffer), l.framebufferRenderbuffer(36160, 36064 + ye, 36161, O.__webglColorRenderbuffer[ye]);
          const Me = n.get(A[ye]).__webglTexture;
          t.bindFramebuffer(36160, O.__webglFramebuffer), l.framebufferTexture2D(36009, 36064 + ye, 3553, Me, 0);
        }
        t.bindFramebuffer(36009, O.__webglMultisampledFramebuffer);
      }
    }
    function Ne(D) {
      return Math.min(f, D.samples);
    }
    function Re(D) {
      const A = n.get(D);
      return a && D.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && A.__useRenderToTexture !== false;
    }
    function dt(D) {
      const A = r.render.frame;
      b.get(D) !== A && (b.set(D, A), D.update());
    }
    function it(D, A) {
      const $ = D.encoding, he = D.format, me = D.type;
      return D.isCompressedTexture === true || D.isVideoTexture === true || D.format === Ha || $ !== Ai && ($ === ct ? a === false ? e.has("EXT_sRGB") === true && he === un ? (D.format = Ha, D.minFilter = yt, D.generateMipmaps = false) : A = Eh.sRGBToLinear(A) : (he !== un || me !== Ci) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", $)), A;
    }
    this.allocateTextureUnit = W, this.resetTextureUnits = re, this.setTexture2D = ae, this.setTexture2DArray = Te, this.setTexture3D = q, this.setTextureCube = le, this.rebindTextures = ge, this.setupRenderTarget = Ee, this.updateRenderTargetMipmap = fe, this.updateMultisampleRenderTarget = Fe, this.setupDepthRenderbuffer = ne, this.setupFrameBufferTexture = ve, this.useMultisampledRTT = Re;
  }
  function om(l, e, t) {
    const n = t.isWebGL2;
    function i(s, r = null) {
      let a;
      if (s === Ci) return 5121;
      if (s === Cf) return 32819;
      if (s === Af) return 32820;
      if (s === Sf) return 5120;
      if (s === Ef) return 5122;
      if (s === yh) return 5123;
      if (s === Tf) return 5124;
      if (s === wi) return 5125;
      if (s === ei) return 5126;
      if (s === tr) return n ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
      if (s === Pf) return 6406;
      if (s === un) return 6408;
      if (s === Lf) return 6409;
      if (s === Rf) return 6410;
      if (s === Mi) return 6402;
      if (s === hs) return 34041;
      if (s === Ha) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
      if (s === If) return 6403;
      if (s === Df) return 36244;
      if (s === kf) return 33319;
      if (s === Nf) return 33320;
      if (s === Of) return 36249;
      if (s === La || s === Ra || s === Ia || s === Da) if (r === ct) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
        if (s === La) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
        if (s === Ra) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
        if (s === Ia) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
        if (s === Da) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
      } else return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (s === La) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Ra) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Ia) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Da) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (s === Dc || s === kc || s === Nc || s === Oc) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (s === Dc) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === kc) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Nc) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Oc) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (s === Ff) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (s === Fc || s === Bc) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (s === Fc) return r === ct ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Bc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
      if (s === Uc || s === zc || s === Vc || s === Gc || s === Hc || s === Wc || s === qc || s === Xc || s === jc || s === Kc || s === Yc || s === $c || s === Zc || s === Jc) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (s === Uc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === zc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Vc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Gc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Hc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === Wc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === qc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Xc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === jc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === Kc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === Yc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === $c) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === Zc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === Jc) return r === ct ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
      if (s === ka) if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (s === ka) return r === ct ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
      if (s === Bf || s === Qc || s === eh || s === th) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (s === ka) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === Qc) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === eh) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === th) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
      return s === os ? n ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : l[s] !== void 0 ? l[s] : null;
    }
    return {
      convert: i
    };
  }
  class am extends Ft {
    constructor(e = []) {
      super(), this.isArrayCamera = true, this.cameras = e;
    }
  }
  class ni extends rt {
    constructor() {
      super(), this.isGroup = true, this.type = "Group";
    }
  }
  const OM = {
    type: "move"
  };
  class lc {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new ni(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
        pinching: false
      }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new ni(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new P(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new P()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new ni(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new P(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new P()), this._grip;
    }
    dispatchEvent(e) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
    }
    connect(e) {
      if (e && e.hand) {
        const t = this._hand;
        if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
      }
      return this.dispatchEvent({
        type: "connected",
        data: e
      }), this;
    }
    disconnect(e) {
      return this.dispatchEvent({
        type: "disconnected",
        data: e
      }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(e, t, n) {
      let i = null, s = null, r = null;
      const a = this._targetRay, c = this._grip, u = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
        if (u && e.hand) {
          r = true;
          for (const _ of e.hand.values()) {
            const x = t.getJointPose(_, n), w = this._getHandJoint(u, _);
            x !== null && (w.matrix.fromArray(x.transform.matrix), w.matrix.decompose(w.position, w.rotation, w.scale), w.jointRadius = x.radius), w.visible = x !== null;
          }
          const p = u.joints["index-finger-tip"], f = u.joints["thumb-tip"], m = p.position.distanceTo(f.position), v = 0.02, b = 5e-3;
          u.inputState.pinching && m > v + b ? (u.inputState.pinching = false, this.dispatchEvent({
            type: "pinchend",
            handedness: e.handedness,
            target: this
          })) : !u.inputState.pinching && m <= v - b && (u.inputState.pinching = true, this.dispatchEvent({
            type: "pinchstart",
            handedness: e.handedness,
            target: this
          }));
        } else c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), s.linearVelocity ? (c.hasLinearVelocity = true, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = false, s.angularVelocity ? (c.hasAngularVelocity = true, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = false));
        a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = false, i.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(OM)));
      }
      return a !== null && (a.visible = i !== null), c !== null && (c.visible = s !== null), u !== null && (u.visible = r !== null), this;
    }
    _getHandJoint(e, t) {
      if (e.joints[t.jointName] === void 0) {
        const n = new ni();
        n.matrixAutoUpdate = false, n.visible = false, e.joints[t.jointName] = n, e.add(n);
      }
      return e.joints[t.jointName];
    }
  }
  class lm extends Mt {
    constructor(e, t, n, i, s, r, a, c, u, p) {
      if (p = p !== void 0 ? p : Mi, p !== Mi && p !== hs) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n === void 0 && p === Mi && (n = wi), n === void 0 && p === hs && (n = os), super(null, i, s, r, a, c, p, n, u), this.isDepthTexture = true, this.image = {
        width: e,
        height: t
      }, this.magFilter = a !== void 0 ? a : Et, this.minFilter = c !== void 0 ? c : Et, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class FM extends zn {
    constructor(e, t) {
      super();
      const n = this;
      let i = null, s = 1, r = null, a = "local-floor", c = 1, u = null, p = null, f = null, m = null, v = null, b = null;
      const _ = t.getContextAttributes();
      let x = null, w = null;
      const S = [], y = [], M = /* @__PURE__ */ new Set(), C = /* @__PURE__ */ new Map(), R = new Ft();
      R.layers.enable(1), R.viewport = new ft();
      const k = new Ft();
      k.layers.enable(2), k.viewport = new ft();
      const T = [
        R,
        k
      ], L = new am();
      L.layers.enable(1), L.layers.enable(2);
      let F = null, j = null;
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(q) {
        let le = S[q];
        return le === void 0 && (le = new lc(), S[q] = le), le.getTargetRaySpace();
      }, this.getControllerGrip = function(q) {
        let le = S[q];
        return le === void 0 && (le = new lc(), S[q] = le), le.getGripSpace();
      }, this.getHand = function(q) {
        let le = S[q];
        return le === void 0 && (le = new lc(), S[q] = le), le.getHandSpace();
      };
      function Y(q) {
        const le = y.indexOf(q.inputSource);
        if (le === -1) return;
        const oe = S[le];
        oe !== void 0 && oe.dispatchEvent({
          type: q.type,
          data: q.inputSource
        });
      }
      function z() {
        i.removeEventListener("select", Y), i.removeEventListener("selectstart", Y), i.removeEventListener("selectend", Y), i.removeEventListener("squeeze", Y), i.removeEventListener("squeezestart", Y), i.removeEventListener("squeezeend", Y), i.removeEventListener("end", z), i.removeEventListener("inputsourceschange", B);
        for (let q = 0; q < S.length; q++) {
          const le = y[q];
          le !== null && (y[q] = null, S[q].disconnect(le));
        }
        F = null, j = null, e.setRenderTarget(x), v = null, m = null, f = null, i = null, w = null, Te.stop(), n.isPresenting = false, n.dispatchEvent({
          type: "sessionend"
        });
      }
      this.setFramebufferScaleFactor = function(q) {
        s = q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(q) {
        a = q, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return u || r;
      }, this.setReferenceSpace = function(q) {
        u = q;
      }, this.getBaseLayer = function() {
        return m !== null ? m : v;
      }, this.getBinding = function() {
        return f;
      }, this.getFrame = function() {
        return b;
      }, this.getSession = function() {
        return i;
      }, this.setSession = async function(q) {
        if (i = q, i !== null) {
          if (x = e.getRenderTarget(), i.addEventListener("select", Y), i.addEventListener("selectstart", Y), i.addEventListener("selectend", Y), i.addEventListener("squeeze", Y), i.addEventListener("squeezestart", Y), i.addEventListener("squeezeend", Y), i.addEventListener("end", z), i.addEventListener("inputsourceschange", B), _.xrCompatible !== true && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === false) {
            const le = {
              antialias: i.renderState.layers === void 0 ? _.antialias : true,
              alpha: _.alpha,
              depth: _.depth,
              stencil: _.stencil,
              framebufferScaleFactor: s
            };
            v = new XRWebGLLayer(i, t, le), i.updateRenderState({
              baseLayer: v
            }), w = new Tn(v.framebufferWidth, v.framebufferHeight, {
              format: un,
              type: Ci,
              encoding: e.outputEncoding,
              stencilBuffer: _.stencil
            });
          } else {
            let le = null, oe = null, ce = null;
            _.depth && (ce = _.stencil ? 35056 : 33190, le = _.stencil ? hs : Mi, oe = _.stencil ? os : wi);
            const K = {
              colorFormat: 32856,
              depthFormat: ce,
              scaleFactor: s
            };
            f = new XRWebGLBinding(i, t), m = f.createProjectionLayer(K), i.updateRenderState({
              layers: [
                m
              ]
            }), w = new Tn(m.textureWidth, m.textureHeight, {
              format: un,
              type: Ci,
              depthTexture: new lm(m.textureWidth, m.textureHeight, oe, void 0, void 0, void 0, void 0, void 0, void 0, le),
              stencilBuffer: _.stencil,
              encoding: e.outputEncoding,
              samples: _.antialias ? 4 : 0
            });
            const ke = e.properties.get(w);
            ke.__ignoreDepthValues = m.ignoreDepthValues;
          }
          w.isXRRenderTarget = true, this.setFoveation(c), u = null, r = await i.requestReferenceSpace(a), Te.setContext(i), Te.start(), n.isPresenting = true, n.dispatchEvent({
            type: "sessionstart"
          });
        }
      };
      function B(q) {
        for (let le = 0; le < q.removed.length; le++) {
          const oe = q.removed[le], ce = y.indexOf(oe);
          ce >= 0 && (y[ce] = null, S[ce].disconnect(oe));
        }
        for (let le = 0; le < q.added.length; le++) {
          const oe = q.added[le];
          let ce = y.indexOf(oe);
          if (ce === -1) {
            for (let ke = 0; ke < S.length; ke++) if (ke >= y.length) {
              y.push(oe), ce = ke;
              break;
            } else if (y[ke] === null) {
              y[ke] = oe, ce = ke;
              break;
            }
            if (ce === -1) break;
          }
          const K = S[ce];
          K && K.connect(oe);
        }
      }
      const Z = new P(), ie = new P();
      function re(q, le, oe) {
        Z.setFromMatrixPosition(le.matrixWorld), ie.setFromMatrixPosition(oe.matrixWorld);
        const ce = Z.distanceTo(ie), K = le.projectionMatrix.elements, ke = oe.projectionMatrix.elements, Ce = K[14] / (K[10] - 1), Le = K[14] / (K[10] + 1), ve = (K[9] + 1) / K[5], Ve = (K[9] - 1) / K[5], se = (K[8] - 1) / K[0], ne = (ke[8] + 1) / ke[0], ge = Ce * se, Ee = Ce * ne, fe = ce / (-se + ne), Fe = fe * -se;
        le.matrixWorld.decompose(q.position, q.quaternion, q.scale), q.translateX(Fe), q.translateZ(fe), q.matrixWorld.compose(q.position, q.quaternion, q.scale), q.matrixWorldInverse.copy(q.matrixWorld).invert();
        const Ne = Ce + fe, Re = Le + fe, dt = ge - Fe, it = Ee + (ce - Fe), D = ve * Le / Re * Ne, A = Ve * Le / Re * Ne;
        q.projectionMatrix.makePerspective(dt, it, D, A, Ne, Re);
      }
      function W(q, le) {
        le === null ? q.matrixWorld.copy(q.matrix) : q.matrixWorld.multiplyMatrices(le.matrixWorld, q.matrix), q.matrixWorldInverse.copy(q.matrixWorld).invert();
      }
      this.updateCamera = function(q) {
        if (i === null) return;
        L.near = k.near = R.near = q.near, L.far = k.far = R.far = q.far, (F !== L.near || j !== L.far) && (i.updateRenderState({
          depthNear: L.near,
          depthFar: L.far
        }), F = L.near, j = L.far);
        const le = q.parent, oe = L.cameras;
        W(L, le);
        for (let K = 0; K < oe.length; K++) W(oe[K], le);
        L.matrixWorld.decompose(L.position, L.quaternion, L.scale), q.matrix.copy(L.matrix), q.matrix.decompose(q.position, q.quaternion, q.scale);
        const ce = q.children;
        for (let K = 0, ke = ce.length; K < ke; K++) ce[K].updateMatrixWorld(true);
        oe.length === 2 ? re(L, R, k) : L.projectionMatrix.copy(R.projectionMatrix);
      }, this.getCamera = function() {
        return L;
      }, this.getFoveation = function() {
        if (!(m === null && v === null)) return c;
      }, this.setFoveation = function(q) {
        c = q, m !== null && (m.fixedFoveation = q), v !== null && v.fixedFoveation !== void 0 && (v.fixedFoveation = q);
      }, this.getPlanes = function() {
        return M;
      };
      let pe = null;
      function ae(q, le) {
        if (p = le.getViewerPose(u || r), b = le, p !== null) {
          const oe = p.views;
          v !== null && (e.setRenderTargetFramebuffer(w, v.framebuffer), e.setRenderTarget(w));
          let ce = false;
          oe.length !== L.cameras.length && (L.cameras.length = 0, ce = true);
          for (let K = 0; K < oe.length; K++) {
            const ke = oe[K];
            let Ce = null;
            if (v !== null) Ce = v.getViewport(ke);
            else {
              const ve = f.getViewSubImage(m, ke);
              Ce = ve.viewport, K === 0 && (e.setRenderTargetTextures(w, ve.colorTexture, m.ignoreDepthValues ? void 0 : ve.depthStencilTexture), e.setRenderTarget(w));
            }
            let Le = T[K];
            Le === void 0 && (Le = new Ft(), Le.layers.enable(K), Le.viewport = new ft(), T[K] = Le), Le.matrix.fromArray(ke.transform.matrix), Le.projectionMatrix.fromArray(ke.projectionMatrix), Le.viewport.set(Ce.x, Ce.y, Ce.width, Ce.height), K === 0 && L.matrix.copy(Le.matrix), ce === true && L.cameras.push(Le);
          }
        }
        for (let oe = 0; oe < S.length; oe++) {
          const ce = y[oe], K = S[oe];
          ce !== null && K !== void 0 && K.update(ce, le, u || r);
        }
        if (pe && pe(q, le), le.detectedPlanes) {
          n.dispatchEvent({
            type: "planesdetected",
            data: le.detectedPlanes
          });
          let oe = null;
          for (const ce of M) le.detectedPlanes.has(ce) || (oe === null && (oe = []), oe.push(ce));
          if (oe !== null) for (const ce of oe) M.delete(ce), C.delete(ce), n.dispatchEvent({
            type: "planeremoved",
            data: ce
          });
          for (const ce of le.detectedPlanes) if (!M.has(ce)) M.add(ce), C.set(ce, le.lastChangedTime), n.dispatchEvent({
            type: "planeadded",
            data: ce
          });
          else {
            const K = C.get(ce);
            ce.lastChangedTime > K && (C.set(ce, ce.lastChangedTime), n.dispatchEvent({
              type: "planechanged",
              data: ce
            }));
          }
        }
        b = null;
      }
      const Te = new tm();
      Te.setAnimationLoop(ae), this.setAnimationLoop = function(q) {
        pe = q;
      }, this.dispose = function() {
      };
    }
  }
  function BM(l, e) {
    function t(_, x) {
      x.color.getRGB(_.fogColor.value, Zf(l)), x.isFog ? (_.fogNear.value = x.near, _.fogFar.value = x.far) : x.isFogExp2 && (_.fogDensity.value = x.density);
    }
    function n(_, x, w, S, y) {
      x.isMeshBasicMaterial || x.isMeshLambertMaterial ? i(_, x) : x.isMeshToonMaterial ? (i(_, x), p(_, x)) : x.isMeshPhongMaterial ? (i(_, x), u(_, x)) : x.isMeshStandardMaterial ? (i(_, x), f(_, x), x.isMeshPhysicalMaterial && m(_, x, y)) : x.isMeshMatcapMaterial ? (i(_, x), v(_, x)) : x.isMeshDepthMaterial ? i(_, x) : x.isMeshDistanceMaterial ? (i(_, x), b(_, x)) : x.isMeshNormalMaterial ? i(_, x) : x.isLineBasicMaterial ? (s(_, x), x.isLineDashedMaterial && r(_, x)) : x.isPointsMaterial ? a(_, x, w, S) : x.isSpriteMaterial ? c(_, x) : x.isShadowMaterial ? (_.color.value.copy(x.color), _.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = false);
    }
    function i(_, x) {
      _.opacity.value = x.opacity, x.color && _.diffuse.value.copy(x.color), x.emissive && _.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (_.map.value = x.map), x.alphaMap && (_.alphaMap.value = x.alphaMap), x.bumpMap && (_.bumpMap.value = x.bumpMap, _.bumpScale.value = x.bumpScale, x.side === on && (_.bumpScale.value *= -1)), x.displacementMap && (_.displacementMap.value = x.displacementMap, _.displacementScale.value = x.displacementScale, _.displacementBias.value = x.displacementBias), x.emissiveMap && (_.emissiveMap.value = x.emissiveMap), x.normalMap && (_.normalMap.value = x.normalMap, _.normalScale.value.copy(x.normalScale), x.side === on && _.normalScale.value.negate()), x.specularMap && (_.specularMap.value = x.specularMap), x.alphaTest > 0 && (_.alphaTest.value = x.alphaTest);
      const w = e.get(x).envMap;
      if (w && (_.envMap.value = w, _.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === false ? -1 : 1, _.reflectivity.value = x.reflectivity, _.ior.value = x.ior, _.refractionRatio.value = x.refractionRatio), x.lightMap) {
        _.lightMap.value = x.lightMap;
        const M = l.physicallyCorrectLights !== true ? Math.PI : 1;
        _.lightMapIntensity.value = x.lightMapIntensity * M;
      }
      x.aoMap && (_.aoMap.value = x.aoMap, _.aoMapIntensity.value = x.aoMapIntensity);
      let S;
      x.map ? S = x.map : x.specularMap ? S = x.specularMap : x.displacementMap ? S = x.displacementMap : x.normalMap ? S = x.normalMap : x.bumpMap ? S = x.bumpMap : x.roughnessMap ? S = x.roughnessMap : x.metalnessMap ? S = x.metalnessMap : x.alphaMap ? S = x.alphaMap : x.emissiveMap ? S = x.emissiveMap : x.clearcoatMap ? S = x.clearcoatMap : x.clearcoatNormalMap ? S = x.clearcoatNormalMap : x.clearcoatRoughnessMap ? S = x.clearcoatRoughnessMap : x.iridescenceMap ? S = x.iridescenceMap : x.iridescenceThicknessMap ? S = x.iridescenceThicknessMap : x.specularIntensityMap ? S = x.specularIntensityMap : x.specularColorMap ? S = x.specularColorMap : x.transmissionMap ? S = x.transmissionMap : x.thicknessMap ? S = x.thicknessMap : x.sheenColorMap ? S = x.sheenColorMap : x.sheenRoughnessMap && (S = x.sheenRoughnessMap), S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture), S.matrixAutoUpdate === true && S.updateMatrix(), _.uvTransform.value.copy(S.matrix));
      let y;
      x.aoMap ? y = x.aoMap : x.lightMap && (y = x.lightMap), y !== void 0 && (y.isWebGLRenderTarget && (y = y.texture), y.matrixAutoUpdate === true && y.updateMatrix(), _.uv2Transform.value.copy(y.matrix));
    }
    function s(_, x) {
      _.diffuse.value.copy(x.color), _.opacity.value = x.opacity;
    }
    function r(_, x) {
      _.dashSize.value = x.dashSize, _.totalSize.value = x.dashSize + x.gapSize, _.scale.value = x.scale;
    }
    function a(_, x, w, S) {
      _.diffuse.value.copy(x.color), _.opacity.value = x.opacity, _.size.value = x.size * w, _.scale.value = S * 0.5, x.map && (_.map.value = x.map), x.alphaMap && (_.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (_.alphaTest.value = x.alphaTest);
      let y;
      x.map ? y = x.map : x.alphaMap && (y = x.alphaMap), y !== void 0 && (y.matrixAutoUpdate === true && y.updateMatrix(), _.uvTransform.value.copy(y.matrix));
    }
    function c(_, x) {
      _.diffuse.value.copy(x.color), _.opacity.value = x.opacity, _.rotation.value = x.rotation, x.map && (_.map.value = x.map), x.alphaMap && (_.alphaMap.value = x.alphaMap), x.alphaTest > 0 && (_.alphaTest.value = x.alphaTest);
      let w;
      x.map ? w = x.map : x.alphaMap && (w = x.alphaMap), w !== void 0 && (w.matrixAutoUpdate === true && w.updateMatrix(), _.uvTransform.value.copy(w.matrix));
    }
    function u(_, x) {
      _.specular.value.copy(x.specular), _.shininess.value = Math.max(x.shininess, 1e-4);
    }
    function p(_, x) {
      x.gradientMap && (_.gradientMap.value = x.gradientMap);
    }
    function f(_, x) {
      _.roughness.value = x.roughness, _.metalness.value = x.metalness, x.roughnessMap && (_.roughnessMap.value = x.roughnessMap), x.metalnessMap && (_.metalnessMap.value = x.metalnessMap), e.get(x).envMap && (_.envMapIntensity.value = x.envMapIntensity);
    }
    function m(_, x, w) {
      _.ior.value = x.ior, x.sheen > 0 && (_.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen), _.sheenRoughness.value = x.sheenRoughness, x.sheenColorMap && (_.sheenColorMap.value = x.sheenColorMap), x.sheenRoughnessMap && (_.sheenRoughnessMap.value = x.sheenRoughnessMap)), x.clearcoat > 0 && (_.clearcoat.value = x.clearcoat, _.clearcoatRoughness.value = x.clearcoatRoughness, x.clearcoatMap && (_.clearcoatMap.value = x.clearcoatMap), x.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap), x.clearcoatNormalMap && (_.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), _.clearcoatNormalMap.value = x.clearcoatNormalMap, x.side === on && _.clearcoatNormalScale.value.negate())), x.iridescence > 0 && (_.iridescence.value = x.iridescence, _.iridescenceIOR.value = x.iridescenceIOR, _.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0], _.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1], x.iridescenceMap && (_.iridescenceMap.value = x.iridescenceMap), x.iridescenceThicknessMap && (_.iridescenceThicknessMap.value = x.iridescenceThicknessMap)), x.transmission > 0 && (_.transmission.value = x.transmission, _.transmissionSamplerMap.value = w.texture, _.transmissionSamplerSize.value.set(w.width, w.height), x.transmissionMap && (_.transmissionMap.value = x.transmissionMap), _.thickness.value = x.thickness, x.thicknessMap && (_.thicknessMap.value = x.thicknessMap), _.attenuationDistance.value = x.attenuationDistance, _.attenuationColor.value.copy(x.attenuationColor)), _.specularIntensity.value = x.specularIntensity, _.specularColor.value.copy(x.specularColor), x.specularIntensityMap && (_.specularIntensityMap.value = x.specularIntensityMap), x.specularColorMap && (_.specularColorMap.value = x.specularColorMap);
    }
    function v(_, x) {
      x.matcap && (_.matcap.value = x.matcap);
    }
    function b(_, x) {
      _.referencePosition.value.copy(x.referencePosition), _.nearDistance.value = x.nearDistance, _.farDistance.value = x.farDistance;
    }
    return {
      refreshFogUniforms: t,
      refreshMaterialUniforms: n
    };
  }
  function UM(l, e, t, n) {
    let i = {}, s = {}, r = [];
    const a = t.isWebGL2 ? l.getParameter(35375) : 0;
    function c(S, y) {
      const M = y.program;
      n.uniformBlockBinding(S, M);
    }
    function u(S, y) {
      let M = i[S.id];
      M === void 0 && (b(S), M = p(S), i[S.id] = M, S.addEventListener("dispose", x));
      const C = y.program;
      n.updateUBOMapping(S, C);
      const R = e.render.frame;
      s[S.id] !== R && (m(S), s[S.id] = R);
    }
    function p(S) {
      const y = f();
      S.__bindingPointIndex = y;
      const M = l.createBuffer(), C = S.__size, R = S.usage;
      return l.bindBuffer(35345, M), l.bufferData(35345, C, R), l.bindBuffer(35345, null), l.bindBufferBase(35345, y, M), M;
    }
    function f() {
      for (let S = 0; S < a; S++) if (r.indexOf(S) === -1) return r.push(S), S;
      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
    }
    function m(S) {
      const y = i[S.id], M = S.uniforms, C = S.__cache;
      l.bindBuffer(35345, y);
      for (let R = 0, k = M.length; R < k; R++) {
        const T = M[R];
        if (v(T, R, C) === true) {
          const L = T.__offset, F = Array.isArray(T.value) ? T.value : [
            T.value
          ];
          let j = 0;
          for (let Y = 0; Y < F.length; Y++) {
            const z = F[Y], B = _(z);
            typeof z == "number" ? (T.__data[0] = z, l.bufferSubData(35345, L + j, T.__data)) : z.isMatrix3 ? (T.__data[0] = z.elements[0], T.__data[1] = z.elements[1], T.__data[2] = z.elements[2], T.__data[3] = z.elements[0], T.__data[4] = z.elements[3], T.__data[5] = z.elements[4], T.__data[6] = z.elements[5], T.__data[7] = z.elements[0], T.__data[8] = z.elements[6], T.__data[9] = z.elements[7], T.__data[10] = z.elements[8], T.__data[11] = z.elements[0]) : (z.toArray(T.__data, j), j += B.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          l.bufferSubData(35345, L, T.__data);
        }
      }
      l.bindBuffer(35345, null);
    }
    function v(S, y, M) {
      const C = S.value;
      if (M[y] === void 0) {
        if (typeof C == "number") M[y] = C;
        else {
          const R = Array.isArray(C) ? C : [
            C
          ], k = [];
          for (let T = 0; T < R.length; T++) k.push(R[T].clone());
          M[y] = k;
        }
        return true;
      } else if (typeof C == "number") {
        if (M[y] !== C) return M[y] = C, true;
      } else {
        const R = Array.isArray(M[y]) ? M[y] : [
          M[y]
        ], k = Array.isArray(C) ? C : [
          C
        ];
        for (let T = 0; T < R.length; T++) {
          const L = R[T];
          if (L.equals(k[T]) === false) return L.copy(k[T]), true;
        }
      }
      return false;
    }
    function b(S) {
      const y = S.uniforms;
      let M = 0;
      const C = 16;
      let R = 0;
      for (let k = 0, T = y.length; k < T; k++) {
        const L = y[k], F = {
          boundary: 0,
          storage: 0
        }, j = Array.isArray(L.value) ? L.value : [
          L.value
        ];
        for (let Y = 0, z = j.length; Y < z; Y++) {
          const B = j[Y], Z = _(B);
          F.boundary += Z.boundary, F.storage += Z.storage;
        }
        if (L.__data = new Float32Array(F.storage / Float32Array.BYTES_PER_ELEMENT), L.__offset = M, k > 0) {
          R = M % C;
          const Y = C - R;
          R !== 0 && Y - F.boundary < 0 && (M += C - R, L.__offset = M);
        }
        M += F.storage;
      }
      return R = M % C, R > 0 && (M += C - R), S.__size = M, S.__cache = {}, this;
    }
    function _(S) {
      const y = {
        boundary: 0,
        storage: 0
      };
      return typeof S == "number" ? (y.boundary = 4, y.storage = 4) : S.isVector2 ? (y.boundary = 8, y.storage = 8) : S.isVector3 || S.isColor ? (y.boundary = 16, y.storage = 12) : S.isVector4 ? (y.boundary = 16, y.storage = 16) : S.isMatrix3 ? (y.boundary = 48, y.storage = 48) : S.isMatrix4 ? (y.boundary = 64, y.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), y;
    }
    function x(S) {
      const y = S.target;
      y.removeEventListener("dispose", x);
      const M = r.indexOf(y.__bindingPointIndex);
      r.splice(M, 1), l.deleteBuffer(i[y.id]), delete i[y.id], delete s[y.id];
    }
    function w() {
      for (const S in i) l.deleteBuffer(i[S]);
      r = [], i = {}, s = {};
    }
    return {
      bind: c,
      update: u,
      dispose: w
    };
  }
  function zM() {
    const l = so("canvas");
    return l.style.display = "block", l;
  }
  function Ih(l = {}) {
    this.isWebGLRenderer = true;
    const e = l.canvas !== void 0 ? l.canvas : zM(), t = l.context !== void 0 ? l.context : null, n = l.depth !== void 0 ? l.depth : true, i = l.stencil !== void 0 ? l.stencil : true, s = l.antialias !== void 0 ? l.antialias : false, r = l.premultipliedAlpha !== void 0 ? l.premultipliedAlpha : true, a = l.preserveDrawingBuffer !== void 0 ? l.preserveDrawingBuffer : false, c = l.powerPreference !== void 0 ? l.powerPreference : "default", u = l.failIfMajorPerformanceCaveat !== void 0 ? l.failIfMajorPerformanceCaveat : false;
    let p;
    t !== null ? p = t.getContextAttributes().alpha : p = l.alpha !== void 0 ? l.alpha : false;
    let f = null, m = null;
    const v = [], b = [];
    this.domElement = e, this.debug = {
      checkShaderErrors: true
    }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = Ai, this.physicallyCorrectLights = false, this.toneMapping = kn, this.toneMappingExposure = 1;
    const _ = this;
    let x = false, w = 0, S = 0, y = null, M = -1, C = null;
    const R = new ft(), k = new ft();
    let T = null, L = e.width, F = e.height, j = 1, Y = null, z = null;
    const B = new ft(0, 0, L, F), Z = new ft(0, 0, L, F);
    let ie = false;
    const re = new Qa();
    let W = false, pe = false, ae = null;
    const Te = new ze(), q = new te(), le = new P(), oe = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: true
    };
    function ce() {
      return y === null ? j : 1;
    }
    let K = t;
    function ke(I, X) {
      for (let Q = 0; Q < I.length; Q++) {
        const H = I[Q], ee = e.getContext(H, X);
        if (ee !== null) return ee;
      }
      return null;
    }
    try {
      const I = {
        alpha: true,
        depth: n,
        stencil: i,
        antialias: s,
        premultipliedAlpha: r,
        preserveDrawingBuffer: a,
        powerPreference: c,
        failIfMajorPerformanceCaveat: u
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${Xa}`), e.addEventListener("webglcontextlost", Ie, false), e.addEventListener("webglcontextrestored", Ae, false), e.addEventListener("webglcontextcreationerror", qe, false), K === null) {
        const X = [
          "webgl2",
          "webgl",
          "experimental-webgl"
        ];
        if (_.isWebGL1Renderer === true && X.shift(), K = ke(X, I), K === null) throw ke(X) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      K.getShaderPrecisionFormat === void 0 && (K.getShaderPrecisionFormat = function() {
        return {
          rangeMin: 1,
          rangeMax: 1,
          precision: 1
        };
      });
    } catch (I) {
      throw console.error("THREE.WebGLRenderer: " + I.message), I;
    }
    let Ce, Le, ve, Ve, se, ne, ge, Ee, fe, Fe, Ne, Re, dt, it, D, A, $, he, me, xe, Be, O, G, ye;
    function Me() {
      Ce = new nw(K), Le = new $y(K, Ce, l), Ce.init(Le), O = new om(K, Ce, Le), ve = new kM(K, Ce, Le), Ve = new rw(), se = new wM(), ne = new NM(K, Ce, ve, se, Le, O, Ve), ge = new Jy(_), Ee = new tw(_), fe = new fx(K, Le), G = new Ky(K, Ce, fe, Le), Fe = new iw(K, fe, Ve, G), Ne = new cw(K, Fe, fe, Ve), me = new lw(K, Le, ne), A = new Zy(se), Re = new yM(_, ge, Ee, Ce, Le, G, A), dt = new BM(_, se), it = new SM(), D = new LM(Ce, Le), he = new jy(_, ge, Ee, ve, Ne, p, r), $ = new DM(_, Ne, Le), ye = new UM(K, Ve, Le, ve), xe = new Yy(K, Ce, Ve, Le), Be = new sw(K, Ce, Ve, Le), Ve.programs = Re.programs, _.capabilities = Le, _.extensions = Ce, _.properties = se, _.renderLists = it, _.shadowMap = $, _.state = ve, _.info = Ve;
    }
    Me();
    const be = new FM(_, K);
    this.xr = be, this.getContext = function() {
      return K;
    }, this.getContextAttributes = function() {
      return K.getContextAttributes();
    }, this.forceContextLoss = function() {
      const I = Ce.get("WEBGL_lose_context");
      I && I.loseContext();
    }, this.forceContextRestore = function() {
      const I = Ce.get("WEBGL_lose_context");
      I && I.restoreContext();
    }, this.getPixelRatio = function() {
      return j;
    }, this.setPixelRatio = function(I) {
      I !== void 0 && (j = I, this.setSize(L, F, false));
    }, this.getSize = function(I) {
      return I.set(L, F);
    }, this.setSize = function(I, X, Q) {
      if (be.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      L = I, F = X, e.width = Math.floor(I * j), e.height = Math.floor(X * j), Q !== false && (e.style.width = I + "px", e.style.height = X + "px"), this.setViewport(0, 0, I, X);
    }, this.getDrawingBufferSize = function(I) {
      return I.set(L * j, F * j).floor();
    }, this.setDrawingBufferSize = function(I, X, Q) {
      L = I, F = X, j = Q, e.width = Math.floor(I * Q), e.height = Math.floor(X * Q), this.setViewport(0, 0, I, X);
    }, this.getCurrentViewport = function(I) {
      return I.copy(R);
    }, this.getViewport = function(I) {
      return I.copy(B);
    }, this.setViewport = function(I, X, Q, H) {
      I.isVector4 ? B.set(I.x, I.y, I.z, I.w) : B.set(I, X, Q, H), ve.viewport(R.copy(B).multiplyScalar(j).floor());
    }, this.getScissor = function(I) {
      return I.copy(Z);
    }, this.setScissor = function(I, X, Q, H) {
      I.isVector4 ? Z.set(I.x, I.y, I.z, I.w) : Z.set(I, X, Q, H), ve.scissor(k.copy(Z).multiplyScalar(j).floor());
    }, this.getScissorTest = function() {
      return ie;
    }, this.setScissorTest = function(I) {
      ve.setScissorTest(ie = I);
    }, this.setOpaqueSort = function(I) {
      Y = I;
    }, this.setTransparentSort = function(I) {
      z = I;
    }, this.getClearColor = function(I) {
      return I.copy(he.getClearColor());
    }, this.setClearColor = function() {
      he.setClearColor.apply(he, arguments);
    }, this.getClearAlpha = function() {
      return he.getClearAlpha();
    }, this.setClearAlpha = function() {
      he.setClearAlpha.apply(he, arguments);
    }, this.clear = function(I = true, X = true, Q = true) {
      let H = 0;
      I && (H |= 16384), X && (H |= 256), Q && (H |= 1024), K.clear(H);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Ie, false), e.removeEventListener("webglcontextrestored", Ae, false), e.removeEventListener("webglcontextcreationerror", qe, false), it.dispose(), D.dispose(), se.dispose(), ge.dispose(), Ee.dispose(), Ne.dispose(), G.dispose(), ye.dispose(), Re.dispose(), be.dispose(), be.removeEventListener("sessionstart", Se), be.removeEventListener("sessionend", De), ae && (ae.dispose(), ae = null), at.stop();
    };
    function Ie(I) {
      I.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = true;
    }
    function Ae() {
      console.log("THREE.WebGLRenderer: Context Restored."), x = false;
      const I = Ve.autoReset, X = $.enabled, Q = $.autoUpdate, H = $.needsUpdate, ee = $.type;
      Me(), Ve.autoReset = I, $.enabled = X, $.autoUpdate = Q, $.needsUpdate = H, $.type = ee;
    }
    function qe(I) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", I.statusMessage);
    }
    function je(I) {
      const X = I.target;
      X.removeEventListener("dispose", je), pt(X);
    }
    function pt(I) {
      U(I), se.remove(I);
    }
    function U(I) {
      const X = se.get(I).programs;
      X !== void 0 && (X.forEach(function(Q) {
        Re.releaseProgram(Q);
      }), I.isShaderMaterial && Re.releaseShaderCache(I));
    }
    this.renderBufferDirect = function(I, X, Q, H, ee, Oe) {
      X === null && (X = oe);
      const He = ee.isMesh && ee.matrixWorld.determinant() < 0, Ke = ki(I, X, Q, H, ee);
      ve.setMaterial(H, He);
      let $e = Q.index, Ze = 1;
      H.wireframe === true && ($e = Fe.getWireframeAttribute(Q), Ze = 2);
      const Je = Q.drawRange, et = Q.attributes.position;
      let vt = Je.start * Ze, Jt = (Je.start + Je.count) * Ze;
      Oe !== null && (vt = Math.max(vt, Oe.start * Ze), Jt = Math.min(Jt, (Oe.start + Oe.count) * Ze)), $e !== null ? (vt = Math.max(vt, 0), Jt = Math.min(Jt, $e.count)) : et != null && (vt = Math.max(vt, 0), Jt = Math.min(Jt, et.count));
      const jt = Jt - vt;
      if (jt < 0 || jt === 1 / 0) return;
      G.setup(ee, H, Ke, Q, $e);
      let Rn, bt = xe;
      if ($e !== null && (Rn = fe.get($e), bt = Be, bt.setIndex(Rn)), ee.isMesh) H.wireframe === true ? (ve.setLineWidth(H.wireframeLinewidth * ce()), bt.setMode(1)) : bt.setMode(4);
      else if (ee.isLine) {
        let tt = H.linewidth;
        tt === void 0 && (tt = 1), ve.setLineWidth(tt * ce()), ee.isLineSegments ? bt.setMode(1) : ee.isLineLoop ? bt.setMode(2) : bt.setMode(3);
      } else ee.isPoints ? bt.setMode(0) : ee.isSprite && bt.setMode(4);
      if (ee.isInstancedMesh) bt.renderInstances(vt, jt, ee.count);
      else if (Q.isInstancedBufferGeometry) {
        const tt = Q._maxInstanceCount !== void 0 ? Q._maxInstanceCount : 1 / 0, _s = Math.min(Q.instanceCount, tt);
        bt.renderInstances(vt, jt, _s);
      } else bt.render(vt, jt);
    }, this.compile = function(I, X) {
      function Q(H, ee, Oe) {
        H.transparent === true && H.side === Dn && H.forceSinglePass === false ? (H.side = on, H.needsUpdate = true, Tt(H, ee, Oe), H.side = On, H.needsUpdate = true, Tt(H, ee, Oe), H.side = Dn) : Tt(H, ee, Oe);
      }
      m = D.get(I), m.init(), b.push(m), I.traverseVisible(function(H) {
        H.isLight && H.layers.test(X.layers) && (m.pushLight(H), H.castShadow && m.pushShadow(H));
      }), m.setupLights(_.physicallyCorrectLights), I.traverse(function(H) {
        const ee = H.material;
        if (ee) if (Array.isArray(ee)) for (let Oe = 0; Oe < ee.length; Oe++) {
          const He = ee[Oe];
          Q(He, I, H);
        }
        else Q(ee, I, H);
      }), b.pop(), m = null;
    };
    let J = null;
    function ue(I) {
      J && J(I);
    }
    function Se() {
      at.stop();
    }
    function De() {
      at.start();
    }
    const at = new tm();
    at.setAnimationLoop(ue), typeof self < "u" && at.setContext(self), this.setAnimationLoop = function(I) {
      J = I, be.setAnimationLoop(I), I === null ? at.stop() : at.start();
    }, be.addEventListener("sessionstart", Se), be.addEventListener("sessionend", De), this.render = function(I, X) {
      if (X !== void 0 && X.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (x === true) return;
      I.matrixWorldAutoUpdate === true && I.updateMatrixWorld(), X.parent === null && X.matrixWorldAutoUpdate === true && X.updateMatrixWorld(), be.enabled === true && be.isPresenting === true && (be.cameraAutoUpdate === true && be.updateCamera(X), X = be.getCamera()), I.isScene === true && I.onBeforeRender(_, I, X, y), m = D.get(I, b.length), m.init(), b.push(m), Te.multiplyMatrices(X.projectionMatrix, X.matrixWorldInverse), re.setFromProjectionMatrix(Te), pe = this.localClippingEnabled, W = A.init(this.clippingPlanes, pe), f = it.get(I, v.length), f.init(), v.push(f), Lt(I, X, 0, _.sortObjects), f.finish(), _.sortObjects === true && f.sort(Y, z), W === true && A.beginShadows();
      const Q = m.state.shadowsArray;
      if ($.render(Q, I, X), W === true && A.endShadows(), this.info.autoReset === true && this.info.reset(), he.render(f, I), m.setupLights(_.physicallyCorrectLights), X.isArrayCamera) {
        const H = X.cameras;
        for (let ee = 0, Oe = H.length; ee < Oe; ee++) {
          const He = H[ee];
          Rt(f, I, He, He.viewport);
        }
      } else Rt(f, I, X);
      y !== null && (ne.updateMultisampleRenderTarget(y), ne.updateRenderTargetMipmap(y)), I.isScene === true && I.onAfterRender(_, I, X), G.resetDefaultState(), M = -1, C = null, b.pop(), b.length > 0 ? m = b[b.length - 1] : m = null, v.pop(), v.length > 0 ? f = v[v.length - 1] : f = null;
    };
    function Lt(I, X, Q, H) {
      if (I.visible === false) return;
      if (I.layers.test(X.layers)) {
        if (I.isGroup) Q = I.renderOrder;
        else if (I.isLOD) I.autoUpdate === true && I.update(X);
        else if (I.isLight) m.pushLight(I), I.castShadow && m.pushShadow(I);
        else if (I.isSprite) {
          if (!I.frustumCulled || re.intersectsSprite(I)) {
            H && le.setFromMatrixPosition(I.matrixWorld).applyMatrix4(Te);
            const He = Ne.update(I), Ke = I.material;
            Ke.visible && f.push(I, He, Ke, Q, le.z, null);
          }
        } else if ((I.isMesh || I.isLine || I.isPoints) && (I.isSkinnedMesh && I.skeleton.frame !== Ve.render.frame && (I.skeleton.update(), I.skeleton.frame = Ve.render.frame), !I.frustumCulled || re.intersectsObject(I))) {
          H && le.setFromMatrixPosition(I.matrixWorld).applyMatrix4(Te);
          const He = Ne.update(I), Ke = I.material;
          if (Array.isArray(Ke)) {
            const $e = He.groups;
            for (let Ze = 0, Je = $e.length; Ze < Je; Ze++) {
              const et = $e[Ze], vt = Ke[et.materialIndex];
              vt && vt.visible && f.push(I, He, vt, Q, le.z, et);
            }
          } else Ke.visible && f.push(I, He, Ke, Q, le.z, null);
        }
      }
      const Oe = I.children;
      for (let He = 0, Ke = Oe.length; He < Ke; He++) Lt(Oe[He], X, Q, H);
    }
    function Rt(I, X, Q, H) {
      const ee = I.opaque, Oe = I.transmissive, He = I.transparent;
      m.setupLightsView(Q), W === true && A.setGlobalState(_.clippingPlanes, Q), Oe.length > 0 && bn(ee, X, Q), H && ve.viewport(R.copy(H)), ee.length > 0 && nt(ee, X, Q), Oe.length > 0 && nt(Oe, X, Q), He.length > 0 && nt(He, X, Q), ve.buffers.depth.setTest(true), ve.buffers.depth.setMask(true), ve.buffers.color.setMask(true), ve.setPolygonOffset(false);
    }
    function bn(I, X, Q) {
      const H = Le.isWebGL2;
      ae === null && (ae = new Tn(1, 1, {
        generateMipmaps: true,
        type: Ce.has("EXT_color_buffer_half_float") ? tr : Ci,
        minFilter: Fn,
        samples: H && s === true ? 4 : 0
      })), _.getDrawingBufferSize(q), H ? ae.setSize(q.x, q.y) : ae.setSize(Wa(q.x), Wa(q.y));
      const ee = _.getRenderTarget();
      _.setRenderTarget(ae), _.clear();
      const Oe = _.toneMapping;
      _.toneMapping = kn, nt(I, X, Q), _.toneMapping = Oe, ne.updateMultisampleRenderTarget(ae), ne.updateRenderTargetMipmap(ae), _.setRenderTarget(ee);
    }
    function nt(I, X, Q) {
      const H = X.isScene === true ? X.overrideMaterial : null;
      for (let ee = 0, Oe = I.length; ee < Oe; ee++) {
        const He = I[ee], Ke = He.object, $e = He.geometry, Ze = H === null ? He.material : H, Je = He.group;
        Ke.layers.test(Q.layers) && an(Ke, X, Q, $e, Ze, Je);
      }
    }
    function an(I, X, Q, H, ee, Oe) {
      I.onBeforeRender(_, X, Q, H, ee, Oe), I.modelViewMatrix.multiplyMatrices(Q.matrixWorldInverse, I.matrixWorld), I.normalMatrix.getNormalMatrix(I.modelViewMatrix), ee.onBeforeRender(_, X, Q, H, I, Oe), ee.transparent === true && ee.side === Dn && ee.forceSinglePass === false ? (ee.side = on, ee.needsUpdate = true, _.renderBufferDirect(Q, X, H, ee, I, Oe), ee.side = On, ee.needsUpdate = true, _.renderBufferDirect(Q, X, H, ee, I, Oe), ee.side = Dn) : _.renderBufferDirect(Q, X, H, ee, I, Oe), I.onAfterRender(_, X, Q, H, ee, Oe);
    }
    function Tt(I, X, Q) {
      X.isScene !== true && (X = oe);
      const H = se.get(I), ee = m.state.lights, Oe = m.state.shadowsArray, He = ee.state.version, Ke = Re.getParameters(I, ee.state, Oe, X, Q), $e = Re.getProgramCacheKey(Ke);
      let Ze = H.programs;
      H.environment = I.isMeshStandardMaterial ? X.environment : null, H.fog = X.fog, H.envMap = (I.isMeshStandardMaterial ? Ee : ge).get(I.envMap || H.environment), Ze === void 0 && (I.addEventListener("dispose", je), Ze = /* @__PURE__ */ new Map(), H.programs = Ze);
      let Je = Ze.get($e);
      if (Je !== void 0) {
        if (H.currentProgram === Je && H.lightsStateVersion === He) return Io(I, Ke), Je;
      } else Ke.uniforms = Re.getUniforms(I), I.onBuild(Q, Ke, _), I.onBeforeCompile(Ke, _), Je = Re.acquireProgram(Ke, $e), Ze.set($e, Je), H.uniforms = Ke.uniforms;
      const et = H.uniforms;
      (!I.isShaderMaterial && !I.isRawShaderMaterial || I.clipping === true) && (et.clippingPlanes = A.uniform), Io(I, Ke), H.needsLights = vs(I), H.lightsStateVersion = He, H.needsLights && (et.ambientLightColor.value = ee.state.ambient, et.lightProbe.value = ee.state.probe, et.directionalLights.value = ee.state.directional, et.directionalLightShadows.value = ee.state.directionalShadow, et.spotLights.value = ee.state.spot, et.spotLightShadows.value = ee.state.spotShadow, et.rectAreaLights.value = ee.state.rectArea, et.ltc_1.value = ee.state.rectAreaLTC1, et.ltc_2.value = ee.state.rectAreaLTC2, et.pointLights.value = ee.state.point, et.pointLightShadows.value = ee.state.pointShadow, et.hemisphereLights.value = ee.state.hemi, et.directionalShadowMap.value = ee.state.directionalShadowMap, et.directionalShadowMatrix.value = ee.state.directionalShadowMatrix, et.spotShadowMap.value = ee.state.spotShadowMap, et.spotLightMatrix.value = ee.state.spotLightMatrix, et.spotLightMap.value = ee.state.spotLightMap, et.pointShadowMap.value = ee.state.pointShadowMap, et.pointShadowMatrix.value = ee.state.pointShadowMatrix);
      const vt = Je.getUniforms(), Jt = Ba.seqWithValue(vt.seq, et);
      return H.currentProgram = Je, H.uniformsList = Jt, Je;
    }
    function Io(I, X) {
      const Q = se.get(I);
      Q.outputEncoding = X.outputEncoding, Q.instancing = X.instancing, Q.skinning = X.skinning, Q.morphTargets = X.morphTargets, Q.morphNormals = X.morphNormals, Q.morphColors = X.morphColors, Q.morphTargetsCount = X.morphTargetsCount, Q.numClippingPlanes = X.numClippingPlanes, Q.numIntersection = X.numClipIntersection, Q.vertexAlphas = X.vertexAlphas, Q.vertexTangents = X.vertexTangents, Q.toneMapping = X.toneMapping;
    }
    function ki(I, X, Q, H, ee) {
      X.isScene !== true && (X = oe), ne.resetTextureUnits();
      const Oe = X.fog, He = H.isMeshStandardMaterial ? X.environment : null, Ke = y === null ? _.outputEncoding : y.isXRRenderTarget === true ? y.texture.encoding : Ai, $e = (H.isMeshStandardMaterial ? Ee : ge).get(H.envMap || He), Ze = H.vertexColors === true && !!Q.attributes.color && Q.attributes.color.itemSize === 4, Je = !!H.normalMap && !!Q.attributes.tangent, et = !!Q.morphAttributes.position, vt = !!Q.morphAttributes.normal, Jt = !!Q.morphAttributes.color, jt = H.toneMapped ? _.toneMapping : kn, Rn = Q.morphAttributes.position || Q.morphAttributes.normal || Q.morphAttributes.color, bt = Rn !== void 0 ? Rn.length : 0, tt = se.get(H), _s = m.state.lights;
      if (W === true && (pe === true || I !== C)) {
        const Qt = I === C && H.id === M;
        A.setState(H, I, Qt);
      }
      let It = false;
      H.version === tt.__version ? (tt.needsLights && tt.lightsStateVersion !== _s.state.version || tt.outputEncoding !== Ke || ee.isInstancedMesh && tt.instancing === false || !ee.isInstancedMesh && tt.instancing === true || ee.isSkinnedMesh && tt.skinning === false || !ee.isSkinnedMesh && tt.skinning === true || tt.envMap !== $e || H.fog === true && tt.fog !== Oe || tt.numClippingPlanes !== void 0 && (tt.numClippingPlanes !== A.numPlanes || tt.numIntersection !== A.numIntersection) || tt.vertexAlphas !== Ze || tt.vertexTangents !== Je || tt.morphTargets !== et || tt.morphNormals !== vt || tt.morphColors !== Jt || tt.toneMapping !== jt || Le.isWebGL2 === true && tt.morphTargetsCount !== bt) && (It = true) : (It = true, tt.__version = H.version);
      let ln = tt.currentProgram;
      It === true && (ln = Tt(H, X, ee));
      let ko = false, Ni = false, xs = false;
      const Gt = ln.getUniforms(), In = tt.uniforms;
      if (ve.useProgram(ln.program) && (ko = true, Ni = true, xs = true), H.id !== M && (M = H.id, Ni = true), ko || C !== I) {
        if (Gt.setValue(K, "projectionMatrix", I.projectionMatrix), Le.logarithmicDepthBuffer && Gt.setValue(K, "logDepthBufFC", 2 / (Math.log(I.far + 1) / Math.LN2)), C !== I && (C = I, Ni = true, xs = true), H.isShaderMaterial || H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshStandardMaterial || H.envMap) {
          const Qt = Gt.map.cameraPosition;
          Qt !== void 0 && Qt.setValue(K, le.setFromMatrixPosition(I.matrixWorld));
        }
        (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial) && Gt.setValue(K, "isOrthographic", I.isOrthographicCamera === true), (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial || H.isShadowMaterial || ee.isSkinnedMesh) && Gt.setValue(K, "viewMatrix", I.matrixWorldInverse);
      }
      if (ee.isSkinnedMesh) {
        Gt.setOptional(K, ee, "bindMatrix"), Gt.setOptional(K, ee, "bindMatrixInverse");
        const Qt = ee.skeleton;
        Qt && (Le.floatVertexTextures ? (Qt.boneTexture === null && Qt.computeBoneTexture(), Gt.setValue(K, "boneTexture", Qt.boneTexture, ne), Gt.setValue(K, "boneTextureSize", Qt.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const bs = Q.morphAttributes;
      if ((bs.position !== void 0 || bs.normal !== void 0 || bs.color !== void 0 && Le.isWebGL2 === true) && me.update(ee, Q, H, ln), (Ni || tt.receiveShadow !== ee.receiveShadow) && (tt.receiveShadow = ee.receiveShadow, Gt.setValue(K, "receiveShadow", ee.receiveShadow)), H.isMeshGouraudMaterial && H.envMap !== null && (In.envMap.value = $e, In.flipEnvMap.value = $e.isCubeTexture && $e.isRenderTargetTexture === false ? -1 : 1), Ni && (Gt.setValue(K, "toneMappingExposure", _.toneMappingExposure), tt.needsLights && Do(In, xs), Oe && H.fog === true && dt.refreshFogUniforms(In, Oe), dt.refreshMaterialUniforms(In, H, j, F, ae), Ba.upload(K, tt.uniformsList, In, ne)), H.isShaderMaterial && H.uniformsNeedUpdate === true && (Ba.upload(K, tt.uniformsList, In, ne), H.uniformsNeedUpdate = false), H.isSpriteMaterial && Gt.setValue(K, "center", ee.center), Gt.setValue(K, "modelViewMatrix", ee.modelViewMatrix), Gt.setValue(K, "normalMatrix", ee.normalMatrix), Gt.setValue(K, "modelMatrix", ee.matrixWorld), H.isShaderMaterial || H.isRawShaderMaterial) {
        const Qt = H.uniformsGroups;
        for (let Gn = 0, pl = Qt.length; Gn < pl; Gn++) if (Le.isWebGL2) {
          const _r = Qt[Gn];
          ye.update(_r, ln), ye.bind(_r, ln);
        } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return ln;
    }
    function Do(I, X) {
      I.ambientLightColor.needsUpdate = X, I.lightProbe.needsUpdate = X, I.directionalLights.needsUpdate = X, I.directionalLightShadows.needsUpdate = X, I.pointLights.needsUpdate = X, I.pointLightShadows.needsUpdate = X, I.spotLights.needsUpdate = X, I.spotLightShadows.needsUpdate = X, I.rectAreaLights.needsUpdate = X, I.hemisphereLights.needsUpdate = X;
    }
    function vs(I) {
      return I.isMeshLambertMaterial || I.isMeshToonMaterial || I.isMeshPhongMaterial || I.isMeshStandardMaterial || I.isShadowMaterial || I.isShaderMaterial && I.lights === true;
    }
    this.getActiveCubeFace = function() {
      return w;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return y;
    }, this.setRenderTargetTextures = function(I, X, Q) {
      se.get(I.texture).__webglTexture = X, se.get(I.depthTexture).__webglTexture = Q;
      const H = se.get(I);
      H.__hasExternalTextures = true, H.__hasExternalTextures && (H.__autoAllocateDepthBuffer = Q === void 0, H.__autoAllocateDepthBuffer || Ce.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), H.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(I, X) {
      const Q = se.get(I);
      Q.__webglFramebuffer = X, Q.__useDefaultFramebuffer = X === void 0;
    }, this.setRenderTarget = function(I, X = 0, Q = 0) {
      y = I, w = X, S = Q;
      let H = true, ee = null, Oe = false, He = false;
      if (I) {
        const $e = se.get(I);
        $e.__useDefaultFramebuffer !== void 0 ? (ve.bindFramebuffer(36160, null), H = false) : $e.__webglFramebuffer === void 0 ? ne.setupRenderTarget(I) : $e.__hasExternalTextures && ne.rebindTextures(I, se.get(I.texture).__webglTexture, se.get(I.depthTexture).__webglTexture);
        const Ze = I.texture;
        (Ze.isData3DTexture || Ze.isDataArrayTexture || Ze.isCompressedArrayTexture) && (He = true);
        const Je = se.get(I).__webglFramebuffer;
        I.isWebGLCubeRenderTarget ? (ee = Je[X], Oe = true) : Le.isWebGL2 && I.samples > 0 && ne.useMultisampledRTT(I) === false ? ee = se.get(I).__webglMultisampledFramebuffer : ee = Je, R.copy(I.viewport), k.copy(I.scissor), T = I.scissorTest;
      } else R.copy(B).multiplyScalar(j).floor(), k.copy(Z).multiplyScalar(j).floor(), T = ie;
      if (ve.bindFramebuffer(36160, ee) && Le.drawBuffers && H && ve.drawBuffers(I, ee), ve.viewport(R), ve.scissor(k), ve.setScissorTest(T), Oe) {
        const $e = se.get(I.texture);
        K.framebufferTexture2D(36160, 36064, 34069 + X, $e.__webglTexture, Q);
      } else if (He) {
        const $e = se.get(I.texture), Ze = X || 0;
        K.framebufferTextureLayer(36160, 36064, $e.__webglTexture, Q || 0, Ze);
      }
      M = -1;
    }, this.readRenderTargetPixels = function(I, X, Q, H, ee, Oe, He) {
      if (!(I && I.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ke = se.get(I).__webglFramebuffer;
      if (I.isWebGLCubeRenderTarget && He !== void 0 && (Ke = Ke[He]), Ke) {
        ve.bindFramebuffer(36160, Ke);
        try {
          const $e = I.texture, Ze = $e.format, Je = $e.type;
          if (Ze !== un && O.convert(Ze) !== K.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const et = Je === tr && (Ce.has("EXT_color_buffer_half_float") || Le.isWebGL2 && Ce.has("EXT_color_buffer_float"));
          if (Je !== Ci && O.convert(Je) !== K.getParameter(35738) && !(Je === ei && (Le.isWebGL2 || Ce.has("OES_texture_float") || Ce.has("WEBGL_color_buffer_float"))) && !et) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          X >= 0 && X <= I.width - H && Q >= 0 && Q <= I.height - ee && K.readPixels(X, Q, H, ee, O.convert(Ze), O.convert(Je), Oe);
        } finally {
          const $e = y !== null ? se.get(y).__webglFramebuffer : null;
          ve.bindFramebuffer(36160, $e);
        }
      }
    }, this.copyFramebufferToTexture = function(I, X, Q = 0) {
      const H = Math.pow(2, -Q), ee = Math.floor(X.image.width * H), Oe = Math.floor(X.image.height * H);
      ne.setTexture2D(X, 0), K.copyTexSubImage2D(3553, Q, 0, 0, I.x, I.y, ee, Oe), ve.unbindTexture();
    }, this.copyTextureToTexture = function(I, X, Q, H = 0) {
      const ee = X.image.width, Oe = X.image.height, He = O.convert(Q.format), Ke = O.convert(Q.type);
      ne.setTexture2D(Q, 0), K.pixelStorei(37440, Q.flipY), K.pixelStorei(37441, Q.premultiplyAlpha), K.pixelStorei(3317, Q.unpackAlignment), X.isDataTexture ? K.texSubImage2D(3553, H, I.x, I.y, ee, Oe, He, Ke, X.image.data) : X.isCompressedTexture ? K.compressedTexSubImage2D(3553, H, I.x, I.y, X.mipmaps[0].width, X.mipmaps[0].height, He, X.mipmaps[0].data) : K.texSubImage2D(3553, H, I.x, I.y, He, Ke, X.image), H === 0 && Q.generateMipmaps && K.generateMipmap(3553), ve.unbindTexture();
    }, this.copyTextureToTexture3D = function(I, X, Q, H, ee = 0) {
      if (_.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Oe = I.max.x - I.min.x + 1, He = I.max.y - I.min.y + 1, Ke = I.max.z - I.min.z + 1, $e = O.convert(H.format), Ze = O.convert(H.type);
      let Je;
      if (H.isData3DTexture) ne.setTexture3D(H, 0), Je = 32879;
      else if (H.isDataArrayTexture) ne.setTexture2DArray(H, 0), Je = 35866;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      K.pixelStorei(37440, H.flipY), K.pixelStorei(37441, H.premultiplyAlpha), K.pixelStorei(3317, H.unpackAlignment);
      const et = K.getParameter(3314), vt = K.getParameter(32878), Jt = K.getParameter(3316), jt = K.getParameter(3315), Rn = K.getParameter(32877), bt = Q.isCompressedTexture ? Q.mipmaps[0] : Q.image;
      K.pixelStorei(3314, bt.width), K.pixelStorei(32878, bt.height), K.pixelStorei(3316, I.min.x), K.pixelStorei(3315, I.min.y), K.pixelStorei(32877, I.min.z), Q.isDataTexture || Q.isData3DTexture ? K.texSubImage3D(Je, ee, X.x, X.y, X.z, Oe, He, Ke, $e, Ze, bt.data) : Q.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), K.compressedTexSubImage3D(Je, ee, X.x, X.y, X.z, Oe, He, Ke, $e, bt.data)) : K.texSubImage3D(Je, ee, X.x, X.y, X.z, Oe, He, Ke, $e, Ze, bt), K.pixelStorei(3314, et), K.pixelStorei(32878, vt), K.pixelStorei(3316, Jt), K.pixelStorei(3315, jt), K.pixelStorei(32877, Rn), ee === 0 && H.generateMipmaps && K.generateMipmap(Je), ve.unbindTexture();
    }, this.initTexture = function(I) {
      I.isCubeTexture ? ne.setTextureCube(I, 0) : I.isData3DTexture ? ne.setTexture3D(I, 0) : I.isDataArrayTexture || I.isCompressedArrayTexture ? ne.setTexture2DArray(I, 0) : ne.setTexture2D(I, 0), ve.unbindTexture();
    }, this.resetState = function() {
      w = 0, S = 0, y = null, ve.reset(), G.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
      detail: this
    }));
  }
  class cm extends Ih {
  }
  cm.prototype.isWebGL1Renderer = true;
  class tl {
    constructor(e, t = 25e-5) {
      this.isFogExp2 = true, this.name = "", this.color = new we(e), this.density = t;
    }
    clone() {
      return new tl(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  }
  class nl {
    constructor(e, t = 1, n = 1e3) {
      this.isFog = true, this.name = "", this.color = new we(e), this.near = t, this.far = n;
    }
    clone() {
      return new nl(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  }
  class Dh extends rt {
    constructor() {
      super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }));
    }
    copy(e, t) {
      return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
    }
    get autoUpdate() {
      return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate;
    }
    set autoUpdate(e) {
      console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e;
    }
  }
  class _o {
    constructor(e, t) {
      this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = no, this.updateRange = {
        offset: 0,
        count: -1
      }, this.version = 0, this.uuid = dn();
    }
    onUploadCallback() {
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    copy(e) {
      return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
    }
    copyAt(e, t, n) {
      e *= this.stride, n *= t.stride;
      for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = t.array[n + i];
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = dn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(e) {
      return this.onUploadCallback = e, this;
    }
    toJSON(e) {
      return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = dn()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  }
  const en = new P();
  class Pi {
    constructor(e, t, n, i = false) {
      this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, n = this.data.count; t < n; t++) en.fromBufferAttribute(this, t), en.applyMatrix4(e), this.setXYZ(t, en.x, en.y, en.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, n = this.count; t < n; t++) en.fromBufferAttribute(this, t), en.applyNormalMatrix(e), this.setXYZ(t, en.x, en.y, en.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, n = this.count; t < n; t++) en.fromBufferAttribute(this, t), en.transformDirection(e), this.setXYZ(t, en.x, en.y, en.z);
      return this;
    }
    setX(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
    }
    setY(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
    }
    setZ(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
    }
    setW(e, t) {
      return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
    }
    getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = ti(t, this.array)), t;
    }
    setXY(e, t, n) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), n = mt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
    }
    setXYZ(e, t, n, i) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), n = mt(n, this.array), i = mt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
    }
    setXYZW(e, t, n, i, s) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), n = mt(n, this.array), i = mt(i, this.array), s = mt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this;
    }
    clone(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
        }
        return new ht(new this.array.constructor(t), this.itemSize, this.normalized);
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Pi(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(e) {
      if (e === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
        const t = [];
        for (let n = 0; n < this.count; n++) {
          const i = n * this.data.stride + this.offset;
          for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized
        };
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
  class kh extends Bt {
    constructor(e) {
      super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new we(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
  }
  let Gs;
  const Ur = new P(), Hs = new P(), Ws = new P(), qs = new te(), zr = new te(), hm = new ze(), ca = new P(), Vr = new P(), ha = new P(), Xd = new te(), cc = new te(), jd = new te();
  class um extends rt {
    constructor(e) {
      if (super(), this.isSprite = true, this.type = "Sprite", Gs === void 0) {
        Gs = new Xe();
        const t = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]), n = new _o(t, 5);
        Gs.setIndex([
          0,
          1,
          2,
          0,
          2,
          3
        ]), Gs.setAttribute("position", new Pi(n, 3, 0, false)), Gs.setAttribute("uv", new Pi(n, 2, 3, false));
      }
      this.geometry = Gs, this.material = e !== void 0 ? e : new kh(), this.center = new te(0.5, 0.5);
    }
    raycast(e, t) {
      e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Hs.setFromMatrixScale(this.matrixWorld), hm.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ws.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && Hs.multiplyScalar(-Ws.z);
      const n = this.material.rotation;
      let i, s;
      n !== 0 && (s = Math.cos(n), i = Math.sin(n));
      const r = this.center;
      ua(ca.set(-0.5, -0.5, 0), Ws, r, Hs, i, s), ua(Vr.set(0.5, -0.5, 0), Ws, r, Hs, i, s), ua(ha.set(0.5, 0.5, 0), Ws, r, Hs, i, s), Xd.set(0, 0), cc.set(1, 0), jd.set(1, 1);
      let a = e.ray.intersectTriangle(ca, Vr, ha, false, Ur);
      if (a === null && (ua(Vr.set(-0.5, 0.5, 0), Ws, r, Hs, i, s), cc.set(0, 1), a = e.ray.intersectTriangle(ca, ha, Vr, false, Ur), a === null)) return;
      const c = e.ray.origin.distanceTo(Ur);
      c < e.near || c > e.far || t.push({
        distance: c,
        point: Ur.clone(),
        uv: xn.getUV(Ur, ca, Vr, ha, Xd, cc, jd, new te()),
        face: null,
        object: this
      });
    }
    copy(e, t) {
      return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
    }
  }
  function ua(l, e, t, n, i, s) {
    qs.subVectors(l, t).addScalar(0.5).multiply(n), i !== void 0 ? (zr.x = s * qs.x - i * qs.y, zr.y = i * qs.x + s * qs.y) : zr.copy(qs), l.copy(e), l.x += zr.x, l.y += zr.y, l.applyMatrix4(hm);
  }
  const da = new P(), Kd = new P();
  class dm extends rt {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
        levels: {
          enumerable: true,
          value: []
        },
        isLOD: {
          value: true
        }
      }), this.autoUpdate = true;
    }
    copy(e) {
      super.copy(e, false);
      const t = e.levels;
      for (let n = 0, i = t.length; n < i; n++) {
        const s = t[n];
        this.addLevel(s.object.clone(), s.distance, s.hysteresis);
      }
      return this.autoUpdate = e.autoUpdate, this;
    }
    addLevel(e, t = 0, n = 0) {
      t = Math.abs(t);
      const i = this.levels;
      let s;
      for (s = 0; s < i.length && !(t < i[s].distance); s++) ;
      return i.splice(s, 0, {
        distance: t,
        hysteresis: n,
        object: e
      }), this.add(e), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(e) {
      const t = this.levels;
      if (t.length > 0) {
        let n, i;
        for (n = 1, i = t.length; n < i; n++) {
          let s = t[n].distance;
          if (t[n].object.visible && (s -= s * t[n].hysteresis), e < s) break;
        }
        return t[n - 1].object;
      }
      return null;
    }
    raycast(e, t) {
      if (this.levels.length > 0) {
        da.setFromMatrixPosition(this.matrixWorld);
        const i = e.ray.origin.distanceTo(da);
        this.getObjectForDistance(i).raycast(e, t);
      }
    }
    update(e) {
      const t = this.levels;
      if (t.length > 1) {
        da.setFromMatrixPosition(e.matrixWorld), Kd.setFromMatrixPosition(this.matrixWorld);
        const n = da.distanceTo(Kd) / e.zoom;
        t[0].object.visible = true;
        let i, s;
        for (i = 1, s = t.length; i < s; i++) {
          let r = t[i].distance;
          if (t[i].object.visible && (r -= r * t[i].hysteresis), n >= r) t[i - 1].object.visible = false, t[i].object.visible = true;
          else break;
        }
        for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = false;
      }
    }
    toJSON(e) {
      const t = super.toJSON(e);
      this.autoUpdate === false && (t.object.autoUpdate = false), t.object.levels = [];
      const n = this.levels;
      for (let i = 0, s = n.length; i < s; i++) {
        const r = n[i];
        t.object.levels.push({
          object: r.object.uuid,
          distance: r.distance,
          hysteresis: r.hysteresis
        });
      }
      return t;
    }
  }
  const Yd = new P(), $d = new ft(), Zd = new ft(), VM = new P(), Jd = new ze();
  class Nh extends kt {
    constructor(e, t) {
      super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ze(), this.bindMatrixInverse = new ze();
    }
    copy(e, t) {
      return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
    }
    bind(e, t) {
      this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e = new ft(), t = this.geometry.attributes.skinWeight;
      for (let n = 0, i = t.count; n < i; n++) {
        e.fromBufferAttribute(t, n);
        const s = 1 / e.manhattanLength();
        s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(e, t) {
      const n = this.skeleton, i = this.geometry;
      $d.fromBufferAttribute(i.attributes.skinIndex, e), Zd.fromBufferAttribute(i.attributes.skinWeight, e), Yd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
      for (let s = 0; s < 4; s++) {
        const r = Zd.getComponent(s);
        if (r !== 0) {
          const a = $d.getComponent(s);
          Jd.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(VM.copy(Yd).applyMatrix4(Jd), r);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
  }
  class il extends rt {
    constructor() {
      super(), this.isBone = true, this.type = "Bone";
    }
  }
  class Js extends Mt {
    constructor(e = null, t = 1, n = 1, i, s, r, a, c, u = Et, p = Et, f, m) {
      super(null, r, a, c, u, p, i, s, f, m), this.isDataTexture = true, this.image = {
        data: e,
        width: t,
        height: n
      }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
    }
  }
  const Qd = new ze(), GM = new ze();
  class xo {
    constructor(e = [], t = []) {
      this.uuid = dn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      const e = this.bones, t = this.boneInverses;
      if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new ze());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = new ze();
        this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && n.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const n = this.bones[e];
        n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
      }
    }
    update() {
      const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
      for (let s = 0, r = e.length; s < r; s++) {
        const a = e[s] ? e[s].matrixWorld : GM;
        Qd.multiplyMatrices(a, t[s]), Qd.toArray(n, s * 16);
      }
      i !== null && (i.needsUpdate = true);
    }
    clone() {
      return new xo(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      e = jf(e), e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      const n = new Js(t, e, e, un, ei);
      return n.needsUpdate = true, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this;
    }
    getBoneByName(e) {
      for (let t = 0, n = this.bones.length; t < n; t++) {
        const i = this.bones[t];
        if (i.name === e) return i;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let n = 0, i = e.bones.length; n < i; n++) {
        const s = e.bones[n];
        let r = t[s];
        r === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), r = new il()), this.bones.push(r), this.boneInverses.push(new ze().fromArray(e.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      e.uuid = this.uuid;
      const t = this.bones, n = this.boneInverses;
      for (let i = 0, s = t.length; i < s; i++) {
        const r = t[i];
        e.bones.push(r.uuid);
        const a = n[i];
        e.boneInverses.push(a.toArray());
      }
      return e;
    }
  }
  class rr extends ht {
    constructor(e, t, n, i = 1) {
      super(e, t, n), this.isInstancedBufferAttribute = true, this.meshPerAttribute = i;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
    }
  }
  const ep = new ze(), tp = new ze(), pa = [], HM = new ze(), Gr = new kt();
  class Oh extends kt {
    constructor(e, t, n) {
      super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new rr(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = false;
      for (let i = 0; i < n; i++) this.setMatrixAt(i, HM);
    }
    copy(e, t) {
      return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16);
    }
    raycast(e, t) {
      const n = this.matrixWorld, i = this.count;
      if (Gr.geometry = this.geometry, Gr.material = this.material, Gr.material !== void 0) for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, ep), tp.multiplyMatrices(n, ep), Gr.matrixWorld = tp, Gr.raycast(e, pa);
        for (let r = 0, a = pa.length; r < a; r++) {
          const c = pa[r];
          c.instanceId = s, c.object = this, t.push(c);
        }
        pa.length = 0;
      }
    }
    setColorAt(e, t) {
      this.instanceColor === null && (this.instanceColor = new rr(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({
        type: "dispose"
      });
    }
  }
  class Zt extends Bt {
    constructor(e) {
      super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new we(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
    }
  }
  const np = new P(), ip = new P(), sp = new ze(), hc = new fo(), fa = new Ii();
  class si extends rt {
    constructor(e = new Xe(), t = new Zt()) {
      super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [
          0
        ];
        for (let i = 1, s = t.count; i < s; i++) np.fromBufferAttribute(t, i - 1), ip.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += np.distanceTo(ip);
        e.setAttribute("lineDistance", new Pe(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, s = e.params.Line.threshold, r = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), fa.copy(n.boundingSphere), fa.applyMatrix4(i), fa.radius += s, e.ray.intersectsSphere(fa) === false) return;
      sp.copy(i).invert(), hc.copy(e.ray).applyMatrix4(sp);
      const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = a * a, u = new P(), p = new P(), f = new P(), m = new P(), v = this.isLineSegments ? 2 : 1, b = n.index, x = n.attributes.position;
      if (b !== null) {
        const w = Math.max(0, r.start), S = Math.min(b.count, r.start + r.count);
        for (let y = w, M = S - 1; y < M; y += v) {
          const C = b.getX(y), R = b.getX(y + 1);
          if (u.fromBufferAttribute(x, C), p.fromBufferAttribute(x, R), hc.distanceSqToSegment(u, p, m, f) > c) continue;
          m.applyMatrix4(this.matrixWorld);
          const T = e.ray.origin.distanceTo(m);
          T < e.near || T > e.far || t.push({
            distance: T,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const w = Math.max(0, r.start), S = Math.min(x.count, r.start + r.count);
        for (let y = w, M = S - 1; y < M; y += v) {
          if (u.fromBufferAttribute(x, y), p.fromBufferAttribute(x, y + 1), hc.distanceSqToSegment(u, p, m, f) > c) continue;
          m.applyMatrix4(this.matrixWorld);
          const R = e.ray.origin.distanceTo(m);
          R < e.near || R > e.far || t.push({
            distance: R,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: y,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, r = i.length; s < r; s++) {
            const a = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
  }
  const rp = new P(), op = new P();
  class Cn extends si {
    constructor(e, t) {
      super(e, t), this.isLineSegments = true, this.type = "LineSegments";
    }
    computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
        const t = e.attributes.position, n = [];
        for (let i = 0, s = t.count; i < s; i += 2) rp.fromBufferAttribute(t, i), op.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + rp.distanceTo(op);
        e.setAttribute("lineDistance", new Pe(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this;
    }
  }
  class Fh extends si {
    constructor(e, t) {
      super(e, t), this.isLineLoop = true, this.type = "LineLoop";
    }
  }
  class sl extends Bt {
    constructor(e) {
      super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new we(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
    }
  }
  const ap = new ze(), oh = new fo(), ma = new Ii(), ga = new P();
  class Bh extends rt {
    constructor(e = new Xe(), t = new sl()) {
      super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
    }
    copy(e, t) {
      return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
    }
    raycast(e, t) {
      const n = this.geometry, i = this.matrixWorld, s = e.params.Points.threshold, r = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), ma.copy(n.boundingSphere), ma.applyMatrix4(i), ma.radius += s, e.ray.intersectsSphere(ma) === false) return;
      ap.copy(i).invert(), oh.copy(e.ray).applyMatrix4(ap);
      const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = a * a, u = n.index, f = n.attributes.position;
      if (u !== null) {
        const m = Math.max(0, r.start), v = Math.min(u.count, r.start + r.count);
        for (let b = m, _ = v; b < _; b++) {
          const x = u.getX(b);
          ga.fromBufferAttribute(f, x), lp(ga, x, c, i, e, t, this);
        }
      } else {
        const m = Math.max(0, r.start), v = Math.min(f.count, r.start + r.count);
        for (let b = m, _ = v; b < _; b++) ga.fromBufferAttribute(f, b), lp(ga, b, c, i, e, t, this);
      }
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes, n = Object.keys(t);
      if (n.length > 0) {
        const i = t[n[0]];
        if (i !== void 0) {
          this.morphTargetInfluences = [], this.morphTargetDictionary = {};
          for (let s = 0, r = i.length; s < r; s++) {
            const a = i[s].name || String(s);
            this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
          }
        }
      }
    }
  }
  function lp(l, e, t, n, i, s, r) {
    const a = oh.distanceSqToPoint(l);
    if (a < t) {
      const c = new P();
      oh.closestPointToPoint(l, c), c.applyMatrix4(n);
      const u = i.ray.origin.distanceTo(c);
      if (u < i.near || u > i.far) return;
      s.push({
        distance: u,
        distanceToRay: Math.sqrt(a),
        point: c,
        index: e,
        face: null,
        object: r
      });
    }
  }
  class WM extends Mt {
    constructor(e, t, n, i, s, r, a, c, u) {
      super(e, t, n, i, s, r, a, c, u), this.isVideoTexture = true, this.minFilter = r !== void 0 ? r : yt, this.magFilter = s !== void 0 ? s : yt, this.generateMipmaps = false;
      const p = this;
      function f() {
        p.needsUpdate = true, e.requestVideoFrameCallback(f);
      }
      "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f);
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const e = this.image;
      "requestVideoFrameCallback" in e === false && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  }
  class qM extends Mt {
    constructor(e, t, n) {
      super({
        width: e,
        height: t
      }), this.isFramebufferTexture = true, this.format = n, this.magFilter = Et, this.minFilter = Et, this.generateMipmaps = false, this.needsUpdate = true;
    }
  }
  class Uh extends Mt {
    constructor(e, t, n, i, s, r, a, c, u, p, f, m) {
      super(null, r, a, c, u, p, i, s, f, m), this.isCompressedTexture = true, this.image = {
        width: t,
        height: n
      }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
    }
  }
  class XM extends Uh {
    constructor(e, t, n, i, s, r) {
      super(e, t, n, s, r), this.isCompressedArrayTexture = true, this.image.depth = i, this.wrapR = Xt;
    }
  }
  class jM extends Mt {
    constructor(e, t, n, i, s, r, a, c, u) {
      super(e, t, n, i, s, r, a, c, u), this.isCanvasTexture = true, this.needsUpdate = true;
    }
  }
  class An {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getPoint(n, t);
    }
    getPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return t;
    }
    getSpacedPoints(e = 5) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
      return t;
    }
    getLength() {
      const e = this.getLengths();
      return e[e.length - 1];
    }
    getLengths(e = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = false;
      const t = [];
      let n, i = this.getPoint(0), s = 0;
      t.push(0);
      for (let r = 1; r <= e; r++) n = this.getPoint(r / e), s += n.distanceTo(i), t.push(s), i = n;
      return this.cacheArcLengths = t, t;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(e, t) {
      const n = this.getLengths();
      let i = 0;
      const s = n.length;
      let r;
      t ? r = t : r = e * n[s - 1];
      let a = 0, c = s - 1, u;
      for (; a <= c; ) if (i = Math.floor(a + (c - a) / 2), u = n[i] - r, u < 0) a = i + 1;
      else if (u > 0) c = i - 1;
      else {
        c = i;
        break;
      }
      if (i = c, n[i] === r) return i / (s - 1);
      const p = n[i], m = n[i + 1] - p, v = (r - p) / m;
      return (i + v) / (s - 1);
    }
    getTangent(e, t) {
      let i = e - 1e-4, s = e + 1e-4;
      i < 0 && (i = 0), s > 1 && (s = 1);
      const r = this.getPoint(i), a = this.getPoint(s), c = t || (r.isVector2 ? new te() : new P());
      return c.copy(a).sub(r).normalize(), c;
    }
    getTangentAt(e, t) {
      const n = this.getUtoTmapping(e);
      return this.getTangent(n, t);
    }
    computeFrenetFrames(e, t) {
      const n = new P(), i = [], s = [], r = [], a = new P(), c = new ze();
      for (let v = 0; v <= e; v++) {
        const b = v / e;
        i[v] = this.getTangentAt(b, new P());
      }
      s[0] = new P(), r[0] = new P();
      let u = Number.MAX_VALUE;
      const p = Math.abs(i[0].x), f = Math.abs(i[0].y), m = Math.abs(i[0].z);
      p <= u && (u = p, n.set(1, 0, 0)), f <= u && (u = f, n.set(0, 1, 0)), m <= u && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), s[0].crossVectors(i[0], a), r[0].crossVectors(i[0], s[0]);
      for (let v = 1; v <= e; v++) {
        if (s[v] = s[v - 1].clone(), r[v] = r[v - 1].clone(), a.crossVectors(i[v - 1], i[v]), a.length() > Number.EPSILON) {
          a.normalize();
          const b = Math.acos(At(i[v - 1].dot(i[v]), -1, 1));
          s[v].applyMatrix4(c.makeRotationAxis(a, b));
        }
        r[v].crossVectors(i[v], s[v]);
      }
      if (t === true) {
        let v = Math.acos(At(s[0].dot(s[e]), -1, 1));
        v /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (v = -v);
        for (let b = 1; b <= e; b++) s[b].applyMatrix4(c.makeRotationAxis(i[b], v * b)), r[b].crossVectors(i[b], s[b]);
      }
      return {
        tangents: i,
        normals: s,
        binormals: r
      };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
    }
    fromJSON(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this;
    }
  }
  class rl extends An {
    constructor(e = 0, t = 0, n = 1, i = 1, s = 0, r = Math.PI * 2, a = false, c = 0) {
      super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = r, this.aClockwise = a, this.aRotation = c;
    }
    getPoint(e, t) {
      const n = t || new te(), i = Math.PI * 2;
      let s = this.aEndAngle - this.aStartAngle;
      const r = Math.abs(s) < Number.EPSILON;
      for (; s < 0; ) s += i;
      for (; s > i; ) s -= i;
      s < Number.EPSILON && (r ? s = 0 : s = i), this.aClockwise === true && !r && (s === i ? s = -i : s = s - i);
      const a = this.aStartAngle + e * s;
      let c = this.aX + this.xRadius * Math.cos(a), u = this.aY + this.yRadius * Math.sin(a);
      if (this.aRotation !== 0) {
        const p = Math.cos(this.aRotation), f = Math.sin(this.aRotation), m = c - this.aX, v = u - this.aY;
        c = m * p - v * f + this.aX, u = m * f + v * p + this.aY;
      }
      return n.set(c, u);
    }
    copy(e) {
      return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
    }
  }
  class pm extends rl {
    constructor(e, t, n, i, s, r) {
      super(e, t, n, n, i, s, r), this.isArcCurve = true, this.type = "ArcCurve";
    }
  }
  function zh() {
    let l = 0, e = 0, t = 0, n = 0;
    function i(s, r, a, c) {
      l = s, e = a, t = -3 * s + 3 * r - 2 * a - c, n = 2 * s - 2 * r + a + c;
    }
    return {
      initCatmullRom: function(s, r, a, c, u) {
        i(r, a, u * (a - s), u * (c - r));
      },
      initNonuniformCatmullRom: function(s, r, a, c, u, p, f) {
        let m = (r - s) / u - (a - s) / (u + p) + (a - r) / p, v = (a - r) / p - (c - r) / (p + f) + (c - a) / f;
        m *= p, v *= p, i(r, a, m, v);
      },
      calc: function(s) {
        const r = s * s, a = r * s;
        return l + e * s + t * r + n * a;
      }
    };
  }
  const va = new P(), uc = new zh(), dc = new zh(), pc = new zh();
  class fm extends An {
    constructor(e = [], t = false, n = "centripetal", i = 0.5) {
      super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.points, s = i.length, r = (s - (this.closed ? 0 : 1)) * e;
      let a = Math.floor(r), c = r - a;
      this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : c === 0 && a === s - 1 && (a = s - 2, c = 1);
      let u, p;
      this.closed || a > 0 ? u = i[(a - 1) % s] : (va.subVectors(i[0], i[1]).add(i[0]), u = va);
      const f = i[a % s], m = i[(a + 1) % s];
      if (this.closed || a + 2 < s ? p = i[(a + 2) % s] : (va.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), p = va), this.curveType === "centripetal" || this.curveType === "chordal") {
        const v = this.curveType === "chordal" ? 0.5 : 0.25;
        let b = Math.pow(u.distanceToSquared(f), v), _ = Math.pow(f.distanceToSquared(m), v), x = Math.pow(m.distanceToSquared(p), v);
        _ < 1e-4 && (_ = 1), b < 1e-4 && (b = _), x < 1e-4 && (x = _), uc.initNonuniformCatmullRom(u.x, f.x, m.x, p.x, b, _, x), dc.initNonuniformCatmullRom(u.y, f.y, m.y, p.y, b, _, x), pc.initNonuniformCatmullRom(u.z, f.z, m.z, p.z, b, _, x);
      } else this.curveType === "catmullrom" && (uc.initCatmullRom(u.x, f.x, m.x, p.x, this.tension), dc.initCatmullRom(u.y, f.y, m.y, p.y, this.tension), pc.initCatmullRom(u.z, f.z, m.z, p.z, this.tension));
      return n.set(uc.calc(c), dc.calc(c), pc.calc(c)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new P().fromArray(i));
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
    }
  }
  function cp(l, e, t, n, i) {
    const s = (n - e) * 0.5, r = (i - t) * 0.5, a = l * l, c = l * a;
    return (2 * t - 2 * n + s + r) * c + (-3 * t + 3 * n - 2 * s - r) * a + s * l + t;
  }
  function KM(l, e) {
    const t = 1 - l;
    return t * t * e;
  }
  function YM(l, e) {
    return 2 * (1 - l) * l * e;
  }
  function $M(l, e) {
    return l * l * e;
  }
  function $r(l, e, t, n) {
    return KM(l, e) + YM(l, t) + $M(l, n);
  }
  function ZM(l, e) {
    const t = 1 - l;
    return t * t * t * e;
  }
  function JM(l, e) {
    const t = 1 - l;
    return 3 * t * t * l * e;
  }
  function QM(l, e) {
    return 3 * (1 - l) * l * l * e;
  }
  function eS(l, e) {
    return l * l * l * e;
  }
  function Zr(l, e, t, n, i) {
    return ZM(l, e) + JM(l, t) + QM(l, n) + eS(l, i);
  }
  class Vh extends An {
    constructor(e = new te(), t = new te(), n = new te(), i = new te()) {
      super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new te()) {
      const n = t, i = this.v0, s = this.v1, r = this.v2, a = this.v3;
      return n.set(Zr(e, i.x, s.x, r.x, a.x), Zr(e, i.y, s.y, r.y, a.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class mm extends An {
    constructor(e = new P(), t = new P(), n = new P(), i = new P()) {
      super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.v0, s = this.v1, r = this.v2, a = this.v3;
      return n.set(Zr(e, i.x, s.x, r.x, a.x), Zr(e, i.y, s.y, r.y, a.y), Zr(e, i.z, s.z, r.z, a.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
    }
  }
  class ol extends An {
    constructor(e = new te(), t = new te()) {
      super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new te()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    getTangent(e, t) {
      const n = t || new te();
      return n.copy(this.v2).sub(this.v1).normalize(), n;
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class gm extends An {
    constructor(e = new P(), t = new P()) {
      super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
    }
    getPoint(e, t = new P()) {
      const n = t;
      return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
    }
    getPointAt(e, t) {
      return this.getPoint(e, t);
    }
    copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Gh extends An {
    constructor(e = new te(), t = new te(), n = new te()) {
      super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new te()) {
      const n = t, i = this.v0, s = this.v1, r = this.v2;
      return n.set($r(e, i.x, s.x, r.x), $r(e, i.y, s.y, r.y)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Hh extends An {
    constructor(e = new P(), t = new P(), n = new P()) {
      super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
    }
    getPoint(e, t = new P()) {
      const n = t, i = this.v0, s = this.v1, r = this.v2;
      return n.set($r(e, i.x, s.x, r.x), $r(e, i.y, s.y, r.y), $r(e, i.z, s.z, r.z)), n;
    }
    copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
    }
  }
  class Wh extends An {
    constructor(e = []) {
      super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
    }
    getPoint(e, t = new te()) {
      const n = t, i = this.points, s = (i.length - 1) * e, r = Math.floor(s), a = s - r, c = i[r === 0 ? r : r - 1], u = i[r], p = i[r > i.length - 2 ? i.length - 1 : r + 1], f = i[r > i.length - 3 ? i.length - 1 : r + 2];
      return n.set(cp(a, c.x, u.x, p.x, f.x), cp(a, c.y, u.y, p.y, f.y)), n;
    }
    copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, n = this.points.length; t < n; t++) {
        const i = this.points[t];
        e.points.push(i.toArray());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, n = e.points.length; t < n; t++) {
        const i = e.points[t];
        this.points.push(new te().fromArray(i));
      }
      return this;
    }
  }
  var qh = Object.freeze({
    __proto__: null,
    ArcCurve: pm,
    CatmullRomCurve3: fm,
    CubicBezierCurve: Vh,
    CubicBezierCurve3: mm,
    EllipseCurve: rl,
    LineCurve: ol,
    LineCurve3: gm,
    QuadraticBezierCurve: Gh,
    QuadraticBezierCurve3: Hh,
    SplineCurve: Wh
  });
  class vm extends An {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(e) {
      this.curves.push(e);
    }
    closePath() {
      const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
      e.equals(t) || this.curves.push(new ol(t, e));
    }
    getPoint(e, t) {
      const n = e * this.getLength(), i = this.getCurveLengths();
      let s = 0;
      for (; s < i.length; ) {
        if (i[s] >= n) {
          const r = i[s] - n, a = this.curves[s], c = a.getLength(), u = c === 0 ? 0 : 1 - r / c;
          return a.getPointAt(u, t);
        }
        s++;
      }
      return null;
    }
    getLength() {
      const e = this.getCurveLengths();
      return e[e.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      const e = [];
      let t = 0;
      for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
      return this.cacheLengths = e, e;
    }
    getSpacedPoints(e = 40) {
      const t = [];
      for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
      return this.autoClose && t.push(t[0]), t;
    }
    getPoints(e = 12) {
      const t = [];
      let n;
      for (let i = 0, s = this.curves; i < s.length; i++) {
        const r = s[i], a = r.isEllipseCurve ? e * 2 : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? e * r.points.length : e, c = r.getPoints(a);
        for (let u = 0; u < c.length; u++) {
          const p = c[u];
          n && n.equals(p) || (t.push(p), n = p);
        }
      }
      return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
    }
    copy(e) {
      super.copy(e), this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(i.clone());
      }
      return this.autoClose = e.autoClose, this;
    }
    toJSON() {
      const e = super.toJSON();
      e.autoClose = this.autoClose, e.curves = [];
      for (let t = 0, n = this.curves.length; t < n; t++) {
        const i = this.curves[t];
        e.curves.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
      for (let t = 0, n = e.curves.length; t < n; t++) {
        const i = e.curves[t];
        this.curves.push(new qh[i.type]().fromJSON(i));
      }
      return this;
    }
  }
  class ro extends vm {
    constructor(e) {
      super(), this.type = "Path", this.currentPoint = new te(), e && this.setFromPoints(e);
    }
    setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
      return this;
    }
    moveTo(e, t) {
      return this.currentPoint.set(e, t), this;
    }
    lineTo(e, t) {
      const n = new ol(this.currentPoint.clone(), new te(e, t));
      return this.curves.push(n), this.currentPoint.set(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      const s = new Gh(this.currentPoint.clone(), new te(e, t), new te(n, i));
      return this.curves.push(s), this.currentPoint.set(n, i), this;
    }
    bezierCurveTo(e, t, n, i, s, r) {
      const a = new Vh(this.currentPoint.clone(), new te(e, t), new te(n, i), new te(s, r));
      return this.curves.push(a), this.currentPoint.set(s, r), this;
    }
    splineThru(e) {
      const t = [
        this.currentPoint.clone()
      ].concat(e), n = new Wh(t);
      return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
    }
    arc(e, t, n, i, s, r) {
      const a = this.currentPoint.x, c = this.currentPoint.y;
      return this.absarc(e + a, t + c, n, i, s, r), this;
    }
    absarc(e, t, n, i, s, r) {
      return this.absellipse(e, t, n, n, i, s, r), this;
    }
    ellipse(e, t, n, i, s, r, a, c) {
      const u = this.currentPoint.x, p = this.currentPoint.y;
      return this.absellipse(e + u, t + p, n, i, s, r, a, c), this;
    }
    absellipse(e, t, n, i, s, r, a, c) {
      const u = new rl(e, t, n, i, s, r, a, c);
      if (this.curves.length > 0) {
        const f = u.getPoint(0);
        f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
      }
      this.curves.push(u);
      const p = u.getPoint(1);
      return this.currentPoint.copy(p), this;
    }
    copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.currentPoint = this.currentPoint.toArray(), e;
    }
    fromJSON(e) {
      return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
    }
  }
  class pr extends Xe {
    constructor(e = [
      new te(0, -0.5),
      new te(0.5, 0),
      new te(0, 0.5)
    ], t = 12, n = 0, i = Math.PI * 2) {
      super(), this.type = "LatheGeometry", this.parameters = {
        points: e,
        segments: t,
        phiStart: n,
        phiLength: i
      }, t = Math.floor(t), i = At(i, 0, Math.PI * 2);
      const s = [], r = [], a = [], c = [], u = [], p = 1 / t, f = new P(), m = new te(), v = new P(), b = new P(), _ = new P();
      let x = 0, w = 0;
      for (let S = 0; S <= e.length - 1; S++) switch (S) {
        case 0:
          x = e[S + 1].x - e[S].x, w = e[S + 1].y - e[S].y, v.x = w * 1, v.y = -x, v.z = w * 0, _.copy(v), v.normalize(), c.push(v.x, v.y, v.z);
          break;
        case e.length - 1:
          c.push(_.x, _.y, _.z);
          break;
        default:
          x = e[S + 1].x - e[S].x, w = e[S + 1].y - e[S].y, v.x = w * 1, v.y = -x, v.z = w * 0, b.copy(v), v.x += _.x, v.y += _.y, v.z += _.z, v.normalize(), c.push(v.x, v.y, v.z), _.copy(b);
      }
      for (let S = 0; S <= t; S++) {
        const y = n + S * p * i, M = Math.sin(y), C = Math.cos(y);
        for (let R = 0; R <= e.length - 1; R++) {
          f.x = e[R].x * M, f.y = e[R].y, f.z = e[R].x * C, r.push(f.x, f.y, f.z), m.x = S / t, m.y = R / (e.length - 1), a.push(m.x, m.y);
          const k = c[3 * R + 0] * M, T = c[3 * R + 1], L = c[3 * R + 0] * C;
          u.push(k, T, L);
        }
      }
      for (let S = 0; S < t; S++) for (let y = 0; y < e.length - 1; y++) {
        const M = y + S * e.length, C = M, R = M + e.length, k = M + e.length + 1, T = M + 1;
        s.push(C, R, T), s.push(k, T, R);
      }
      this.setIndex(s), this.setAttribute("position", new Pe(r, 3)), this.setAttribute("uv", new Pe(a, 2)), this.setAttribute("normal", new Pe(u, 3));
    }
    static fromJSON(e) {
      return new pr(e.points, e.segments, e.phiStart, e.phiLength);
    }
  }
  class bo extends pr {
    constructor(e = 1, t = 1, n = 4, i = 8) {
      const s = new ro();
      s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
        radius: e,
        height: t,
        capSegments: n,
        radialSegments: i
      };
    }
    static fromJSON(e) {
      return new bo(e.radius, e.length, e.capSegments, e.radialSegments);
    }
  }
  class yo extends Xe {
    constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
      super(), this.type = "CircleGeometry", this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i
      }, t = Math.max(3, t);
      const s = [], r = [], a = [], c = [], u = new P(), p = new te();
      r.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5);
      for (let f = 0, m = 3; f <= t; f++, m += 3) {
        const v = n + f / t * i;
        u.x = e * Math.cos(v), u.y = e * Math.sin(v), r.push(u.x, u.y, u.z), a.push(0, 0, 1), p.x = (r[m] / e + 1) / 2, p.y = (r[m + 1] / e + 1) / 2, c.push(p.x, p.y);
      }
      for (let f = 1; f <= t; f++) s.push(f, f + 1, 0);
      this.setIndex(s), this.setAttribute("position", new Pe(r, 3)), this.setAttribute("normal", new Pe(a, 3)), this.setAttribute("uv", new Pe(c, 2));
    }
    static fromJSON(e) {
      return new yo(e.radius, e.segments, e.thetaStart, e.thetaLength);
    }
  }
  class fs extends Xe {
    constructor(e = 1, t = 1, n = 1, i = 32, s = 1, r = false, a = 0, c = Math.PI * 2) {
      super(), this.type = "CylinderGeometry", this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: s,
        openEnded: r,
        thetaStart: a,
        thetaLength: c
      };
      const u = this;
      i = Math.floor(i), s = Math.floor(s);
      const p = [], f = [], m = [], v = [];
      let b = 0;
      const _ = [], x = n / 2;
      let w = 0;
      S(), r === false && (e > 0 && y(true), t > 0 && y(false)), this.setIndex(p), this.setAttribute("position", new Pe(f, 3)), this.setAttribute("normal", new Pe(m, 3)), this.setAttribute("uv", new Pe(v, 2));
      function S() {
        const M = new P(), C = new P();
        let R = 0;
        const k = (t - e) / n;
        for (let T = 0; T <= s; T++) {
          const L = [], F = T / s, j = F * (t - e) + e;
          for (let Y = 0; Y <= i; Y++) {
            const z = Y / i, B = z * c + a, Z = Math.sin(B), ie = Math.cos(B);
            C.x = j * Z, C.y = -F * n + x, C.z = j * ie, f.push(C.x, C.y, C.z), M.set(Z, k, ie).normalize(), m.push(M.x, M.y, M.z), v.push(z, 1 - F), L.push(b++);
          }
          _.push(L);
        }
        for (let T = 0; T < i; T++) for (let L = 0; L < s; L++) {
          const F = _[L][T], j = _[L + 1][T], Y = _[L + 1][T + 1], z = _[L][T + 1];
          p.push(F, j, z), p.push(j, Y, z), R += 6;
        }
        u.addGroup(w, R, 0), w += R;
      }
      function y(M) {
        const C = b, R = new te(), k = new P();
        let T = 0;
        const L = M === true ? e : t, F = M === true ? 1 : -1;
        for (let Y = 1; Y <= i; Y++) f.push(0, x * F, 0), m.push(0, F, 0), v.push(0.5, 0.5), b++;
        const j = b;
        for (let Y = 0; Y <= i; Y++) {
          const B = Y / i * c + a, Z = Math.cos(B), ie = Math.sin(B);
          k.x = L * ie, k.y = x * F, k.z = L * Z, f.push(k.x, k.y, k.z), m.push(0, F, 0), R.x = Z * 0.5 + 0.5, R.y = ie * 0.5 * F + 0.5, v.push(R.x, R.y), b++;
        }
        for (let Y = 0; Y < i; Y++) {
          const z = C + Y, B = j + Y;
          M === true ? p.push(B, B + 1, z) : p.push(B + 1, B, z), T += 3;
        }
        u.addGroup(w, T, M === true ? 1 : 2), w += T;
      }
    }
    static fromJSON(e) {
      return new fs(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
  }
  class wo extends fs {
    constructor(e = 1, t = 1, n = 32, i = 1, s = false, r = 0, a = Math.PI * 2) {
      super(0, e, t, n, i, s, r, a), this.type = "ConeGeometry", this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: s,
        thetaStart: r,
        thetaLength: a
      };
    }
    static fromJSON(e) {
      return new wo(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
    }
  }
  class ri extends Xe {
    constructor(e = [], t = [], n = 1, i = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = {
        vertices: e,
        indices: t,
        radius: n,
        detail: i
      };
      const s = [], r = [];
      a(i), u(n), p(), this.setAttribute("position", new Pe(s, 3)), this.setAttribute("normal", new Pe(s.slice(), 3)), this.setAttribute("uv", new Pe(r, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
      function a(S) {
        const y = new P(), M = new P(), C = new P();
        for (let R = 0; R < t.length; R += 3) v(t[R + 0], y), v(t[R + 1], M), v(t[R + 2], C), c(y, M, C, S);
      }
      function c(S, y, M, C) {
        const R = C + 1, k = [];
        for (let T = 0; T <= R; T++) {
          k[T] = [];
          const L = S.clone().lerp(M, T / R), F = y.clone().lerp(M, T / R), j = R - T;
          for (let Y = 0; Y <= j; Y++) Y === 0 && T === R ? k[T][Y] = L : k[T][Y] = L.clone().lerp(F, Y / j);
        }
        for (let T = 0; T < R; T++) for (let L = 0; L < 2 * (R - T) - 1; L++) {
          const F = Math.floor(L / 2);
          L % 2 === 0 ? (m(k[T][F + 1]), m(k[T + 1][F]), m(k[T][F])) : (m(k[T][F + 1]), m(k[T + 1][F + 1]), m(k[T + 1][F]));
        }
      }
      function u(S) {
        const y = new P();
        for (let M = 0; M < s.length; M += 3) y.x = s[M + 0], y.y = s[M + 1], y.z = s[M + 2], y.normalize().multiplyScalar(S), s[M + 0] = y.x, s[M + 1] = y.y, s[M + 2] = y.z;
      }
      function p() {
        const S = new P();
        for (let y = 0; y < s.length; y += 3) {
          S.x = s[y + 0], S.y = s[y + 1], S.z = s[y + 2];
          const M = x(S) / 2 / Math.PI + 0.5, C = w(S) / Math.PI + 0.5;
          r.push(M, 1 - C);
        }
        b(), f();
      }
      function f() {
        for (let S = 0; S < r.length; S += 6) {
          const y = r[S + 0], M = r[S + 2], C = r[S + 4], R = Math.max(y, M, C), k = Math.min(y, M, C);
          R > 0.9 && k < 0.1 && (y < 0.2 && (r[S + 0] += 1), M < 0.2 && (r[S + 2] += 1), C < 0.2 && (r[S + 4] += 1));
        }
      }
      function m(S) {
        s.push(S.x, S.y, S.z);
      }
      function v(S, y) {
        const M = S * 3;
        y.x = e[M + 0], y.y = e[M + 1], y.z = e[M + 2];
      }
      function b() {
        const S = new P(), y = new P(), M = new P(), C = new P(), R = new te(), k = new te(), T = new te();
        for (let L = 0, F = 0; L < s.length; L += 9, F += 6) {
          S.set(s[L + 0], s[L + 1], s[L + 2]), y.set(s[L + 3], s[L + 4], s[L + 5]), M.set(s[L + 6], s[L + 7], s[L + 8]), R.set(r[F + 0], r[F + 1]), k.set(r[F + 2], r[F + 3]), T.set(r[F + 4], r[F + 5]), C.copy(S).add(y).add(M).divideScalar(3);
          const j = x(C);
          _(R, F + 0, S, j), _(k, F + 2, y, j), _(T, F + 4, M, j);
        }
      }
      function _(S, y, M, C) {
        C < 0 && S.x === 1 && (r[y] = S.x - 1), M.x === 0 && M.z === 0 && (r[y] = C / 2 / Math.PI + 0.5);
      }
      function x(S) {
        return Math.atan2(S.z, -S.x);
      }
      function w(S) {
        return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
      }
    }
    static fromJSON(e) {
      return new ri(e.vertices, e.indices, e.radius, e.details);
    }
  }
  class Mo extends ri {
    constructor(e = 1, t = 0) {
      const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i
      ], r = [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ];
      super(s, r, e, t), this.type = "DodecahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Mo(e.radius, e.detail);
    }
  }
  const _a = new P(), xa = new P(), fc = new P(), ba = new xn();
  class _m extends Xe {
    constructor(e = null, t = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = {
        geometry: e,
        thresholdAngle: t
      }, e !== null) {
        const i = Math.pow(10, 4), s = Math.cos(as * t), r = e.getIndex(), a = e.getAttribute("position"), c = r ? r.count : a.count, u = [
          0,
          0,
          0
        ], p = [
          "a",
          "b",
          "c"
        ], f = new Array(3), m = {}, v = [];
        for (let b = 0; b < c; b += 3) {
          r ? (u[0] = r.getX(b), u[1] = r.getX(b + 1), u[2] = r.getX(b + 2)) : (u[0] = b, u[1] = b + 1, u[2] = b + 2);
          const { a: _, b: x, c: w } = ba;
          if (_.fromBufferAttribute(a, u[0]), x.fromBufferAttribute(a, u[1]), w.fromBufferAttribute(a, u[2]), ba.getNormal(fc), f[0] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(_.z * i)}`, f[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`, f[2] = `${Math.round(w.x * i)},${Math.round(w.y * i)},${Math.round(w.z * i)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0])) for (let S = 0; S < 3; S++) {
            const y = (S + 1) % 3, M = f[S], C = f[y], R = ba[p[S]], k = ba[p[y]], T = `${M}_${C}`, L = `${C}_${M}`;
            L in m && m[L] ? (fc.dot(m[L].normal) <= s && (v.push(R.x, R.y, R.z), v.push(k.x, k.y, k.z)), m[L] = null) : T in m || (m[T] = {
              index0: u[S],
              index1: u[y],
              normal: fc.clone()
            });
          }
        }
        for (const b in m) if (m[b]) {
          const { index0: _, index1: x } = m[b];
          _a.fromBufferAttribute(a, _), xa.fromBufferAttribute(a, x), v.push(_a.x, _a.y, _a.z), v.push(xa.x, xa.y, xa.z);
        }
        this.setAttribute("position", new Pe(v, 3));
      }
    }
  }
  class cs extends ro {
    constructor(e) {
      super(e), this.uuid = dn(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(e) {
      const t = [];
      for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
      return t;
    }
    extractPoints(e) {
      return {
        shape: this.getPoints(e),
        holes: this.getPointsHoles(e)
      };
    }
    copy(e) {
      super.copy(e), this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(i.clone());
      }
      return this;
    }
    toJSON() {
      const e = super.toJSON();
      e.uuid = this.uuid, e.holes = [];
      for (let t = 0, n = this.holes.length; t < n; t++) {
        const i = this.holes[t];
        e.holes.push(i.toJSON());
      }
      return e;
    }
    fromJSON(e) {
      super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
      for (let t = 0, n = e.holes.length; t < n; t++) {
        const i = e.holes[t];
        this.holes.push(new ro().fromJSON(i));
      }
      return this;
    }
  }
  const tS = {
    triangulate: function(l, e, t = 2) {
      const n = e && e.length, i = n ? e[0] * t : l.length;
      let s = xm(l, 0, i, t, true);
      const r = [];
      if (!s || s.next === s.prev) return r;
      let a, c, u, p, f, m, v;
      if (n && (s = oS(l, e, s, t)), l.length > 80 * t) {
        a = u = l[0], c = p = l[1];
        for (let b = t; b < i; b += t) f = l[b], m = l[b + 1], f < a && (a = f), m < c && (c = m), f > u && (u = f), m > p && (p = m);
        v = Math.max(u - a, p - c), v = v !== 0 ? 32767 / v : 0;
      }
      return oo(s, r, t, a, c, v, 0), r;
    }
  };
  function xm(l, e, t, n, i) {
    let s, r;
    if (i === vS(l, e, t, n) > 0) for (s = e; s < t; s += n) r = hp(s, l[s], l[s + 1], r);
    else for (s = t - n; s >= e; s -= n) r = hp(s, l[s], l[s + 1], r);
    return r && al(r, r.next) && (lo(r), r = r.next), r;
  }
  function ds(l, e) {
    if (!l) return l;
    e || (e = l);
    let t = l, n;
    do
      if (n = false, !t.steiner && (al(t, t.next) || wt(t.prev, t, t.next) === 0)) {
        if (lo(t), t = e = t.prev, t === t.next) break;
        n = true;
      } else t = t.next;
    while (n || t !== e);
    return e;
  }
  function oo(l, e, t, n, i, s, r) {
    if (!l) return;
    !r && s && uS(l, n, i, s);
    let a = l, c, u;
    for (; l.prev !== l.next; ) {
      if (c = l.prev, u = l.next, s ? iS(l, n, i, s) : nS(l)) {
        e.push(c.i / t | 0), e.push(l.i / t | 0), e.push(u.i / t | 0), lo(l), l = u.next, a = u.next;
        continue;
      }
      if (l = u, l === a) {
        r ? r === 1 ? (l = sS(ds(l), e, t), oo(l, e, t, n, i, s, 2)) : r === 2 && rS(l, e, t, n, i, s) : oo(ds(l), e, t, n, i, s, 1);
        break;
      }
    }
  }
  function nS(l) {
    const e = l.prev, t = l, n = l.next;
    if (wt(e, t, n) >= 0) return false;
    const i = e.x, s = t.x, r = n.x, a = e.y, c = t.y, u = n.y, p = i < s ? i < r ? i : r : s < r ? s : r, f = a < c ? a < u ? a : u : c < u ? c : u, m = i > s ? i > r ? i : r : s > r ? s : r, v = a > c ? a > u ? a : u : c > u ? c : u;
    let b = n.next;
    for (; b !== e; ) {
      if (b.x >= p && b.x <= m && b.y >= f && b.y <= v && Ys(i, a, s, c, r, u, b.x, b.y) && wt(b.prev, b, b.next) >= 0) return false;
      b = b.next;
    }
    return true;
  }
  function iS(l, e, t, n) {
    const i = l.prev, s = l, r = l.next;
    if (wt(i, s, r) >= 0) return false;
    const a = i.x, c = s.x, u = r.x, p = i.y, f = s.y, m = r.y, v = a < c ? a < u ? a : u : c < u ? c : u, b = p < f ? p < m ? p : m : f < m ? f : m, _ = a > c ? a > u ? a : u : c > u ? c : u, x = p > f ? p > m ? p : m : f > m ? f : m, w = ah(v, b, e, t, n), S = ah(_, x, e, t, n);
    let y = l.prevZ, M = l.nextZ;
    for (; y && y.z >= w && M && M.z <= S; ) {
      if (y.x >= v && y.x <= _ && y.y >= b && y.y <= x && y !== i && y !== r && Ys(a, p, c, f, u, m, y.x, y.y) && wt(y.prev, y, y.next) >= 0 || (y = y.prevZ, M.x >= v && M.x <= _ && M.y >= b && M.y <= x && M !== i && M !== r && Ys(a, p, c, f, u, m, M.x, M.y) && wt(M.prev, M, M.next) >= 0)) return false;
      M = M.nextZ;
    }
    for (; y && y.z >= w; ) {
      if (y.x >= v && y.x <= _ && y.y >= b && y.y <= x && y !== i && y !== r && Ys(a, p, c, f, u, m, y.x, y.y) && wt(y.prev, y, y.next) >= 0) return false;
      y = y.prevZ;
    }
    for (; M && M.z <= S; ) {
      if (M.x >= v && M.x <= _ && M.y >= b && M.y <= x && M !== i && M !== r && Ys(a, p, c, f, u, m, M.x, M.y) && wt(M.prev, M, M.next) >= 0) return false;
      M = M.nextZ;
    }
    return true;
  }
  function sS(l, e, t) {
    let n = l;
    do {
      const i = n.prev, s = n.next.next;
      !al(i, s) && bm(i, n, n.next, s) && ao(i, s) && ao(s, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(s.i / t | 0), lo(n), lo(n.next), n = l = s), n = n.next;
    } while (n !== l);
    return ds(n);
  }
  function rS(l, e, t, n, i, s) {
    let r = l;
    do {
      let a = r.next.next;
      for (; a !== r.prev; ) {
        if (r.i !== a.i && fS(r, a)) {
          let c = ym(r, a);
          r = ds(r, r.next), c = ds(c, c.next), oo(r, e, t, n, i, s, 0), oo(c, e, t, n, i, s, 0);
          return;
        }
        a = a.next;
      }
      r = r.next;
    } while (r !== l);
  }
  function oS(l, e, t, n) {
    const i = [];
    let s, r, a, c, u;
    for (s = 0, r = e.length; s < r; s++) a = e[s] * n, c = s < r - 1 ? e[s + 1] * n : l.length, u = xm(l, a, c, n, false), u === u.next && (u.steiner = true), i.push(pS(u));
    for (i.sort(aS), s = 0; s < i.length; s++) t = lS(i[s], t);
    return t;
  }
  function aS(l, e) {
    return l.x - e.x;
  }
  function lS(l, e) {
    const t = cS(l, e);
    if (!t) return e;
    const n = ym(t, l);
    return ds(n, n.next), ds(t, t.next);
  }
  function cS(l, e) {
    let t = e, n = -1 / 0, i;
    const s = l.x, r = l.y;
    do {
      if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
        const m = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
        if (m <= s && m > n && (n = m, i = t.x < t.next.x ? t : t.next, m === s)) return i;
      }
      t = t.next;
    } while (t !== e);
    if (!i) return null;
    const a = i, c = i.x, u = i.y;
    let p = 1 / 0, f;
    t = i;
    do
      s >= t.x && t.x >= c && s !== t.x && Ys(r < u ? s : n, r, c, u, r < u ? n : s, r, t.x, t.y) && (f = Math.abs(r - t.y) / (s - t.x), ao(t, l) && (f < p || f === p && (t.x > i.x || t.x === i.x && hS(i, t))) && (i = t, p = f)), t = t.next;
    while (t !== a);
    return i;
  }
  function hS(l, e) {
    return wt(l.prev, l, e.prev) < 0 && wt(e.next, l, l.next) < 0;
  }
  function uS(l, e, t, n) {
    let i = l;
    do
      i.z === 0 && (i.z = ah(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
    while (i !== l);
    i.prevZ.nextZ = null, i.prevZ = null, dS(i);
  }
  function dS(l) {
    let e, t, n, i, s, r, a, c, u = 1;
    do {
      for (t = l, l = null, s = null, r = 0; t; ) {
        for (r++, n = t, a = 0, e = 0; e < u && (a++, n = n.nextZ, !!n); e++) ;
        for (c = u; a > 0 || c > 0 && n; ) a !== 0 && (c === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, c--), s ? s.nextZ = i : l = i, i.prevZ = s, s = i;
        t = n;
      }
      s.nextZ = null, u *= 2;
    } while (r > 1);
    return l;
  }
  function ah(l, e, t, n, i) {
    return l = (l - t) * i | 0, e = (e - n) * i | 0, l = (l | l << 8) & 16711935, l = (l | l << 4) & 252645135, l = (l | l << 2) & 858993459, l = (l | l << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, l | e << 1;
  }
  function pS(l) {
    let e = l, t = l;
    do
      (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
    while (e !== l);
    return t;
  }
  function Ys(l, e, t, n, i, s, r, a) {
    return (i - r) * (e - a) >= (l - r) * (s - a) && (l - r) * (n - a) >= (t - r) * (e - a) && (t - r) * (s - a) >= (i - r) * (n - a);
  }
  function fS(l, e) {
    return l.next.i !== e.i && l.prev.i !== e.i && !mS(l, e) && (ao(l, e) && ao(e, l) && gS(l, e) && (wt(l.prev, l, e.prev) || wt(l, e.prev, e)) || al(l, e) && wt(l.prev, l, l.next) > 0 && wt(e.prev, e, e.next) > 0);
  }
  function wt(l, e, t) {
    return (e.y - l.y) * (t.x - e.x) - (e.x - l.x) * (t.y - e.y);
  }
  function al(l, e) {
    return l.x === e.x && l.y === e.y;
  }
  function bm(l, e, t, n) {
    const i = wa(wt(l, e, t)), s = wa(wt(l, e, n)), r = wa(wt(t, n, l)), a = wa(wt(t, n, e));
    return !!(i !== s && r !== a || i === 0 && ya(l, t, e) || s === 0 && ya(l, n, e) || r === 0 && ya(t, l, n) || a === 0 && ya(t, e, n));
  }
  function ya(l, e, t) {
    return e.x <= Math.max(l.x, t.x) && e.x >= Math.min(l.x, t.x) && e.y <= Math.max(l.y, t.y) && e.y >= Math.min(l.y, t.y);
  }
  function wa(l) {
    return l > 0 ? 1 : l < 0 ? -1 : 0;
  }
  function mS(l, e) {
    let t = l;
    do {
      if (t.i !== l.i && t.next.i !== l.i && t.i !== e.i && t.next.i !== e.i && bm(t, t.next, l, e)) return true;
      t = t.next;
    } while (t !== l);
    return false;
  }
  function ao(l, e) {
    return wt(l.prev, l, l.next) < 0 ? wt(l, e, l.next) >= 0 && wt(l, l.prev, e) >= 0 : wt(l, e, l.prev) < 0 || wt(l, l.next, e) < 0;
  }
  function gS(l, e) {
    let t = l, n = false;
    const i = (l.x + e.x) / 2, s = (l.y + e.y) / 2;
    do
      t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
    while (t !== l);
    return n;
  }
  function ym(l, e) {
    const t = new lh(l.i, l.x, l.y), n = new lh(e.i, e.x, e.y), i = l.next, s = e.prev;
    return l.next = e, e.prev = l, t.next = i, i.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
  }
  function hp(l, e, t, n) {
    const i = new lh(l, e, t);
    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
  }
  function lo(l) {
    l.next.prev = l.prev, l.prev.next = l.next, l.prevZ && (l.prevZ.nextZ = l.nextZ), l.nextZ && (l.nextZ.prevZ = l.prevZ);
  }
  function lh(l, e, t) {
    this.i = l, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function vS(l, e, t, n) {
    let i = 0;
    for (let s = e, r = t - n; s < t; s += n) i += (l[r] - l[s]) * (l[s + 1] + l[r + 1]), r = s;
    return i;
  }
  class Nn {
    static area(e) {
      const t = e.length;
      let n = 0;
      for (let i = t - 1, s = 0; s < t; i = s++) n += e[i].x * e[s].y - e[s].x * e[i].y;
      return n * 0.5;
    }
    static isClockWise(e) {
      return Nn.area(e) < 0;
    }
    static triangulateShape(e, t) {
      const n = [], i = [], s = [];
      up(e), dp(n, e);
      let r = e.length;
      t.forEach(up);
      for (let c = 0; c < t.length; c++) i.push(r), r += t[c].length, dp(n, t[c]);
      const a = tS.triangulate(n, i);
      for (let c = 0; c < a.length; c += 3) s.push(a.slice(c, c + 3));
      return s;
    }
  }
  function up(l) {
    const e = l.length;
    e > 2 && l[e - 1].equals(l[0]) && l.pop();
  }
  function dp(l, e) {
    for (let t = 0; t < e.length; t++) l.push(e[t].x), l.push(e[t].y);
  }
  class So extends Xe {
    constructor(e = new cs([
      new te(0.5, 0.5),
      new te(-0.5, 0.5),
      new te(-0.5, -0.5),
      new te(0.5, -0.5)
    ]), t = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = {
        shapes: e,
        options: t
      }, e = Array.isArray(e) ? e : [
        e
      ];
      const n = this, i = [], s = [];
      for (let a = 0, c = e.length; a < c; a++) {
        const u = e[a];
        r(u);
      }
      this.setAttribute("position", new Pe(i, 3)), this.setAttribute("uv", new Pe(s, 2)), this.computeVertexNormals();
      function r(a) {
        const c = [], u = t.curveSegments !== void 0 ? t.curveSegments : 12, p = t.steps !== void 0 ? t.steps : 1, f = t.depth !== void 0 ? t.depth : 1;
        let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, v = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, b = t.bevelSize !== void 0 ? t.bevelSize : v - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
        const w = t.extrudePath, S = t.UVGenerator !== void 0 ? t.UVGenerator : _S;
        let y, M = false, C, R, k, T;
        w && (y = w.getSpacedPoints(p), M = true, m = false, C = w.computeFrenetFrames(p, false), R = new P(), k = new P(), T = new P()), m || (x = 0, v = 0, b = 0, _ = 0);
        const L = a.extractPoints(u);
        let F = L.shape;
        const j = L.holes;
        if (!Nn.isClockWise(F)) {
          F = F.reverse();
          for (let se = 0, ne = j.length; se < ne; se++) {
            const ge = j[se];
            Nn.isClockWise(ge) && (j[se] = ge.reverse());
          }
        }
        const z = Nn.triangulateShape(F, j), B = F;
        for (let se = 0, ne = j.length; se < ne; se++) {
          const ge = j[se];
          F = F.concat(ge);
        }
        function Z(se, ne, ge) {
          return ne || console.error("THREE.ExtrudeGeometry: vec does not exist"), ne.clone().multiplyScalar(ge).add(se);
        }
        const ie = F.length, re = z.length;
        function W(se, ne, ge) {
          let Ee, fe, Fe;
          const Ne = se.x - ne.x, Re = se.y - ne.y, dt = ge.x - se.x, it = ge.y - se.y, D = Ne * Ne + Re * Re, A = Ne * it - Re * dt;
          if (Math.abs(A) > Number.EPSILON) {
            const $ = Math.sqrt(D), he = Math.sqrt(dt * dt + it * it), me = ne.x - Re / $, xe = ne.y + Ne / $, Be = ge.x - it / he, O = ge.y + dt / he, G = ((Be - me) * it - (O - xe) * dt) / (Ne * it - Re * dt);
            Ee = me + Ne * G - se.x, fe = xe + Re * G - se.y;
            const ye = Ee * Ee + fe * fe;
            if (ye <= 2) return new te(Ee, fe);
            Fe = Math.sqrt(ye / 2);
          } else {
            let $ = false;
            Ne > Number.EPSILON ? dt > Number.EPSILON && ($ = true) : Ne < -Number.EPSILON ? dt < -Number.EPSILON && ($ = true) : Math.sign(Re) === Math.sign(it) && ($ = true), $ ? (Ee = -Re, fe = Ne, Fe = Math.sqrt(D)) : (Ee = Ne, fe = Re, Fe = Math.sqrt(D / 2));
          }
          return new te(Ee / Fe, fe / Fe);
        }
        const pe = [];
        for (let se = 0, ne = B.length, ge = ne - 1, Ee = se + 1; se < ne; se++, ge++, Ee++) ge === ne && (ge = 0), Ee === ne && (Ee = 0), pe[se] = W(B[se], B[ge], B[Ee]);
        const ae = [];
        let Te, q = pe.concat();
        for (let se = 0, ne = j.length; se < ne; se++) {
          const ge = j[se];
          Te = [];
          for (let Ee = 0, fe = ge.length, Fe = fe - 1, Ne = Ee + 1; Ee < fe; Ee++, Fe++, Ne++) Fe === fe && (Fe = 0), Ne === fe && (Ne = 0), Te[Ee] = W(ge[Ee], ge[Fe], ge[Ne]);
          ae.push(Te), q = q.concat(Te);
        }
        for (let se = 0; se < x; se++) {
          const ne = se / x, ge = v * Math.cos(ne * Math.PI / 2), Ee = b * Math.sin(ne * Math.PI / 2) + _;
          for (let fe = 0, Fe = B.length; fe < Fe; fe++) {
            const Ne = Z(B[fe], pe[fe], Ee);
            ke(Ne.x, Ne.y, -ge);
          }
          for (let fe = 0, Fe = j.length; fe < Fe; fe++) {
            const Ne = j[fe];
            Te = ae[fe];
            for (let Re = 0, dt = Ne.length; Re < dt; Re++) {
              const it = Z(Ne[Re], Te[Re], Ee);
              ke(it.x, it.y, -ge);
            }
          }
        }
        const le = b + _;
        for (let se = 0; se < ie; se++) {
          const ne = m ? Z(F[se], q[se], le) : F[se];
          M ? (k.copy(C.normals[0]).multiplyScalar(ne.x), R.copy(C.binormals[0]).multiplyScalar(ne.y), T.copy(y[0]).add(k).add(R), ke(T.x, T.y, T.z)) : ke(ne.x, ne.y, 0);
        }
        for (let se = 1; se <= p; se++) for (let ne = 0; ne < ie; ne++) {
          const ge = m ? Z(F[ne], q[ne], le) : F[ne];
          M ? (k.copy(C.normals[se]).multiplyScalar(ge.x), R.copy(C.binormals[se]).multiplyScalar(ge.y), T.copy(y[se]).add(k).add(R), ke(T.x, T.y, T.z)) : ke(ge.x, ge.y, f / p * se);
        }
        for (let se = x - 1; se >= 0; se--) {
          const ne = se / x, ge = v * Math.cos(ne * Math.PI / 2), Ee = b * Math.sin(ne * Math.PI / 2) + _;
          for (let fe = 0, Fe = B.length; fe < Fe; fe++) {
            const Ne = Z(B[fe], pe[fe], Ee);
            ke(Ne.x, Ne.y, f + ge);
          }
          for (let fe = 0, Fe = j.length; fe < Fe; fe++) {
            const Ne = j[fe];
            Te = ae[fe];
            for (let Re = 0, dt = Ne.length; Re < dt; Re++) {
              const it = Z(Ne[Re], Te[Re], Ee);
              M ? ke(it.x, it.y + y[p - 1].y, y[p - 1].x + ge) : ke(it.x, it.y, f + ge);
            }
          }
        }
        oe(), ce();
        function oe() {
          const se = i.length / 3;
          if (m) {
            let ne = 0, ge = ie * ne;
            for (let Ee = 0; Ee < re; Ee++) {
              const fe = z[Ee];
              Ce(fe[2] + ge, fe[1] + ge, fe[0] + ge);
            }
            ne = p + x * 2, ge = ie * ne;
            for (let Ee = 0; Ee < re; Ee++) {
              const fe = z[Ee];
              Ce(fe[0] + ge, fe[1] + ge, fe[2] + ge);
            }
          } else {
            for (let ne = 0; ne < re; ne++) {
              const ge = z[ne];
              Ce(ge[2], ge[1], ge[0]);
            }
            for (let ne = 0; ne < re; ne++) {
              const ge = z[ne];
              Ce(ge[0] + ie * p, ge[1] + ie * p, ge[2] + ie * p);
            }
          }
          n.addGroup(se, i.length / 3 - se, 0);
        }
        function ce() {
          const se = i.length / 3;
          let ne = 0;
          K(B, ne), ne += B.length;
          for (let ge = 0, Ee = j.length; ge < Ee; ge++) {
            const fe = j[ge];
            K(fe, ne), ne += fe.length;
          }
          n.addGroup(se, i.length / 3 - se, 1);
        }
        function K(se, ne) {
          let ge = se.length;
          for (; --ge >= 0; ) {
            const Ee = ge;
            let fe = ge - 1;
            fe < 0 && (fe = se.length - 1);
            for (let Fe = 0, Ne = p + x * 2; Fe < Ne; Fe++) {
              const Re = ie * Fe, dt = ie * (Fe + 1), it = ne + Ee + Re, D = ne + fe + Re, A = ne + fe + dt, $ = ne + Ee + dt;
              Le(it, D, A, $);
            }
          }
        }
        function ke(se, ne, ge) {
          c.push(se), c.push(ne), c.push(ge);
        }
        function Ce(se, ne, ge) {
          ve(se), ve(ne), ve(ge);
          const Ee = i.length / 3, fe = S.generateTopUV(n, i, Ee - 3, Ee - 2, Ee - 1);
          Ve(fe[0]), Ve(fe[1]), Ve(fe[2]);
        }
        function Le(se, ne, ge, Ee) {
          ve(se), ve(ne), ve(Ee), ve(ne), ve(ge), ve(Ee);
          const fe = i.length / 3, Fe = S.generateSideWallUV(n, i, fe - 6, fe - 3, fe - 2, fe - 1);
          Ve(Fe[0]), Ve(Fe[1]), Ve(Fe[3]), Ve(Fe[1]), Ve(Fe[2]), Ve(Fe[3]);
        }
        function ve(se) {
          i.push(c[se * 3 + 0]), i.push(c[se * 3 + 1]), i.push(c[se * 3 + 2]);
        }
        function Ve(se) {
          s.push(se.x), s.push(se.y);
        }
      }
    }
    toJSON() {
      const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
      return xS(t, n, e);
    }
    static fromJSON(e, t) {
      const n = [];
      for (let s = 0, r = e.shapes.length; s < r; s++) {
        const a = t[e.shapes[s]];
        n.push(a);
      }
      const i = e.options.extrudePath;
      return i !== void 0 && (e.options.extrudePath = new qh[i.type]().fromJSON(i)), new So(n, e.options);
    }
  }
  const _S = {
    generateTopUV: function(l, e, t, n, i) {
      const s = e[t * 3], r = e[t * 3 + 1], a = e[n * 3], c = e[n * 3 + 1], u = e[i * 3], p = e[i * 3 + 1];
      return [
        new te(s, r),
        new te(a, c),
        new te(u, p)
      ];
    },
    generateSideWallUV: function(l, e, t, n, i, s) {
      const r = e[t * 3], a = e[t * 3 + 1], c = e[t * 3 + 2], u = e[n * 3], p = e[n * 3 + 1], f = e[n * 3 + 2], m = e[i * 3], v = e[i * 3 + 1], b = e[i * 3 + 2], _ = e[s * 3], x = e[s * 3 + 1], w = e[s * 3 + 2];
      return Math.abs(a - p) < Math.abs(r - u) ? [
        new te(r, 1 - c),
        new te(u, 1 - f),
        new te(m, 1 - b),
        new te(_, 1 - w)
      ] : [
        new te(a, 1 - c),
        new te(p, 1 - f),
        new te(v, 1 - b),
        new te(x, 1 - w)
      ];
    }
  };
  function xS(l, e, t) {
    if (t.shapes = [], Array.isArray(l)) for (let n = 0, i = l.length; n < i; n++) {
      const s = l[n];
      t.shapes.push(s.uuid);
    }
    else t.shapes.push(l.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
  }
  class Eo extends ri {
    constructor(e = 1, t = 0) {
      const n = (1 + Math.sqrt(5)) / 2, i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1
      ], s = [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ];
      super(i, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Eo(e.radius, e.detail);
    }
  }
  class fr extends ri {
    constructor(e = 1, t = 0) {
      const n = [
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        -1
      ], i = [
        0,
        2,
        4,
        0,
        4,
        3,
        0,
        3,
        5,
        0,
        5,
        2,
        1,
        2,
        5,
        1,
        5,
        3,
        1,
        3,
        4,
        1,
        4,
        2
      ];
      super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new fr(e.radius, e.detail);
    }
  }
  class To extends Xe {
    constructor(e = 0.5, t = 1, n = 32, i = 1, s = 0, r = Math.PI * 2) {
      super(), this.type = "RingGeometry", this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: s,
        thetaLength: r
      }, n = Math.max(3, n), i = Math.max(1, i);
      const a = [], c = [], u = [], p = [];
      let f = e;
      const m = (t - e) / i, v = new P(), b = new te();
      for (let _ = 0; _ <= i; _++) {
        for (let x = 0; x <= n; x++) {
          const w = s + x / n * r;
          v.x = f * Math.cos(w), v.y = f * Math.sin(w), c.push(v.x, v.y, v.z), u.push(0, 0, 1), b.x = (v.x / t + 1) / 2, b.y = (v.y / t + 1) / 2, p.push(b.x, b.y);
        }
        f += m;
      }
      for (let _ = 0; _ < i; _++) {
        const x = _ * (n + 1);
        for (let w = 0; w < n; w++) {
          const S = w + x, y = S, M = S + n + 1, C = S + n + 2, R = S + 1;
          a.push(y, M, R), a.push(M, C, R);
        }
      }
      this.setIndex(a), this.setAttribute("position", new Pe(c, 3)), this.setAttribute("normal", new Pe(u, 3)), this.setAttribute("uv", new Pe(p, 2));
    }
    static fromJSON(e) {
      return new To(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
    }
  }
  class Co extends Xe {
    constructor(e = new cs([
      new te(0, 0.5),
      new te(-0.5, -0.5),
      new te(0.5, -0.5)
    ]), t = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = {
        shapes: e,
        curveSegments: t
      };
      const n = [], i = [], s = [], r = [];
      let a = 0, c = 0;
      if (Array.isArray(e) === false) u(e);
      else for (let p = 0; p < e.length; p++) u(e[p]), this.addGroup(a, c, p), a += c, c = 0;
      this.setIndex(n), this.setAttribute("position", new Pe(i, 3)), this.setAttribute("normal", new Pe(s, 3)), this.setAttribute("uv", new Pe(r, 2));
      function u(p) {
        const f = i.length / 3, m = p.extractPoints(t);
        let v = m.shape;
        const b = m.holes;
        Nn.isClockWise(v) === false && (v = v.reverse());
        for (let x = 0, w = b.length; x < w; x++) {
          const S = b[x];
          Nn.isClockWise(S) === true && (b[x] = S.reverse());
        }
        const _ = Nn.triangulateShape(v, b);
        for (let x = 0, w = b.length; x < w; x++) {
          const S = b[x];
          v = v.concat(S);
        }
        for (let x = 0, w = v.length; x < w; x++) {
          const S = v[x];
          i.push(S.x, S.y, 0), s.push(0, 0, 1), r.push(S.x, S.y);
        }
        for (let x = 0, w = _.length; x < w; x++) {
          const S = _[x], y = S[0] + f, M = S[1] + f, C = S[2] + f;
          n.push(y, M, C), c += 3;
        }
      }
    }
    toJSON() {
      const e = super.toJSON(), t = this.parameters.shapes;
      return bS(t, e);
    }
    static fromJSON(e, t) {
      const n = [];
      for (let i = 0, s = e.shapes.length; i < s; i++) {
        const r = t[e.shapes[i]];
        n.push(r);
      }
      return new Co(n, e.curveSegments);
    }
  }
  function bS(l, e) {
    if (e.shapes = [], Array.isArray(l)) for (let t = 0, n = l.length; t < n; t++) {
      const i = l[t];
      e.shapes.push(i.uuid);
    }
    else e.shapes.push(l.uuid);
    return e;
  }
  class mr extends Xe {
    constructor(e = 1, t = 32, n = 16, i = 0, s = Math.PI * 2, r = 0, a = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: r,
        thetaLength: a
      }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
      const c = Math.min(r + a, Math.PI);
      let u = 0;
      const p = [], f = new P(), m = new P(), v = [], b = [], _ = [], x = [];
      for (let w = 0; w <= n; w++) {
        const S = [], y = w / n;
        let M = 0;
        w == 0 && r == 0 ? M = 0.5 / t : w == n && c == Math.PI && (M = -0.5 / t);
        for (let C = 0; C <= t; C++) {
          const R = C / t;
          f.x = -e * Math.cos(i + R * s) * Math.sin(r + y * a), f.y = e * Math.cos(r + y * a), f.z = e * Math.sin(i + R * s) * Math.sin(r + y * a), b.push(f.x, f.y, f.z), m.copy(f).normalize(), _.push(m.x, m.y, m.z), x.push(R + M, 1 - y), S.push(u++);
        }
        p.push(S);
      }
      for (let w = 0; w < n; w++) for (let S = 0; S < t; S++) {
        const y = p[w][S + 1], M = p[w][S], C = p[w + 1][S], R = p[w + 1][S + 1];
        (w !== 0 || r > 0) && v.push(y, M, R), (w !== n - 1 || c < Math.PI) && v.push(M, C, R);
      }
      this.setIndex(v), this.setAttribute("position", new Pe(b, 3)), this.setAttribute("normal", new Pe(_, 3)), this.setAttribute("uv", new Pe(x, 2));
    }
    static fromJSON(e) {
      return new mr(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
    }
  }
  class Ao extends ri {
    constructor(e = 1, t = 0) {
      const n = [
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        1,
        -1,
        -1
      ], i = [
        2,
        1,
        0,
        0,
        3,
        2,
        1,
        3,
        0,
        2,
        3,
        1
      ];
      super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
        radius: e,
        detail: t
      };
    }
    static fromJSON(e) {
      return new Ao(e.radius, e.detail);
    }
  }
  class Po extends Xe {
    constructor(e = 1, t = 0.4, n = 12, i = 48, s = Math.PI * 2) {
      super(), this.type = "TorusGeometry", this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: i,
        arc: s
      }, n = Math.floor(n), i = Math.floor(i);
      const r = [], a = [], c = [], u = [], p = new P(), f = new P(), m = new P();
      for (let v = 0; v <= n; v++) for (let b = 0; b <= i; b++) {
        const _ = b / i * s, x = v / n * Math.PI * 2;
        f.x = (e + t * Math.cos(x)) * Math.cos(_), f.y = (e + t * Math.cos(x)) * Math.sin(_), f.z = t * Math.sin(x), a.push(f.x, f.y, f.z), p.x = e * Math.cos(_), p.y = e * Math.sin(_), m.subVectors(f, p).normalize(), c.push(m.x, m.y, m.z), u.push(b / i), u.push(v / n);
      }
      for (let v = 1; v <= n; v++) for (let b = 1; b <= i; b++) {
        const _ = (i + 1) * v + b - 1, x = (i + 1) * (v - 1) + b - 1, w = (i + 1) * (v - 1) + b, S = (i + 1) * v + b;
        r.push(_, x, S), r.push(x, w, S);
      }
      this.setIndex(r), this.setAttribute("position", new Pe(a, 3)), this.setAttribute("normal", new Pe(c, 3)), this.setAttribute("uv", new Pe(u, 2));
    }
    static fromJSON(e) {
      return new Po(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
    }
  }
  class Lo extends Xe {
    constructor(e = 1, t = 0.4, n = 64, i = 8, s = 2, r = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: i,
        p: s,
        q: r
      }, n = Math.floor(n), i = Math.floor(i);
      const a = [], c = [], u = [], p = [], f = new P(), m = new P(), v = new P(), b = new P(), _ = new P(), x = new P(), w = new P();
      for (let y = 0; y <= n; ++y) {
        const M = y / n * s * Math.PI * 2;
        S(M, s, r, e, v), S(M + 0.01, s, r, e, b), x.subVectors(b, v), w.addVectors(b, v), _.crossVectors(x, w), w.crossVectors(_, x), _.normalize(), w.normalize();
        for (let C = 0; C <= i; ++C) {
          const R = C / i * Math.PI * 2, k = -t * Math.cos(R), T = t * Math.sin(R);
          f.x = v.x + (k * w.x + T * _.x), f.y = v.y + (k * w.y + T * _.y), f.z = v.z + (k * w.z + T * _.z), c.push(f.x, f.y, f.z), m.subVectors(f, v).normalize(), u.push(m.x, m.y, m.z), p.push(y / n), p.push(C / i);
        }
      }
      for (let y = 1; y <= n; y++) for (let M = 1; M <= i; M++) {
        const C = (i + 1) * (y - 1) + (M - 1), R = (i + 1) * y + (M - 1), k = (i + 1) * y + M, T = (i + 1) * (y - 1) + M;
        a.push(C, R, T), a.push(R, k, T);
      }
      this.setIndex(a), this.setAttribute("position", new Pe(c, 3)), this.setAttribute("normal", new Pe(u, 3)), this.setAttribute("uv", new Pe(p, 2));
      function S(y, M, C, R, k) {
        const T = Math.cos(y), L = Math.sin(y), F = C / M * y, j = Math.cos(F);
        k.x = R * (2 + j) * 0.5 * T, k.y = R * (2 + j) * L * 0.5, k.z = R * Math.sin(F) * 0.5;
      }
    }
    static fromJSON(e) {
      return new Lo(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
    }
  }
  class Ro extends Xe {
    constructor(e = new Hh(new P(-1, -1, 0), new P(-1, 1, 0), new P(1, 1, 0)), t = 64, n = 1, i = 8, s = false) {
      super(), this.type = "TubeGeometry", this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: i,
        closed: s
      };
      const r = e.computeFrenetFrames(t, s);
      this.tangents = r.tangents, this.normals = r.normals, this.binormals = r.binormals;
      const a = new P(), c = new P(), u = new te();
      let p = new P();
      const f = [], m = [], v = [], b = [];
      _(), this.setIndex(b), this.setAttribute("position", new Pe(f, 3)), this.setAttribute("normal", new Pe(m, 3)), this.setAttribute("uv", new Pe(v, 2));
      function _() {
        for (let y = 0; y < t; y++) x(y);
        x(s === false ? t : 0), S(), w();
      }
      function x(y) {
        p = e.getPointAt(y / t, p);
        const M = r.normals[y], C = r.binormals[y];
        for (let R = 0; R <= i; R++) {
          const k = R / i * Math.PI * 2, T = Math.sin(k), L = -Math.cos(k);
          c.x = L * M.x + T * C.x, c.y = L * M.y + T * C.y, c.z = L * M.z + T * C.z, c.normalize(), m.push(c.x, c.y, c.z), a.x = p.x + n * c.x, a.y = p.y + n * c.y, a.z = p.z + n * c.z, f.push(a.x, a.y, a.z);
        }
      }
      function w() {
        for (let y = 1; y <= t; y++) for (let M = 1; M <= i; M++) {
          const C = (i + 1) * (y - 1) + (M - 1), R = (i + 1) * y + (M - 1), k = (i + 1) * y + M, T = (i + 1) * (y - 1) + M;
          b.push(C, R, T), b.push(R, k, T);
        }
      }
      function S() {
        for (let y = 0; y <= t; y++) for (let M = 0; M <= i; M++) u.x = y / t, u.y = M / i, v.push(u.x, u.y);
      }
    }
    toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e;
    }
    static fromJSON(e) {
      return new Ro(new qh[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
    }
  }
  class wm extends Xe {
    constructor(e = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = {
        geometry: e
      }, e !== null) {
        const t = [], n = /* @__PURE__ */ new Set(), i = new P(), s = new P();
        if (e.index !== null) {
          const r = e.attributes.position, a = e.index;
          let c = e.groups;
          c.length === 0 && (c = [
            {
              start: 0,
              count: a.count,
              materialIndex: 0
            }
          ]);
          for (let u = 0, p = c.length; u < p; ++u) {
            const f = c[u], m = f.start, v = f.count;
            for (let b = m, _ = m + v; b < _; b += 3) for (let x = 0; x < 3; x++) {
              const w = a.getX(b + x), S = a.getX(b + (x + 1) % 3);
              i.fromBufferAttribute(r, w), s.fromBufferAttribute(r, S), pp(i, s, n) === true && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
          }
        } else {
          const r = e.attributes.position;
          for (let a = 0, c = r.count / 3; a < c; a++) for (let u = 0; u < 3; u++) {
            const p = 3 * a + u, f = 3 * a + (u + 1) % 3;
            i.fromBufferAttribute(r, p), s.fromBufferAttribute(r, f), pp(i, s, n) === true && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
        }
        this.setAttribute("position", new Pe(t, 3));
      }
    }
  }
  function pp(l, e, t) {
    const n = `${l.x},${l.y},${l.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${l.x},${l.y},${l.z}`;
    return t.has(n) === true || t.has(i) === true ? false : (t.add(n), t.add(i), true);
  }
  var fp = Object.freeze({
    __proto__: null,
    BoxGeometry: Vn,
    CapsuleGeometry: bo,
    CircleGeometry: yo,
    ConeGeometry: wo,
    CylinderGeometry: fs,
    DodecahedronGeometry: Mo,
    EdgesGeometry: _m,
    ExtrudeGeometry: So,
    IcosahedronGeometry: Eo,
    LatheGeometry: pr,
    OctahedronGeometry: fr,
    PlaneGeometry: ur,
    PolyhedronGeometry: ri,
    RingGeometry: To,
    ShapeGeometry: Co,
    SphereGeometry: mr,
    TetrahedronGeometry: Ao,
    TorusGeometry: Po,
    TorusKnotGeometry: Lo,
    TubeGeometry: Ro,
    WireframeGeometry: wm
  });
  class Mm extends Bt {
    constructor(e) {
      super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new we(0), this.transparent = true, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
    }
  }
  class Sm extends Un {
    constructor(e) {
      super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
    }
  }
  class gr extends Bt {
    constructor(e) {
      super(), this.isMeshStandardMaterial = true, this.defines = {
        STANDARD: ""
      }, this.type = "MeshStandardMaterial", this.color = new we(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new we(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: ""
      }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class oi extends gr {
    constructor(e) {
      super(), this.isMeshPhysicalMaterial = true, this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new te(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
        get: function() {
          return At(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        }
      }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
        100,
        400
      ], this.iridescenceThicknessMap = null, this.sheenColor = new we(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new we(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new we(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
    }
    copy(e) {
      return super.copy(e), this.defines = {
        STANDARD: "",
        PHYSICAL: ""
      }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
        ...e.iridescenceThicknessRange
      ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
    }
  }
  class Em extends Bt {
    constructor(e) {
      super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new we(16777215), this.specular = new we(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new we(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = po, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class Tm extends Bt {
    constructor(e) {
      super(), this.isMeshToonMaterial = true, this.defines = {
        TOON: ""
      }, this.type = "MeshToonMaterial", this.color = new we(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new we(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
    }
  }
  class Cm extends Bt {
    constructor(e) {
      super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
    }
  }
  class Am extends Bt {
    constructor(e) {
      super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new we(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new we(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = po, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class Pm extends Bt {
    constructor(e) {
      super(), this.isMeshMatcapMaterial = true, this.defines = {
        MATCAP: ""
      }, this.type = "MeshMatcapMaterial", this.color = new we(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ri, this.normalScale = new te(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.defines = {
        MATCAP: ""
      }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
    }
  }
  class Lm extends Zt {
    constructor(e) {
      super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
    }
    copy(e) {
      return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
    }
  }
  function _n(l, e, t) {
    return Xh(l) ? new l.constructor(l.subarray(e, t !== void 0 ? t : l.length)) : l.slice(e, t);
  }
  function ss(l, e, t) {
    return !l || !t && l.constructor === e ? l : typeof e.BYTES_PER_ELEMENT == "number" ? new e(l) : Array.prototype.slice.call(l);
  }
  function Xh(l) {
    return ArrayBuffer.isView(l) && !(l instanceof DataView);
  }
  function Rm(l) {
    function e(i, s) {
      return l[i] - l[s];
    }
    const t = l.length, n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return n.sort(e), n;
  }
  function ch(l, e, t) {
    const n = l.length, i = new l.constructor(n);
    for (let s = 0, r = 0; r !== n; ++s) {
      const a = t[s] * e;
      for (let c = 0; c !== e; ++c) i[r++] = l[a + c];
    }
    return i;
  }
  function jh(l, e, t, n) {
    let i = 1, s = l[0];
    for (; s !== void 0 && s[n] === void 0; ) s = l[i++];
    if (s === void 0) return;
    let r = s[n];
    if (r !== void 0) if (Array.isArray(r)) do
      r = s[n], r !== void 0 && (e.push(s.time), t.push.apply(t, r)), s = l[i++];
    while (s !== void 0);
    else if (r.toArray !== void 0) do
      r = s[n], r !== void 0 && (e.push(s.time), r.toArray(t, t.length)), s = l[i++];
    while (s !== void 0);
    else do
      r = s[n], r !== void 0 && (e.push(s.time), t.push(r)), s = l[i++];
    while (s !== void 0);
  }
  function yS(l, e, t, n, i = 30) {
    const s = l.clone();
    s.name = e;
    const r = [];
    for (let c = 0; c < s.tracks.length; ++c) {
      const u = s.tracks[c], p = u.getValueSize(), f = [], m = [];
      for (let v = 0; v < u.times.length; ++v) {
        const b = u.times[v] * i;
        if (!(b < t || b >= n)) {
          f.push(u.times[v]);
          for (let _ = 0; _ < p; ++_) m.push(u.values[v * p + _]);
        }
      }
      f.length !== 0 && (u.times = ss(f, u.times.constructor), u.values = ss(m, u.values.constructor), r.push(u));
    }
    s.tracks = r;
    let a = 1 / 0;
    for (let c = 0; c < s.tracks.length; ++c) a > s.tracks[c].times[0] && (a = s.tracks[c].times[0]);
    for (let c = 0; c < s.tracks.length; ++c) s.tracks[c].shift(-1 * a);
    return s.resetDuration(), s;
  }
  function wS(l, e = 0, t = l, n = 30) {
    n <= 0 && (n = 30);
    const i = t.tracks.length, s = e / n;
    for (let r = 0; r < i; ++r) {
      const a = t.tracks[r], c = a.ValueTypeName;
      if (c === "bool" || c === "string") continue;
      const u = l.tracks.find(function(w) {
        return w.name === a.name && w.ValueTypeName === c;
      });
      if (u === void 0) continue;
      let p = 0;
      const f = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = f / 3);
      let m = 0;
      const v = u.getValueSize();
      u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = v / 3);
      const b = a.times.length - 1;
      let _;
      if (s <= a.times[0]) {
        const w = p, S = f - p;
        _ = _n(a.values, w, S);
      } else if (s >= a.times[b]) {
        const w = b * f + p, S = w + f - p;
        _ = _n(a.values, w, S);
      } else {
        const w = a.createInterpolant(), S = p, y = f - p;
        w.evaluate(s), _ = _n(w.resultBuffer, S, y);
      }
      c === "quaternion" && new xt().fromArray(_).normalize().conjugate().toArray(_);
      const x = u.times.length;
      for (let w = 0; w < x; ++w) {
        const S = w * v + m;
        if (c === "quaternion") xt.multiplyQuaternionsFlat(u.values, S, _, 0, u.values, S);
        else {
          const y = v - m * 2;
          for (let M = 0; M < y; ++M) u.values[S + M] -= _[M];
        }
      }
    }
    return l.blendMode = wh, l;
  }
  var MS = Object.freeze({
    __proto__: null,
    arraySlice: _n,
    convertArray: ss,
    flattenJSON: jh,
    getKeyframeOrder: Rm,
    isTypedArray: Xh,
    makeClipAdditive: wS,
    sortedArray: ch,
    subclip: yS
  });
  class vr {
    constructor(e, t, n, i) {
      this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(e) {
      const t = this.parameterPositions;
      let n = this._cachedIndex, i = t[n], s = t[n - 1];
      e: {
        t: {
          let r;
          n: {
            i: if (!(e < i)) {
              for (let a = n + 2; ; ) {
                if (i === void 0) {
                  if (e < s) break i;
                  return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
                }
                if (n === a) break;
                if (s = i, i = t[++n], e < i) break t;
              }
              r = t.length;
              break n;
            }
            if (!(e >= s)) {
              const a = t[1];
              e < a && (n = 2, s = a);
              for (let c = n - 2; ; ) {
                if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (n === c) break;
                if (i = s, s = t[--n - 1], e >= s) break t;
              }
              r = n, n = 0;
              break n;
            }
            break e;
          }
          for (; n < r; ) {
            const a = n + r >>> 1;
            e < t[a] ? r = a : n = a + 1;
          }
          if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
          if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
        }
        this._cachedIndex = n, this.intervalChanged_(n, s, i);
      }
      return this.interpolate_(n, s, e, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, s = e * i;
      for (let r = 0; r !== i; ++r) t[r] = n[s + r];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  }
  class Im extends vr {
    constructor(e, t, n, i) {
      super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
        endingStart: ts,
        endingEnd: ts
      };
    }
    intervalChanged_(e, t, n) {
      const i = this.parameterPositions;
      let s = e - 2, r = e + 1, a = i[s], c = i[r];
      if (a === void 0) switch (this.getSettings_().endingStart) {
        case ns:
          s = e, a = 2 * t - n;
          break;
        case to:
          s = i.length - 2, a = t + i[s] - i[s + 1];
          break;
        default:
          s = e, a = n;
      }
      if (c === void 0) switch (this.getSettings_().endingEnd) {
        case ns:
          r = e, c = 2 * n - t;
          break;
        case to:
          r = 1, c = n + i[1] - i[0];
          break;
        default:
          r = e - 1, c = t;
      }
      const u = (n - t) * 0.5, p = this.valueSize;
      this._weightPrev = u / (t - a), this._weightNext = u / (c - n), this._offsetPrev = s * p, this._offsetNext = r * p;
    }
    interpolate_(e, t, n, i) {
      const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, c = e * a, u = c - a, p = this._offsetPrev, f = this._offsetNext, m = this._weightPrev, v = this._weightNext, b = (n - t) / (i - t), _ = b * b, x = _ * b, w = -m * x + 2 * m * _ - m * b, S = (1 + m) * x + (-1.5 - 2 * m) * _ + (-0.5 + m) * b + 1, y = (-1 - v) * x + (1.5 + v) * _ + 0.5 * b, M = v * x - v * _;
      for (let C = 0; C !== a; ++C) s[C] = w * r[p + C] + S * r[u + C] + y * r[c + C] + M * r[f + C];
      return s;
    }
  }
  class Kh extends vr {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, c = e * a, u = c - a, p = (n - t) / (i - t), f = 1 - p;
      for (let m = 0; m !== a; ++m) s[m] = r[u + m] * f + r[c + m] * p;
      return s;
    }
  }
  class Dm extends vr {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  }
  class Pn {
    constructor(e, t, n, i) {
      if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
      this.name = e, this.times = ss(t, this.TimeBufferType), this.values = ss(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(e) {
      const t = e.constructor;
      let n;
      if (t.toJSON !== this.toJSON) n = t.toJSON(e);
      else {
        n = {
          name: e.name,
          times: ss(e.times, Array),
          values: ss(e.values, Array)
        };
        const i = e.getInterpolation();
        i !== e.DefaultInterpolation && (n.interpolation = i);
      }
      return n.type = e.ValueTypeName, n;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new Dm(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new Kh(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new Im(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case nr:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case us:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case Na:
          t = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (t === void 0) {
        const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
        return console.warn("THREE.KeyframeTrack:", n), this;
      }
      return this.createInterpolant = t, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return nr;
        case this.InterpolantFactoryMethodLinear:
          return us;
        case this.InterpolantFactoryMethodSmooth:
          return Na;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (e !== 0) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
      }
      return this;
    }
    scale(e) {
      if (e !== 1) {
        const t = this.times;
        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
      }
      return this;
    }
    trim(e, t) {
      const n = this.times, i = n.length;
      let s = 0, r = i - 1;
      for (; s !== i && n[s] < e; ) ++s;
      for (; r !== -1 && n[r] > t; ) --r;
      if (++r, s !== 0 || r !== i) {
        s >= r && (r = Math.max(r, 1), s = r - 1);
        const a = this.getValueSize();
        this.times = _n(n, s, r), this.values = _n(this.values, s * a, r * a);
      }
      return this;
    }
    validate() {
      let e = true;
      const t = this.getValueSize();
      t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
      const n = this.times, i = this.values, s = n.length;
      s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
      let r = null;
      for (let a = 0; a !== s; a++) {
        const c = n[a];
        if (typeof c == "number" && isNaN(c)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c), e = false;
          break;
        }
        if (r !== null && r > c) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, r), e = false;
          break;
        }
        r = c;
      }
      if (i !== void 0 && Xh(i)) for (let a = 0, c = i.length; a !== c; ++a) {
        const u = i[a];
        if (isNaN(u)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), e = false;
          break;
        }
      }
      return e;
    }
    optimize() {
      const e = _n(this.times), t = _n(this.values), n = this.getValueSize(), i = this.getInterpolation() === Na, s = e.length - 1;
      let r = 1;
      for (let a = 1; a < s; ++a) {
        let c = false;
        const u = e[a], p = e[a + 1];
        if (u !== p && (a !== 1 || u !== e[0])) if (i) c = true;
        else {
          const f = a * n, m = f - n, v = f + n;
          for (let b = 0; b !== n; ++b) {
            const _ = t[f + b];
            if (_ !== t[m + b] || _ !== t[v + b]) {
              c = true;
              break;
            }
          }
        }
        if (c) {
          if (a !== r) {
            e[r] = e[a];
            const f = a * n, m = r * n;
            for (let v = 0; v !== n; ++v) t[m + v] = t[f + v];
          }
          ++r;
        }
      }
      if (s > 0) {
        e[r] = e[s];
        for (let a = s * n, c = r * n, u = 0; u !== n; ++u) t[c + u] = t[a + u];
        ++r;
      }
      return r !== e.length ? (this.times = _n(e, 0, r), this.values = _n(t, 0, r * n)) : (this.times = e, this.values = t), this;
    }
    clone() {
      const e = _n(this.times, 0), t = _n(this.values, 0), n = this.constructor, i = new n(this.name, e, t);
      return i.createInterpolant = this.createInterpolant, i;
    }
  }
  Pn.prototype.TimeBufferType = Float32Array;
  Pn.prototype.ValueBufferType = Float32Array;
  Pn.prototype.DefaultInterpolation = us;
  class ms extends Pn {
  }
  ms.prototype.ValueTypeName = "bool";
  ms.prototype.ValueBufferType = Array;
  ms.prototype.DefaultInterpolation = nr;
  ms.prototype.InterpolantFactoryMethodLinear = void 0;
  ms.prototype.InterpolantFactoryMethodSmooth = void 0;
  class Yh extends Pn {
  }
  Yh.prototype.ValueTypeName = "color";
  class or extends Pn {
  }
  or.prototype.ValueTypeName = "number";
  class km extends vr {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    interpolate_(e, t, n, i) {
      const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, c = (n - t) / (i - t);
      let u = e * a;
      for (let p = u + a; u !== p; u += 4) xt.slerpFlat(s, 0, r, u - a, r, u, c);
      return s;
    }
  }
  class Li extends Pn {
    InterpolantFactoryMethodLinear(e) {
      return new km(this.times, this.values, this.getValueSize(), e);
    }
  }
  Li.prototype.ValueTypeName = "quaternion";
  Li.prototype.DefaultInterpolation = us;
  Li.prototype.InterpolantFactoryMethodSmooth = void 0;
  class gs extends Pn {
  }
  gs.prototype.ValueTypeName = "string";
  gs.prototype.ValueBufferType = Array;
  gs.prototype.DefaultInterpolation = nr;
  gs.prototype.InterpolantFactoryMethodLinear = void 0;
  gs.prototype.InterpolantFactoryMethodSmooth = void 0;
  class ar extends Pn {
  }
  ar.prototype.ValueTypeName = "vector";
  class lr {
    constructor(e, t = -1, n, i = Ya) {
      this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = dn(), this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
      const t = [], n = e.tracks, i = 1 / (e.fps || 1);
      for (let r = 0, a = n.length; r !== a; ++r) t.push(ES(n[r]).scale(i));
      const s = new this(e.name, e.duration, t, e.blendMode);
      return s.uuid = e.uuid, s;
    }
    static toJSON(e) {
      const t = [], n = e.tracks, i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode
      };
      for (let s = 0, r = n.length; s !== r; ++s) t.push(Pn.toJSON(n[s]));
      return i;
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
      const s = t.length, r = [];
      for (let a = 0; a < s; a++) {
        let c = [], u = [];
        c.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0);
        const p = Rm(c);
        c = ch(c, 1, p), u = ch(u, 1, p), !i && c[0] === 0 && (c.push(s), u.push(u[0])), r.push(new or(".morphTargetInfluences[" + t[a].name + "]", c, u).scale(1 / n));
      }
      return new this(e, -1, r);
    }
    static findByName(e, t) {
      let n = e;
      if (!Array.isArray(e)) {
        const i = e;
        n = i.geometry && i.geometry.animations || i.animations;
      }
      for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
      const i = {}, s = /^([\w-]*?)([\d]+)$/;
      for (let a = 0, c = e.length; a < c; a++) {
        const u = e[a], p = u.name.match(s);
        if (p && p.length > 1) {
          const f = p[1];
          let m = i[f];
          m || (i[f] = m = []), m.push(u);
        }
      }
      const r = [];
      for (const a in i) r.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
      return r;
    }
    static parseAnimation(e, t) {
      if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const n = function(f, m, v, b, _) {
        if (v.length !== 0) {
          const x = [], w = [];
          jh(v, x, w, b), x.length !== 0 && _.push(new f(m, x, w));
        }
      }, i = [], s = e.name || "default", r = e.fps || 30, a = e.blendMode;
      let c = e.length || -1;
      const u = e.hierarchy || [];
      for (let f = 0; f < u.length; f++) {
        const m = u[f].keys;
        if (!(!m || m.length === 0)) if (m[0].morphTargets) {
          const v = {};
          let b;
          for (b = 0; b < m.length; b++) if (m[b].morphTargets) for (let _ = 0; _ < m[b].morphTargets.length; _++) v[m[b].morphTargets[_]] = -1;
          for (const _ in v) {
            const x = [], w = [];
            for (let S = 0; S !== m[b].morphTargets.length; ++S) {
              const y = m[b];
              x.push(y.time), w.push(y.morphTarget === _ ? 1 : 0);
            }
            i.push(new or(".morphTargetInfluence[" + _ + "]", x, w));
          }
          c = v.length * r;
        } else {
          const v = ".bones[" + t[f].name + "]";
          n(ar, v + ".position", m, "pos", i), n(Li, v + ".quaternion", m, "rot", i), n(ar, v + ".scale", m, "scl", i);
        }
      }
      return i.length === 0 ? null : new this(s, c, i, a);
    }
    resetDuration() {
      const e = this.tracks;
      let t = 0;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const s = this.tracks[n];
        t = Math.max(t, s.times[s.times.length - 1]);
      }
      return this.duration = t, this;
    }
    trim() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
      return this;
    }
    validate() {
      let e = true;
      for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
      return e;
    }
    optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this;
    }
    clone() {
      const e = [];
      for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function SS(l) {
    switch (l.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return or;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ar;
      case "color":
        return Yh;
      case "quaternion":
        return Li;
      case "bool":
      case "boolean":
        return ms;
      case "string":
        return gs;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + l);
  }
  function ES(l) {
    if (l.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = SS(l.type);
    if (l.times === void 0) {
      const t = [], n = [];
      jh(l.keys, t, n, "value"), l.times = t, l.values = n;
    }
    return e.parse !== void 0 ? e.parse(l) : new e(l.name, l.times, l.values, l.interpolation);
  }
  const ps = {
    enabled: false,
    files: {},
    add: function(l, e) {
      this.enabled !== false && (this.files[l] = e);
    },
    get: function(l) {
      if (this.enabled !== false) return this.files[l];
    },
    remove: function(l) {
      delete this.files[l];
    },
    clear: function() {
      this.files = {};
    }
  };
  class $h {
    constructor(e, t, n) {
      const i = this;
      let s = false, r = 0, a = 0, c;
      const u = [];
      this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(p) {
        a++, s === false && i.onStart !== void 0 && i.onStart(p, r, a), s = true;
      }, this.itemEnd = function(p) {
        r++, i.onProgress !== void 0 && i.onProgress(p, r, a), r === a && (s = false, i.onLoad !== void 0 && i.onLoad());
      }, this.itemError = function(p) {
        i.onError !== void 0 && i.onError(p);
      }, this.resolveURL = function(p) {
        return c ? c(p) : p;
      }, this.setURLModifier = function(p) {
        return c = p, this;
      }, this.addHandler = function(p, f) {
        return u.push(p, f), this;
      }, this.removeHandler = function(p) {
        const f = u.indexOf(p);
        return f !== -1 && u.splice(f, 2), this;
      }, this.getHandler = function(p) {
        for (let f = 0, m = u.length; f < m; f += 2) {
          const v = u[f], b = u[f + 1];
          if (v.global && (v.lastIndex = 0), v.test(p)) return b;
        }
        return null;
      };
    }
  }
  const Nm = new $h();
  class sn {
    constructor(e) {
      this.manager = e !== void 0 ? e : Nm, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(e, t) {
      const n = this;
      return new Promise(function(i, s) {
        n.load(e, i, t, s);
      });
    }
    parse() {
    }
    setCrossOrigin(e) {
      return this.crossOrigin = e, this;
    }
    setWithCredentials(e) {
      return this.withCredentials = e, this;
    }
    setPath(e) {
      return this.path = e, this;
    }
    setResourcePath(e) {
      return this.resourcePath = e, this;
    }
    setRequestHeader(e) {
      return this.requestHeader = e, this;
    }
  }
  const Jn = {};
  class TS extends Error {
    constructor(e, t) {
      super(e), this.response = t;
    }
  }
  class pn extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const s = ps.get(e);
      if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
      if (Jn[e] !== void 0) {
        Jn[e].push({
          onLoad: t,
          onProgress: n,
          onError: i
        });
        return;
      }
      Jn[e] = [], Jn[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      const r = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin"
      }), a = this.mimeType, c = this.responseType;
      fetch(r).then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u;
          const p = Jn[e], f = u.body.getReader(), m = u.headers.get("Content-Length") || u.headers.get("X-File-Size"), v = m ? parseInt(m) : 0, b = v !== 0;
          let _ = 0;
          const x = new ReadableStream({
            start(w) {
              S();
              function S() {
                f.read().then(({ done: y, value: M }) => {
                  if (y) w.close();
                  else {
                    _ += M.byteLength;
                    const C = new ProgressEvent("progress", {
                      lengthComputable: b,
                      loaded: _,
                      total: v
                    });
                    for (let R = 0, k = p.length; R < k; R++) {
                      const T = p[R];
                      T.onProgress && T.onProgress(C);
                    }
                    w.enqueue(M), S();
                  }
                });
              }
            }
          });
          return new Response(x);
        } else throw new TS(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u);
      }).then((u) => {
        switch (c) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((p) => new DOMParser().parseFromString(p, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a), m = f && f[1] ? f[1].toLowerCase() : void 0, v = new TextDecoder(m);
              return u.arrayBuffer().then((b) => v.decode(b));
            }
        }
      }).then((u) => {
        ps.add(e, u);
        const p = Jn[e];
        delete Jn[e];
        for (let f = 0, m = p.length; f < m; f++) {
          const v = p[f];
          v.onLoad && v.onLoad(u);
        }
      }).catch((u) => {
        const p = Jn[e];
        if (p === void 0) throw this.manager.itemError(e), u;
        delete Jn[e];
        for (let f = 0, m = p.length; f < m; f++) {
          const v = p[f];
          v.onError && v.onError(u);
        }
        this.manager.itemError(e);
      }).finally(() => {
        this.manager.itemEnd(e);
      }), this.manager.itemStart(e);
    }
    setResponseType(e) {
      return this.responseType = e, this;
    }
    setMimeType(e) {
      return this.mimeType = e, this;
    }
  }
  class CS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = new pn(this.manager);
      r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, function(a) {
        try {
          t(s.parse(JSON.parse(a)));
        } catch (c) {
          i ? i(c) : console.error(c), s.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = [];
      for (let n = 0; n < e.length; n++) {
        const i = lr.parse(e[n]);
        t.push(i);
      }
      return t;
    }
  }
  class AS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = [], a = new Uh(), c = new pn(this.manager);
      c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(s.withCredentials);
      let u = 0;
      function p(f) {
        c.load(e[f], function(m) {
          const v = s.parse(m, true);
          r[f] = {
            width: v.width,
            height: v.height,
            format: v.format,
            mipmaps: v.mipmaps
          }, u += 1, u === 6 && (v.mipmapCount === 1 && (a.minFilter = yt), a.image = r, a.format = v.format, a.needsUpdate = true, t && t(a));
        }, n, i);
      }
      if (Array.isArray(e)) for (let f = 0, m = e.length; f < m; ++f) p(f);
      else c.load(e, function(f) {
        const m = s.parse(f, true);
        if (m.isCubemap) {
          const v = m.mipmaps.length / m.mipmapCount;
          for (let b = 0; b < v; b++) {
            r[b] = {
              mipmaps: []
            };
            for (let _ = 0; _ < m.mipmapCount; _++) r[b].mipmaps.push(m.mipmaps[b * m.mipmapCount + _]), r[b].format = m.format, r[b].width = m.width, r[b].height = m.height;
          }
          a.image = r;
        } else a.image.width = m.width, a.image.height = m.height, a.mipmaps = m.mipmaps;
        m.mipmapCount === 1 && (a.minFilter = yt), a.format = m.format, a.needsUpdate = true, t && t(a);
      }, n, i);
      return a;
    }
  }
  class co extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const s = this, r = ps.get(e);
      if (r !== void 0) return s.manager.itemStart(e), setTimeout(function() {
        t && t(r), s.manager.itemEnd(e);
      }, 0), r;
      const a = so("img");
      function c() {
        p(), ps.add(e, this), t && t(this), s.manager.itemEnd(e);
      }
      function u(f) {
        p(), i && i(f), s.manager.itemError(e), s.manager.itemEnd(e);
      }
      function p() {
        a.removeEventListener("load", c, false), a.removeEventListener("error", u, false);
      }
      return a.addEventListener("load", c, false), a.addEventListener("error", u, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
    }
  }
  class PS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = new go(), r = new co(this.manager);
      r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
      let a = 0;
      function c(u) {
        r.load(e[u], function(p) {
          s.images[u] = p, a++, a === 6 && (s.needsUpdate = true, t && t(s));
        }, void 0, i);
      }
      for (let u = 0; u < e.length; ++u) c(u);
      return s;
    }
  }
  class LS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = new Js(), a = new pn(this.manager);
      return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(c) {
        const u = s.parse(c);
        u && (u.image !== void 0 ? r.image = u.image : u.data !== void 0 && (r.image.width = u.width, r.image.height = u.height, r.image.data = u.data), r.wrapS = u.wrapS !== void 0 ? u.wrapS : Xt, r.wrapT = u.wrapT !== void 0 ? u.wrapT : Xt, r.magFilter = u.magFilter !== void 0 ? u.magFilter : yt, r.minFilter = u.minFilter !== void 0 ? u.minFilter : yt, r.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.encoding !== void 0 && (r.encoding = u.encoding), u.flipY !== void 0 && (r.flipY = u.flipY), u.format !== void 0 && (r.format = u.format), u.type !== void 0 && (r.type = u.type), u.mipmaps !== void 0 && (r.mipmaps = u.mipmaps, r.minFilter = Fn), u.mipmapCount === 1 && (r.minFilter = yt), u.generateMipmaps !== void 0 && (r.generateMipmaps = u.generateMipmaps), r.needsUpdate = true, t && t(r, u));
      }, n, i), r;
    }
  }
  class Zh extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = new Mt(), r = new co(this.manager);
      return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(e, function(a) {
        s.image = a, s.needsUpdate = true, t !== void 0 && t(s);
      }, n, i), s;
    }
  }
  class Di extends rt {
    constructor(e, t = 1) {
      super(), this.isLight = true, this.type = "Light", this.color = new we(e), this.intensity = t;
    }
    dispose() {
    }
    copy(e, t) {
      return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
    }
  }
  class Om extends Di {
    constructor(e, t, n) {
      super(e, n), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(rt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new we(t);
    }
    copy(e, t) {
      return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
    }
  }
  const mc = new ze(), mp = new P(), gp = new P();
  class Jh {
    constructor(e) {
      this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new te(512, 512), this.map = null, this.mapPass = null, this.matrix = new ze(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Qa(), this._frameExtents = new te(1, 1), this._viewportCount = 1, this._viewports = [
        new ft(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      const t = this.camera, n = this.matrix;
      mp.setFromMatrixPosition(e.matrixWorld), t.position.copy(mp), gp.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(gp), t.updateMatrixWorld(), mc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mc), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(mc);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e = {};
      return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
    }
  }
  class RS extends Jh {
    constructor() {
      super(new Ft(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
    }
    updateMatrices(e) {
      const t = this.camera, n = io * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
      (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), this.focus = e.focus, this;
    }
  }
  class Qh extends Di {
    constructor(e, t, n = 0, i = Math.PI / 3, s = 0, r = 2) {
      super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(rt.DEFAULT_UP), this.updateMatrix(), this.target = new rt(), this.distance = n, this.angle = i, this.penumbra = s, this.decay = r, this.map = null, this.shadow = new RS();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  const vp = new ze(), Hr = new P(), gc = new P();
  class IS extends Jh {
    constructor() {
      super(new Ft(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new te(4, 2), this._viewportCount = 6, this._viewports = [
        new ft(2, 1, 1, 1),
        new ft(0, 1, 1, 1),
        new ft(3, 1, 1, 1),
        new ft(1, 1, 1, 1),
        new ft(3, 0, 1, 1),
        new ft(1, 0, 1, 1)
      ], this._cubeDirections = [
        new P(1, 0, 0),
        new P(-1, 0, 0),
        new P(0, 0, 1),
        new P(0, 0, -1),
        new P(0, 1, 0),
        new P(0, -1, 0)
      ], this._cubeUps = [
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 1, 0),
        new P(0, 0, 1),
        new P(0, 0, -1)
      ];
    }
    updateMatrices(e, t = 0) {
      const n = this.camera, i = this.matrix, s = e.distance || n.far;
      s !== n.far && (n.far = s, n.updateProjectionMatrix()), Hr.setFromMatrixPosition(e.matrixWorld), n.position.copy(Hr), gc.copy(n.position), gc.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(gc), n.updateMatrixWorld(), i.makeTranslation(-Hr.x, -Hr.y, -Hr.z), vp.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vp);
    }
  }
  class eu extends Di {
    constructor(e, t, n = 0, i = 2) {
      super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new IS();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
    }
  }
  class DS extends Jh {
    constructor() {
      super(new vo(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
    }
  }
  class ll extends Di {
    constructor(e, t) {
      super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(rt.DEFAULT_UP), this.updateMatrix(), this.target = new rt(), this.shadow = new DS();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
    }
  }
  class tu extends Di {
    constructor(e, t) {
      super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
    }
  }
  class Fm extends Di {
    constructor(e, t, n = 10, i = 10) {
      super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = n, this.height = i;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(e) {
      this.intensity = e / (this.width * this.height * Math.PI);
    }
    copy(e) {
      return super.copy(e), this.width = e.width, this.height = e.height, this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.width = this.width, t.object.height = this.height, t;
    }
  }
  class Bm {
    constructor() {
      this.isSphericalHarmonics3 = true, this.coefficients = [];
      for (let e = 0; e < 9; e++) this.coefficients.push(new P());
    }
    set(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
      return this;
    }
    zero() {
      for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
      return this;
    }
    getAt(e, t) {
      const n = e.x, i = e.y, s = e.z, r = this.coefficients;
      return t.copy(r[0]).multiplyScalar(0.282095), t.addScaledVector(r[1], 0.488603 * i), t.addScaledVector(r[2], 0.488603 * s), t.addScaledVector(r[3], 0.488603 * n), t.addScaledVector(r[4], 1.092548 * (n * i)), t.addScaledVector(r[5], 1.092548 * (i * s)), t.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(r[7], 1.092548 * (n * s)), t.addScaledVector(r[8], 0.546274 * (n * n - i * i)), t;
    }
    getIrradianceAt(e, t) {
      const n = e.x, i = e.y, s = e.z, r = this.coefficients;
      return t.copy(r[0]).multiplyScalar(0.886227), t.addScaledVector(r[1], 2 * 0.511664 * i), t.addScaledVector(r[2], 2 * 0.511664 * s), t.addScaledVector(r[3], 2 * 0.511664 * n), t.addScaledVector(r[4], 2 * 0.429043 * n * i), t.addScaledVector(r[5], 2 * 0.429043 * i * s), t.addScaledVector(r[6], 0.743125 * s * s - 0.247708), t.addScaledVector(r[7], 2 * 0.429043 * n * s), t.addScaledVector(r[8], 0.429043 * (n * n - i * i)), t;
    }
    add(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
      return this;
    }
    addScaledSH(e, t) {
      for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
      return this;
    }
    scale(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
      return this;
    }
    lerp(e, t) {
      for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
      return this;
    }
    equals(e) {
      for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
      return true;
    }
    copy(e) {
      return this.set(e.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
      return this;
    }
    toArray(e = [], t = 0) {
      const n = this.coefficients;
      for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
      return e;
    }
    static getBasisAt(e, t) {
      const n = e.x, i = e.y, s = e.z;
      t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * s, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = 0.546274 * (n * n - i * i);
    }
  }
  class cl extends Di {
    constructor(e = new Bm(), t = 1) {
      super(void 0, t), this.isLightProbe = true, this.sh = e;
    }
    copy(e) {
      return super.copy(e), this.sh.copy(e.sh), this;
    }
    fromJSON(e) {
      return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.object.sh = this.sh.toArray(), t;
    }
  }
  class hl extends sn {
    constructor(e) {
      super(e), this.textures = {};
    }
    load(e, t, n, i) {
      const s = this, r = new pn(s.manager);
      r.setPath(s.path), r.setRequestHeader(s.requestHeader), r.setWithCredentials(s.withCredentials), r.load(e, function(a) {
        try {
          t(s.parse(JSON.parse(a)));
        } catch (c) {
          i ? i(c) : console.error(c), s.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = this.textures;
      function n(s) {
        return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
      }
      const i = hl.createMaterialFromType(e.type);
      if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new we().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) {
        const r = e.uniforms[s];
        switch (i.uniforms[s] = {}, r.type) {
          case "t":
            i.uniforms[s].value = n(r.value);
            break;
          case "c":
            i.uniforms[s].value = new we().setHex(r.value);
            break;
          case "v2":
            i.uniforms[s].value = new te().fromArray(r.value);
            break;
          case "v3":
            i.uniforms[s].value = new P().fromArray(r.value);
            break;
          case "v4":
            i.uniforms[s].value = new ft().fromArray(r.value);
            break;
          case "m3":
            i.uniforms[s].value = new nn().fromArray(r.value);
            break;
          case "m4":
            i.uniforms[s].value = new ze().fromArray(r.value);
            break;
          default:
            i.uniforms[s].value = r.value;
        }
      }
      if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) i.extensions[s] = e.extensions[s];
      if (e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
        let s = e.normalScale;
        Array.isArray(s) === false && (s = [
          s,
          s
        ]), i.normalScale = new te().fromArray(s);
      }
      return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new te().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
    }
    setTextures(e) {
      return this.textures = e, this;
    }
    static createMaterialFromType(e) {
      const t = {
        ShadowMaterial: Mm,
        SpriteMaterial: kh,
        RawShaderMaterial: Sm,
        ShaderMaterial: Un,
        PointsMaterial: sl,
        MeshPhysicalMaterial: oi,
        MeshStandardMaterial: gr,
        MeshPhongMaterial: Em,
        MeshToonMaterial: Tm,
        MeshNormalMaterial: Cm,
        MeshLambertMaterial: Am,
        MeshDepthMaterial: Lh,
        MeshDistanceMaterial: Rh,
        MeshBasicMaterial: $t,
        MeshMatcapMaterial: Pm,
        LineDashedMaterial: Lm,
        LineBasicMaterial: Zt,
        Material: Bt
      };
      return new t[e]();
    }
  }
  class cr {
    static decodeText(e) {
      if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
      let t = "";
      for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
      try {
        return decodeURIComponent(escape(t));
      } catch {
        return t;
      }
    }
    static extractUrlBase(e) {
      const t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
    }
  }
  class Um extends Xe {
    constructor() {
      super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(e) {
      return super.copy(e), this.instanceCount = e.instanceCount, this;
    }
    toJSON() {
      const e = super.toJSON();
      return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e;
    }
  }
  class zm extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = new pn(s.manager);
      r.setPath(s.path), r.setRequestHeader(s.requestHeader), r.setWithCredentials(s.withCredentials), r.load(e, function(a) {
        try {
          t(s.parse(JSON.parse(a)));
        } catch (c) {
          i ? i(c) : console.error(c), s.manager.itemError(e);
        }
      }, n, i);
    }
    parse(e) {
      const t = {}, n = {};
      function i(v, b) {
        if (t[b] !== void 0) return t[b];
        const x = v.interleavedBuffers[b], w = s(v, x.buffer), S = js(x.type, w), y = new _o(S, x.stride);
        return y.uuid = x.uuid, t[b] = y, y;
      }
      function s(v, b) {
        if (n[b] !== void 0) return n[b];
        const x = v.arrayBuffers[b], w = new Uint32Array(x).buffer;
        return n[b] = w, w;
      }
      const r = e.isInstancedBufferGeometry ? new Um() : new Xe(), a = e.data.index;
      if (a !== void 0) {
        const v = js(a.type, a.array);
        r.setIndex(new ht(v, 1));
      }
      const c = e.data.attributes;
      for (const v in c) {
        const b = c[v];
        let _;
        if (b.isInterleavedBufferAttribute) {
          const x = i(e.data, b.data);
          _ = new Pi(x, b.itemSize, b.offset, b.normalized);
        } else {
          const x = js(b.type, b.array), w = b.isInstancedBufferAttribute ? rr : ht;
          _ = new w(x, b.itemSize, b.normalized);
        }
        b.name !== void 0 && (_.name = b.name), b.usage !== void 0 && _.setUsage(b.usage), b.updateRange !== void 0 && (_.updateRange.offset = b.updateRange.offset, _.updateRange.count = b.updateRange.count), r.setAttribute(v, _);
      }
      const u = e.data.morphAttributes;
      if (u) for (const v in u) {
        const b = u[v], _ = [];
        for (let x = 0, w = b.length; x < w; x++) {
          const S = b[x];
          let y;
          if (S.isInterleavedBufferAttribute) {
            const M = i(e.data, S.data);
            y = new Pi(M, S.itemSize, S.offset, S.normalized);
          } else {
            const M = js(S.type, S.array);
            y = new ht(M, S.itemSize, S.normalized);
          }
          S.name !== void 0 && (y.name = S.name), _.push(y);
        }
        r.morphAttributes[v] = _;
      }
      e.data.morphTargetsRelative && (r.morphTargetsRelative = true);
      const f = e.data.groups || e.data.drawcalls || e.data.offsets;
      if (f !== void 0) for (let v = 0, b = f.length; v !== b; ++v) {
        const _ = f[v];
        r.addGroup(_.start, _.count, _.materialIndex);
      }
      const m = e.data.boundingSphere;
      if (m !== void 0) {
        const v = new P();
        m.center !== void 0 && v.fromArray(m.center), r.boundingSphere = new Ii(v, m.radius);
      }
      return e.name && (r.name = e.name), e.userData && (r.userData = e.userData), r;
    }
  }
  class kS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = this.path === "" ? cr.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || r;
      const a = new pn(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
        let u = null;
        try {
          u = JSON.parse(c);
        } catch (f) {
          i !== void 0 && i(f), console.error("THREE:ObjectLoader: Can't parse " + e + ".", f.message);
          return;
        }
        const p = u.metadata;
        if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry") {
          i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
          return;
        }
        s.parse(u, t);
      }, n, i);
    }
    async loadAsync(e, t) {
      const n = this, i = this.path === "" ? cr.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || i;
      const s = new pn(this.manager);
      s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
      const r = await s.loadAsync(e, t), a = JSON.parse(r), c = a.metadata;
      if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
      return await n.parseAsync(a);
    }
    parse(e, t) {
      const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, i), r = this.parseImages(e.images, function() {
        t !== void 0 && t(u);
      }), a = this.parseTextures(e.textures, r), c = this.parseMaterials(e.materials, a), u = this.parseObject(e.object, s, c, a, n), p = this.parseSkeletons(e.skeletons, u);
      if (this.bindSkeletons(u, p), t !== void 0) {
        let f = false;
        for (const m in r) if (r[m].data instanceof HTMLImageElement) {
          f = true;
          break;
        }
        f === false && t(u);
      }
      return u;
    }
    async parseAsync(e) {
      const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), s = await this.parseImagesAsync(e.images), r = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, r), c = this.parseObject(e.object, i, a, r, t), u = this.parseSkeletons(e.skeletons, c);
      return this.bindSkeletons(c, u), c;
    }
    parseShapes(e) {
      const t = {};
      if (e !== void 0) for (let n = 0, i = e.length; n < i; n++) {
        const s = new cs().fromJSON(e[n]);
        t[s.uuid] = s;
      }
      return t;
    }
    parseSkeletons(e, t) {
      const n = {}, i = {};
      if (t.traverse(function(s) {
        s.isBone && (i[s.uuid] = s);
      }), e !== void 0) for (let s = 0, r = e.length; s < r; s++) {
        const a = new xo().fromJSON(e[s], i);
        n[a.uuid] = a;
      }
      return n;
    }
    parseGeometries(e, t) {
      const n = {};
      if (e !== void 0) {
        const i = new zm();
        for (let s = 0, r = e.length; s < r; s++) {
          let a;
          const c = e[s];
          switch (c.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              a = i.parse(c);
              break;
            default:
              c.type in fp ? a = fp[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`);
          }
          a.uuid = c.uuid, c.name !== void 0 && (a.name = c.name), a.isBufferGeometry === true && c.userData !== void 0 && (a.userData = c.userData), n[c.uuid] = a;
        }
      }
      return n;
    }
    parseMaterials(e, t) {
      const n = {}, i = {};
      if (e !== void 0) {
        const s = new hl();
        s.setTextures(t);
        for (let r = 0, a = e.length; r < a; r++) {
          const c = e[r];
          n[c.uuid] === void 0 && (n[c.uuid] = s.parse(c)), i[c.uuid] = n[c.uuid];
        }
      }
      return i;
    }
    parseAnimations(e) {
      const t = {};
      if (e !== void 0) for (let n = 0; n < e.length; n++) {
        const i = e[n], s = lr.parse(i);
        t[s.uuid] = s;
      }
      return t;
    }
    parseImages(e, t) {
      const n = this, i = {};
      let s;
      function r(c) {
        return n.manager.itemStart(c), s.load(c, function() {
          n.manager.itemEnd(c);
        }, void 0, function() {
          n.manager.itemError(c), n.manager.itemEnd(c);
        });
      }
      function a(c) {
        if (typeof c == "string") {
          const u = c, p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
          return r(p);
        } else return c.data ? {
          data: js(c.type, c.data),
          width: c.width,
          height: c.height
        } : null;
      }
      if (e !== void 0 && e.length > 0) {
        const c = new $h(t);
        s = new co(c), s.setCrossOrigin(this.crossOrigin);
        for (let u = 0, p = e.length; u < p; u++) {
          const f = e[u], m = f.url;
          if (Array.isArray(m)) {
            const v = [];
            for (let b = 0, _ = m.length; b < _; b++) {
              const x = m[b], w = a(x);
              w !== null && (w instanceof HTMLImageElement ? v.push(w) : v.push(new Js(w.data, w.width, w.height)));
            }
            i[f.uuid] = new is(v);
          } else {
            const v = a(f.url);
            i[f.uuid] = new is(v);
          }
        }
      }
      return i;
    }
    async parseImagesAsync(e) {
      const t = this, n = {};
      let i;
      async function s(r) {
        if (typeof r == "string") {
          const a = r, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
          return await i.loadAsync(c);
        } else return r.data ? {
          data: js(r.type, r.data),
          width: r.width,
          height: r.height
        } : null;
      }
      if (e !== void 0 && e.length > 0) {
        i = new co(this.manager), i.setCrossOrigin(this.crossOrigin);
        for (let r = 0, a = e.length; r < a; r++) {
          const c = e[r], u = c.url;
          if (Array.isArray(u)) {
            const p = [];
            for (let f = 0, m = u.length; f < m; f++) {
              const v = u[f], b = await s(v);
              b !== null && (b instanceof HTMLImageElement ? p.push(b) : p.push(new Js(b.data, b.width, b.height)));
            }
            n[c.uuid] = new is(p);
          } else {
            const p = await s(c.url);
            n[c.uuid] = new is(p);
          }
        }
      }
      return n;
    }
    parseTextures(e, t) {
      function n(s, r) {
        return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), r[s]);
      }
      const i = {};
      if (e !== void 0) for (let s = 0, r = e.length; s < r; s++) {
        const a = e[s];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const c = t[a.image], u = c.data;
        let p;
        Array.isArray(u) ? (p = new go(), u.length === 6 && (p.needsUpdate = true)) : (u && u.data ? p = new Js() : p = new Mt(), u && (p.needsUpdate = true)), p.source = c, p.uuid = a.uuid, a.name !== void 0 && (p.name = a.name), a.mapping !== void 0 && (p.mapping = n(a.mapping, NS)), a.offset !== void 0 && p.offset.fromArray(a.offset), a.repeat !== void 0 && p.repeat.fromArray(a.repeat), a.center !== void 0 && p.center.fromArray(a.center), a.rotation !== void 0 && (p.rotation = a.rotation), a.wrap !== void 0 && (p.wrapS = n(a.wrap[0], _p), p.wrapT = n(a.wrap[1], _p)), a.format !== void 0 && (p.format = a.format), a.type !== void 0 && (p.type = a.type), a.encoding !== void 0 && (p.encoding = a.encoding), a.minFilter !== void 0 && (p.minFilter = n(a.minFilter, xp)), a.magFilter !== void 0 && (p.magFilter = n(a.magFilter, xp)), a.anisotropy !== void 0 && (p.anisotropy = a.anisotropy), a.flipY !== void 0 && (p.flipY = a.flipY), a.generateMipmaps !== void 0 && (p.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (p.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (p.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (p.userData = a.userData), i[a.uuid] = p;
      }
      return i;
    }
    parseObject(e, t, n, i, s) {
      let r;
      function a(m) {
        return t[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", m), t[m];
      }
      function c(m) {
        if (m !== void 0) {
          if (Array.isArray(m)) {
            const v = [];
            for (let b = 0, _ = m.length; b < _; b++) {
              const x = m[b];
              n[x] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", x), v.push(n[x]);
            }
            return v;
          }
          return n[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", m), n[m];
        }
      }
      function u(m) {
        return i[m] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", m), i[m];
      }
      let p, f;
      switch (e.type) {
        case "Scene":
          r = new Dh(), e.background !== void 0 && (Number.isInteger(e.background) ? r.background = new we(e.background) : r.background = u(e.background)), e.environment !== void 0 && (r.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? r.fog = new nl(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (r.fog = new tl(e.fog.color, e.fog.density))), e.backgroundBlurriness !== void 0 && (r.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (r.backgroundIntensity = e.backgroundIntensity);
          break;
        case "PerspectiveCamera":
          r = new Ft(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (r.focus = e.focus), e.zoom !== void 0 && (r.zoom = e.zoom), e.filmGauge !== void 0 && (r.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (r.filmOffset = e.filmOffset), e.view !== void 0 && (r.view = Object.assign({}, e.view));
          break;
        case "OrthographicCamera":
          r = new vo(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (r.zoom = e.zoom), e.view !== void 0 && (r.view = Object.assign({}, e.view));
          break;
        case "AmbientLight":
          r = new tu(e.color, e.intensity);
          break;
        case "DirectionalLight":
          r = new ll(e.color, e.intensity);
          break;
        case "PointLight":
          r = new eu(e.color, e.intensity, e.distance, e.decay);
          break;
        case "RectAreaLight":
          r = new Fm(e.color, e.intensity, e.width, e.height);
          break;
        case "SpotLight":
          r = new Qh(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
          break;
        case "HemisphereLight":
          r = new Om(e.color, e.groundColor, e.intensity);
          break;
        case "LightProbe":
          r = new cl().fromJSON(e);
          break;
        case "SkinnedMesh":
          p = a(e.geometry), f = c(e.material), r = new Nh(p, f), e.bindMode !== void 0 && (r.bindMode = e.bindMode), e.bindMatrix !== void 0 && r.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (r.skeleton = e.skeleton);
          break;
        case "Mesh":
          p = a(e.geometry), f = c(e.material), r = new kt(p, f);
          break;
        case "InstancedMesh":
          p = a(e.geometry), f = c(e.material);
          const m = e.count, v = e.instanceMatrix, b = e.instanceColor;
          r = new Oh(p, f, m), r.instanceMatrix = new rr(new Float32Array(v.array), 16), b !== void 0 && (r.instanceColor = new rr(new Float32Array(b.array), b.itemSize));
          break;
        case "LOD":
          r = new dm();
          break;
        case "Line":
          r = new si(a(e.geometry), c(e.material));
          break;
        case "LineLoop":
          r = new Fh(a(e.geometry), c(e.material));
          break;
        case "LineSegments":
          r = new Cn(a(e.geometry), c(e.material));
          break;
        case "PointCloud":
        case "Points":
          r = new Bh(a(e.geometry), c(e.material));
          break;
        case "Sprite":
          r = new um(c(e.material));
          break;
        case "Group":
          r = new ni();
          break;
        case "Bone":
          r = new il();
          break;
        default:
          r = new rt();
      }
      if (r.uuid = e.uuid, e.name !== void 0 && (r.name = e.name), e.matrix !== void 0 ? (r.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (r.matrixAutoUpdate = e.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (e.position !== void 0 && r.position.fromArray(e.position), e.rotation !== void 0 && r.rotation.fromArray(e.rotation), e.quaternion !== void 0 && r.quaternion.fromArray(e.quaternion), e.scale !== void 0 && r.scale.fromArray(e.scale)), e.castShadow !== void 0 && (r.castShadow = e.castShadow), e.receiveShadow !== void 0 && (r.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (r.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (r.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (r.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && r.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (r.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (r.visible = e.visible), e.frustumCulled !== void 0 && (r.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (r.renderOrder = e.renderOrder), e.userData !== void 0 && (r.userData = e.userData), e.layers !== void 0 && (r.layers.mask = e.layers), e.children !== void 0) {
        const m = e.children;
        for (let v = 0; v < m.length; v++) r.add(this.parseObject(m[v], t, n, i, s));
      }
      if (e.animations !== void 0) {
        const m = e.animations;
        for (let v = 0; v < m.length; v++) {
          const b = m[v];
          r.animations.push(s[b]);
        }
      }
      if (e.type === "LOD") {
        e.autoUpdate !== void 0 && (r.autoUpdate = e.autoUpdate);
        const m = e.levels;
        for (let v = 0; v < m.length; v++) {
          const b = m[v], _ = r.getObjectByProperty("uuid", b.object);
          _ !== void 0 && r.addLevel(_, b.distance, b.hysteresis);
        }
      }
      return r;
    }
    bindSkeletons(e, t) {
      Object.keys(t).length !== 0 && e.traverse(function(n) {
        if (n.isSkinnedMesh === true && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
        }
      });
    }
  }
  const NS = {
    UVMapping: ja,
    CubeReflectionMapping: Si,
    CubeRefractionMapping: Ei,
    EquirectangularReflectionMapping: Jr,
    EquirectangularRefractionMapping: Qr,
    CubeUVReflectionMapping: hr
  }, _p = {
    RepeatWrapping: Ti,
    ClampToEdgeWrapping: Xt,
    MirroredRepeatWrapping: er
  }, xp = {
    NearestFilter: Et,
    NearestMipmapNearestFilter: eo,
    NearestMipmapLinearFilter: Zs,
    LinearFilter: yt,
    LinearMipmapNearestFilter: Ka,
    LinearMipmapLinearFilter: Fn
  };
  class Vm extends sn {
    constructor(e) {
      super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
        premultiplyAlpha: "none"
      };
    }
    setOptions(e) {
      return this.options = e, this;
    }
    load(e, t, n, i) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const s = this, r = ps.get(e);
      if (r !== void 0) return s.manager.itemStart(e), setTimeout(function() {
        t && t(r), s.manager.itemEnd(e);
      }, 0), r;
      const a = {};
      a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then(function(c) {
        return c.blob();
      }).then(function(c) {
        return createImageBitmap(c, Object.assign(s.options, {
          colorSpaceConversion: "none"
        }));
      }).then(function(c) {
        ps.add(e, c), t && t(c), s.manager.itemEnd(e);
      }).catch(function(c) {
        i && i(c), s.manager.itemError(e), s.manager.itemEnd(e);
      }), s.manager.itemStart(e);
    }
  }
  let Ma;
  class nu {
    static getContext() {
      return Ma === void 0 && (Ma = new (window.AudioContext || window.webkitAudioContext)()), Ma;
    }
    static setContext(e) {
      Ma = e;
    }
  }
  class OS extends sn {
    constructor(e) {
      super(e);
    }
    load(e, t, n, i) {
      const s = this, r = new pn(this.manager);
      r.setResponseType("arraybuffer"), r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, function(a) {
        try {
          const c = a.slice(0);
          nu.getContext().decodeAudioData(c, function(p) {
            t(p);
          });
        } catch (c) {
          i ? i(c) : console.error(c), s.manager.itemError(e);
        }
      }, n, i);
    }
  }
  class FS extends cl {
    constructor(e, t, n = 1) {
      super(void 0, n), this.isHemisphereLightProbe = true;
      const i = new we().set(e), s = new we().set(t), r = new P(i.r, i.g, i.b), a = new P(s.r, s.g, s.b), c = Math.sqrt(Math.PI), u = c * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(r).add(a).multiplyScalar(c), this.sh.coefficients[1].copy(r).sub(a).multiplyScalar(u);
    }
  }
  class BS extends cl {
    constructor(e, t = 1) {
      super(void 0, t), this.isAmbientLightProbe = true;
      const n = new we().set(e);
      this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  }
  const bp = new ze(), yp = new ze(), qi = new ze();
  class US {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ft(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Ft(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      };
    }
    update(e) {
      const t = this._cache;
      if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, qi.copy(e.projectionMatrix);
        const i = t.eyeSep / 2, s = i * t.near / t.focus, r = t.near * Math.tan(as * t.fov * 0.5) / t.zoom;
        let a, c;
        yp.elements[12] = -i, bp.elements[12] = i, a = -r * t.aspect + s, c = r * t.aspect + s, qi.elements[0] = 2 * t.near / (c - a), qi.elements[8] = (c + a) / (c - a), this.cameraL.projectionMatrix.copy(qi), a = -r * t.aspect - s, c = r * t.aspect - s, qi.elements[0] = 2 * t.near / (c - a), qi.elements[8] = (c + a) / (c - a), this.cameraR.projectionMatrix.copy(qi);
      }
      this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(yp), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(bp);
    }
  }
  class iu {
    constructor(e = true) {
      this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = wp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const t = wp();
        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
      }
      return e;
    }
  }
  function wp() {
    return (typeof performance > "u" ? Date : performance).now();
  }
  const Xi = new P(), Mp = new xt(), zS = new P(), ji = new P();
  class VS extends rt {
    constructor() {
      super(), this.type = "AudioListener", this.context = nu.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new iu();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(e) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e);
      const t = this.context.listener, n = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Xi, Mp, zS), ji.set(0, 0, -1).applyQuaternion(Mp), t.positionX) {
        const i = this.context.currentTime + this.timeDelta;
        t.positionX.linearRampToValueAtTime(Xi.x, i), t.positionY.linearRampToValueAtTime(Xi.y, i), t.positionZ.linearRampToValueAtTime(Xi.z, i), t.forwardX.linearRampToValueAtTime(ji.x, i), t.forwardY.linearRampToValueAtTime(ji.y, i), t.forwardZ.linearRampToValueAtTime(ji.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
      } else t.setPosition(Xi.x, Xi.y, Xi.z), t.setOrientation(ji.x, ji.y, ji.z, n.x, n.y, n.z);
    }
  }
  class Gm extends rt {
    constructor(e) {
      super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
    }
    setMediaElementSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
    }
    setMediaStreamSource(e) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
    }
    setBuffer(e) {
      return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(e = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + e;
      const t = this.context.createBufferSource();
      return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(e) {
      return e || (e = []), this._connected === true ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
    }
    setDetune(e) {
      if (this.detune = e, this.source.detune !== void 0) return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(e) {
      return this.setFilters(e ? [
        e
      ] : []);
    }
    setPlaybackRate(e) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.playbackRate = e, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(e) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.loop = e, this.isPlaying === true && (this.source.loop = this.loop), this;
    }
    setLoopStart(e) {
      return this.loopStart = e, this;
    }
    setLoopEnd(e) {
      return this.loopEnd = e, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
    }
  }
  const Ki = new P(), Sp = new xt(), GS = new P(), Yi = new P();
  class HS extends Gm {
    constructor(e) {
      super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    disconnect() {
      super.disconnect(), this.panner.disconnect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(e) {
      return this.panner.refDistance = e, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(e) {
      return this.panner.rolloffFactor = e, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(e) {
      return this.panner.distanceModel = e, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(e) {
      return this.panner.maxDistance = e, this;
    }
    setDirectionalCone(e, t, n) {
      return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
    }
    updateMatrixWorld(e) {
      if (super.updateMatrixWorld(e), this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(Ki, Sp, GS), Yi.set(0, 0, 1).applyQuaternion(Sp);
      const t = this.panner;
      if (t.positionX) {
        const n = this.context.currentTime + this.listener.timeDelta;
        t.positionX.linearRampToValueAtTime(Ki.x, n), t.positionY.linearRampToValueAtTime(Ki.y, n), t.positionZ.linearRampToValueAtTime(Ki.z, n), t.orientationX.linearRampToValueAtTime(Yi.x, n), t.orientationY.linearRampToValueAtTime(Yi.y, n), t.orientationZ.linearRampToValueAtTime(Yi.z, n);
      } else t.setPosition(Ki.x, Ki.y, Ki.z), t.setOrientation(Yi.x, Yi.y, Yi.z);
    }
  }
  class WS {
    constructor(e, t = 2048) {
      this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let e = 0;
      const t = this.getFrequencyData();
      for (let n = 0; n < t.length; n++) e += t[n];
      return e / t.length;
    }
  }
  class Hm {
    constructor(e, t, n) {
      this.binding = e, this.valueSize = n;
      let i, s, r;
      switch (t) {
        case "quaternion":
          i = this._slerp, s = this._slerpAdditive, r = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          i = this._select, s = this._select, r = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
          break;
        default:
          i = this._lerp, s = this._lerpAdditive, r = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
      }
      this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = r, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(e, t) {
      const n = this.buffer, i = this.valueSize, s = e * i + i;
      let r = this.cumulativeWeight;
      if (r === 0) {
        for (let a = 0; a !== i; ++a) n[s + a] = n[a];
        r = t;
      } else {
        r += t;
        const a = t / r;
        this._mixBufferRegion(n, s, 0, a, i);
      }
      this.cumulativeWeight = r;
    }
    accumulateAdditive(e) {
      const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
    }
    apply(e) {
      const t = this.valueSize, n = this.buffer, i = e * t + t, s = this.cumulativeWeight, r = this.cumulativeWeightAdditive, a = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
        const c = t * this._origIndex;
        this._mixBufferRegion(n, i, c, 1 - s, t);
      }
      r > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
      for (let c = t, u = t + t; c !== u; ++c) if (n[c] !== n[c + t]) {
        a.setValue(n, i);
        break;
      }
    }
    saveOriginalState() {
      const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
      e.getValue(t, i);
      for (let s = n, r = i; s !== r; ++s) t[s] = t[i + s % n];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const e = this.valueSize * 3;
      this.binding.setValue(this.buffer, e);
    }
    _setAdditiveIdentityNumeric() {
      const e = this._addIndex * this.valueSize, t = e + this.valueSize;
      for (let n = e; n < t; n++) this.buffer[n] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
    }
    _select(e, t, n, i, s) {
      if (i >= 0.5) for (let r = 0; r !== s; ++r) e[t + r] = e[n + r];
    }
    _slerp(e, t, n, i) {
      xt.slerpFlat(e, t, e, t, e, n, i);
    }
    _slerpAdditive(e, t, n, i, s) {
      const r = this._workIndex * s;
      xt.multiplyQuaternionsFlat(e, r, e, t, e, n), xt.slerpFlat(e, t, e, t, e, r, i);
    }
    _lerp(e, t, n, i, s) {
      const r = 1 - i;
      for (let a = 0; a !== s; ++a) {
        const c = t + a;
        e[c] = e[c] * r + e[n + a] * i;
      }
    }
    _lerpAdditive(e, t, n, i, s) {
      for (let r = 0; r !== s; ++r) {
        const a = t + r;
        e[a] = e[a] + e[n + r] * i;
      }
    }
  }
  const su = "\\[\\]\\.:\\/", qS = new RegExp("[" + su + "]", "g"), ru = "[^" + su + "]", XS = "[^" + su.replace("\\.", "") + "]", jS = /((?:WC+[\/:])*)/.source.replace("WC", ru), KS = /(WCOD+)?/.source.replace("WCOD", XS), YS = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ru), $S = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ru), ZS = new RegExp("^" + jS + KS + YS + $S + "$"), JS = [
    "material",
    "materials",
    "bones",
    "map"
  ];
  class QS {
    constructor(e, t, n) {
      const i = n || st.parseTrackName(t);
      this._targetGroup = e, this._bindings = e.subscribe_(t, i);
    }
    getValue(e, t) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
      i !== void 0 && i.getValue(e, t);
    }
    setValue(e, t) {
      const n = this._bindings;
      for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t);
    }
    bind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
    }
    unbind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
    }
  }
  class st {
    constructor(e, t, n) {
      this.path = t, this.parsedPath = n || st.parseTrackName(t), this.node = st.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(e, t, n) {
      return e && e.isAnimationObjectGroup ? new st.Composite(e, t, n) : new st(e, t, n);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(qS, "");
    }
    static parseTrackName(e) {
      const t = ZS.exec(e);
      if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6]
      }, i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (i !== void 0 && i !== -1) {
        const s = n.nodeName.substring(i + 1);
        JS.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s);
      }
      if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
      return n;
    }
    static findNode(e, t) {
      if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
      if (e.skeleton) {
        const n = e.skeleton.getBoneByName(t);
        if (n !== void 0) return n;
      }
      if (e.children) {
        const n = function(s) {
          for (let r = 0; r < s.length; r++) {
            const a = s[r];
            if (a.name === t || a.uuid === t) return a;
            const c = n(a.children);
            if (c) return c;
          }
          return null;
        }, i = n(e.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      const n = this.resolvedProperty;
      for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node;
      const t = this.parsedPath, n = t.objectName, i = t.propertyName;
      let s = t.propertyIndex;
      if (e || (e = st.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (n) {
        let u = t.objectIndex;
        switch (n) {
          case "materials":
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            e = e.skeleton.bones;
            for (let p = 0; p < e.length; p++) if (e[p].name === u) {
              u = p;
              break;
            }
            break;
          case "map":
            if ("map" in e) {
              e = e.map;
              break;
            }
            if (!e.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!e.material.map) {
              console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
              return;
            }
            e = e.material.map;
            break;
          default:
            if (e[n] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            e = e[n];
        }
        if (u !== void 0) {
          if (e[u] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
            return;
          }
          e = e[u];
        }
      }
      const r = e[i];
      if (r === void 0) {
        const u = t.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + i + " but it wasn't found.", e);
        return;
      }
      let a = this.Versioning.None;
      this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
      let c = this.BindingType.Direct;
      if (s !== void 0) {
        if (i === "morphTargetInfluences") {
          if (!e.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (!e.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
        }
        c = this.BindingType.ArrayElement, this.resolvedProperty = r, this.propertyIndex = s;
      } else r.fromArray !== void 0 && r.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = r) : Array.isArray(r) ? (c = this.BindingType.EntireArray, this.resolvedProperty = r) : this.propertyName = i;
      this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][a];
    }
    unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
  }
  st.Composite = QS;
  st.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  st.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  st.prototype.GetterByBindingType = [
    st.prototype._getValue_direct,
    st.prototype._getValue_array,
    st.prototype._getValue_arrayElement,
    st.prototype._getValue_toArray
  ];
  st.prototype.SetterByBindingTypeAndVersioning = [
    [
      st.prototype._setValue_direct,
      st.prototype._setValue_direct_setNeedsUpdate,
      st.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      st.prototype._setValue_array,
      st.prototype._setValue_array_setNeedsUpdate,
      st.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      st.prototype._setValue_arrayElement,
      st.prototype._setValue_arrayElement_setNeedsUpdate,
      st.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      st.prototype._setValue_fromArray,
      st.prototype._setValue_fromArray_setNeedsUpdate,
      st.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  class e1 {
    constructor() {
      this.isAnimationObjectGroup = true, this.uuid = dn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const e = {};
      this._indicesByUUID = e;
      for (let n = 0, i = arguments.length; n !== i; ++n) e[arguments[n].uuid] = n;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const t = this;
      this.stats = {
        objects: {
          get total() {
            return t._objects.length;
          },
          get inUse() {
            return this.total - t.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return t._bindings.length;
        }
      };
    }
    add() {
      const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, s = this._bindings, r = s.length;
      let a, c = e.length, u = this.nCachedObjects_;
      for (let p = 0, f = arguments.length; p !== f; ++p) {
        const m = arguments[p], v = m.uuid;
        let b = t[v];
        if (b === void 0) {
          b = c++, t[v] = b, e.push(m);
          for (let _ = 0, x = r; _ !== x; ++_) s[_].push(new st(m, n[_], i[_]));
        } else if (b < u) {
          a = e[b];
          const _ = --u, x = e[_];
          t[x.uuid] = b, e[b] = x, t[v] = _, e[_] = m;
          for (let w = 0, S = r; w !== S; ++w) {
            const y = s[w], M = y[_];
            let C = y[b];
            y[b] = M, C === void 0 && (C = new st(m, n[w], i[w])), y[_] = C;
          }
        } else e[b] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = u;
    }
    remove() {
      const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
      let s = this.nCachedObjects_;
      for (let r = 0, a = arguments.length; r !== a; ++r) {
        const c = arguments[r], u = c.uuid, p = t[u];
        if (p !== void 0 && p >= s) {
          const f = s++, m = e[f];
          t[m.uuid] = p, e[p] = m, t[u] = f, e[f] = c;
          for (let v = 0, b = i; v !== b; ++v) {
            const _ = n[v], x = _[f], w = _[p];
            _[p] = x, _[f] = w;
          }
        }
      }
      this.nCachedObjects_ = s;
    }
    uncache() {
      const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
      let s = this.nCachedObjects_, r = e.length;
      for (let a = 0, c = arguments.length; a !== c; ++a) {
        const u = arguments[a], p = u.uuid, f = t[p];
        if (f !== void 0) if (delete t[p], f < s) {
          const m = --s, v = e[m], b = --r, _ = e[b];
          t[v.uuid] = f, e[f] = v, t[_.uuid] = m, e[m] = _, e.pop();
          for (let x = 0, w = i; x !== w; ++x) {
            const S = n[x], y = S[m], M = S[b];
            S[f] = y, S[m] = M, S.pop();
          }
        } else {
          const m = --r, v = e[m];
          m > 0 && (t[v.uuid] = f), e[f] = v, e.pop();
          for (let b = 0, _ = i; b !== _; ++b) {
            const x = n[b];
            x[f] = x[m], x.pop();
          }
        }
      }
      this.nCachedObjects_ = s;
    }
    subscribe_(e, t) {
      const n = this._bindingsIndicesByPath;
      let i = n[e];
      const s = this._bindings;
      if (i !== void 0) return s[i];
      const r = this._paths, a = this._parsedPaths, c = this._objects, u = c.length, p = this.nCachedObjects_, f = new Array(u);
      i = s.length, n[e] = i, r.push(e), a.push(t), s.push(f);
      for (let m = p, v = c.length; m !== v; ++m) {
        const b = c[m];
        f[m] = new st(b, e, t);
      }
      return f;
    }
    unsubscribe_(e) {
      const t = this._bindingsIndicesByPath, n = t[e];
      if (n !== void 0) {
        const i = this._paths, s = this._parsedPaths, r = this._bindings, a = r.length - 1, c = r[a], u = e[a];
        t[u] = n, r[n] = c, r.pop(), s[n] = s[a], s.pop(), i[n] = i[a], i.pop();
      }
    }
  }
  class t1 {
    constructor(e, t, n = null, i = t.blendMode) {
      this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
      const s = t.tracks, r = s.length, a = new Array(r), c = {
        endingStart: ts,
        endingEnd: ts
      };
      for (let u = 0; u !== r; ++u) {
        const p = s[u].createInterpolant(null);
        a[u] = p, p.settings = c;
      }
      this._interpolantSettings = c, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = zf, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(e) {
      return this._startTime = e, this;
    }
    setLoop(e, t) {
      return this.loop = e, this.repetitions = t, this;
    }
    setEffectiveWeight(e) {
      return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(e) {
      return this._scheduleFading(e, 0, 1);
    }
    fadeOut(e) {
      return this._scheduleFading(e, 1, 0);
    }
    crossFadeFrom(e, t, n) {
      if (e.fadeOut(t), this.fadeIn(t), n) {
        const i = this._clip.duration, s = e._clip.duration, r = s / i, a = i / s;
        e.warp(1, r, t), this.warp(a, 1, t);
      }
      return this;
    }
    crossFadeTo(e, t, n) {
      return e.crossFadeFrom(this, t, n);
    }
    stopFading() {
      const e = this._weightInterpolant;
      return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    setEffectiveTimeScale(e) {
      return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(e) {
      return this.timeScale = this._clip.duration / e, this.stopWarping();
    }
    syncWith(e) {
      return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
    }
    halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e);
    }
    warp(e, t, n) {
      const i = this._mixer, s = i.time, r = this.timeScale;
      let a = this._timeScaleInterpolant;
      a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
      const c = a.parameterPositions, u = a.sampleValues;
      return c[0] = s, c[1] = s + n, u[0] = e / r, u[1] = t / r, this;
    }
    stopWarping() {
      const e = this._timeScaleInterpolant;
      return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(e, t, n, i) {
      if (!this.enabled) {
        this._updateWeight(e);
        return;
      }
      const s = this._startTime;
      if (s !== null) {
        const c = (e - s) * n;
        c < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * c);
      }
      t *= this._updateTimeScale(e);
      const r = this._updateTime(t), a = this._updateWeight(e);
      if (a > 0) {
        const c = this._interpolants, u = this._propertyBindings;
        switch (this.blendMode) {
          case wh:
            for (let p = 0, f = c.length; p !== f; ++p) c[p].evaluate(r), u[p].accumulateAdditive(a);
            break;
          case Ya:
          default:
            for (let p = 0, f = c.length; p !== f; ++p) c[p].evaluate(r), u[p].accumulate(i, a);
        }
      }
    }
    _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
        t = this.weight;
        const n = this._weightInterpolant;
        if (n !== null) {
          const i = n.evaluate(e)[0];
          t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = t, t;
    }
    _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
        t = this.timeScale;
        const n = this._timeScaleInterpolant;
        if (n !== null) {
          const i = n.evaluate(e)[0];
          t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = true : this.timeScale = t);
        }
      }
      return this._effectiveTimeScale = t, t;
    }
    _updateTime(e) {
      const t = this._clip.duration, n = this.loop;
      let i = this.time + e, s = this._loopCount;
      const r = n === Vf;
      if (e === 0) return s === -1 ? i : r && (s & 1) === 1 ? t - i : i;
      if (n === Uf) {
        s === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (i >= t) i = t;
          else if (i < 0) i = 0;
          else {
            this.time = i;
            break e;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1
          });
        }
      } else {
        if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(true, this.repetitions === 0, r)) : this._setEndings(this.repetitions === 0, true, r)), i >= t || i < 0) {
          const a = Math.floor(i / t);
          i -= t * a, s += Math.abs(a);
          const c = this.repetitions - s;
          if (c <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
          else {
            if (c === 1) {
              const u = e < 0;
              this._setEndings(u, !u, r);
            } else this._setEndings(false, false, r);
            this._loopCount = s, this.time = i, this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a
            });
          }
        } else this.time = i;
        if (r && (s & 1) === 1) return t - i;
      }
      return i;
    }
    _setEndings(e, t, n) {
      const i = this._interpolantSettings;
      n ? (i.endingStart = ns, i.endingEnd = ns) : (e ? i.endingStart = this.zeroSlopeAtStart ? ns : ts : i.endingStart = to, t ? i.endingEnd = this.zeroSlopeAtEnd ? ns : ts : i.endingEnd = to);
    }
    _scheduleFading(e, t, n) {
      const i = this._mixer, s = i.time;
      let r = this._weightInterpolant;
      r === null && (r = i._lendControlInterpolant(), this._weightInterpolant = r);
      const a = r.parameterPositions, c = r.sampleValues;
      return a[0] = s, c[0] = t, a[1] = s + e, c[1] = n, this;
    }
  }
  const n1 = new Float32Array(1);
  class Wm extends zn {
    constructor(e) {
      super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(e, t) {
      const n = e._localRoot || this._root, i = e._clip.tracks, s = i.length, r = e._propertyBindings, a = e._interpolants, c = n.uuid, u = this._bindingsByRootAndName;
      let p = u[c];
      p === void 0 && (p = {}, u[c] = p);
      for (let f = 0; f !== s; ++f) {
        const m = i[f], v = m.name;
        let b = p[v];
        if (b !== void 0) ++b.referenceCount, r[f] = b;
        else {
          if (b = r[f], b !== void 0) {
            b._cacheIndex === null && (++b.referenceCount, this._addInactiveBinding(b, c, v));
            continue;
          }
          const _ = t && t._propertyBindings[f].binding.parsedPath;
          b = new Hm(st.create(n, v, _), m.ValueTypeName, m.getValueSize()), ++b.referenceCount, this._addInactiveBinding(b, c, v), r[f] = b;
        }
        a[f].resultBuffer = b.buffer;
      }
    }
    _activateAction(e) {
      if (!this._isActiveAction(e)) {
        if (e._cacheIndex === null) {
          const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, s = this._actionsByClip[i];
          this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, i, n);
        }
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
          const s = t[n];
          s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
        }
        this._lendAction(e);
      }
    }
    _deactivateAction(e) {
      if (this._isActiveAction(e)) {
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
          const s = t[n];
          --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
        }
        this._takeBackAction(e);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e = this;
      this.stats = {
        actions: {
          get total() {
            return e._actions.length;
          },
          get inUse() {
            return e._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return e._bindings.length;
          },
          get inUse() {
            return e._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return e._controlInterpolants.length;
          },
          get inUse() {
            return e._nActiveControlInterpolants;
          }
        }
      };
    }
    _isActiveAction(e) {
      const t = e._cacheIndex;
      return t !== null && t < this._nActiveActions;
    }
    _addInactiveAction(e, t, n) {
      const i = this._actions, s = this._actionsByClip;
      let r = s[t];
      if (r === void 0) r = {
        knownActions: [
          e
        ],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = r;
      else {
        const a = r.knownActions;
        e._byClipCacheIndex = a.length, a.push(e);
      }
      e._cacheIndex = i.length, i.push(e), r.actionByRoot[n] = e;
    }
    _removeInactiveAction(e) {
      const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
      n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
      const s = e._clip.uuid, r = this._actionsByClip, a = r[s], c = a.knownActions, u = c[c.length - 1], p = e._byClipCacheIndex;
      u._byClipCacheIndex = p, c[p] = u, c.pop(), e._byClipCacheIndex = null;
      const f = a.actionByRoot, m = (e._localRoot || this._root).uuid;
      delete f[m], c.length === 0 && delete r[s], this._removeInactiveBindingsForAction(e);
    }
    _removeInactiveBindingsForAction(e) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = t[n];
        --s.referenceCount === 0 && this._removeInactiveBinding(s);
      }
    }
    _lendAction(e) {
      const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s;
    }
    _takeBackAction(e) {
      const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s;
    }
    _addInactiveBinding(e, t, n) {
      const i = this._bindingsByRootAndName, s = this._bindings;
      let r = i[t];
      r === void 0 && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = s.length, s.push(e);
    }
    _removeInactiveBinding(e) {
      const t = this._bindings, n = e.binding, i = n.rootNode.uuid, s = n.path, r = this._bindingsByRootAndName, a = r[i], c = t[t.length - 1], u = e._cacheIndex;
      c._cacheIndex = u, t[u] = c, t.pop(), delete a[s], Object.keys(a).length === 0 && delete r[i];
    }
    _lendBinding(e) {
      const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s;
    }
    _takeBackBinding(e) {
      const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, s = t[i];
      e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s;
    }
    _lendControlInterpolant() {
      const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
      let n = e[t];
      return n === void 0 && (n = new Kh(new Float32Array(2), new Float32Array(2), 1, n1), n.__cacheIndex = t, e[t] = n), n;
    }
    _takeBackControlInterpolant(e) {
      const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, s = t[i];
      e.__cacheIndex = i, t[i] = e, s.__cacheIndex = n, t[n] = s;
    }
    clipAction(e, t, n) {
      const i = t || this._root, s = i.uuid;
      let r = typeof e == "string" ? lr.findByName(i, e) : e;
      const a = r !== null ? r.uuid : e, c = this._actionsByClip[a];
      let u = null;
      if (n === void 0 && (r !== null ? n = r.blendMode : n = Ya), c !== void 0) {
        const f = c.actionByRoot[s];
        if (f !== void 0 && f.blendMode === n) return f;
        u = c.knownActions[0], r === null && (r = u._clip);
      }
      if (r === null) return null;
      const p = new t1(this, r, t, n);
      return this._bindAction(p, u), this._addInactiveAction(p, a, s), p;
    }
    existingAction(e, t) {
      const n = t || this._root, i = n.uuid, s = typeof e == "string" ? lr.findByName(n, e) : e, r = s ? s.uuid : e, a = this._actionsByClip[r];
      return a !== void 0 && a.actionByRoot[i] || null;
    }
    stopAllAction() {
      const e = this._actions, t = this._nActiveActions;
      for (let n = t - 1; n >= 0; --n) e[n].stop();
      return this;
    }
    update(e) {
      e *= this.timeScale;
      const t = this._actions, n = this._nActiveActions, i = this.time += e, s = Math.sign(e), r = this._accuIndex ^= 1;
      for (let u = 0; u !== n; ++u) t[u]._update(i, e, s, r);
      const a = this._bindings, c = this._nActiveBindings;
      for (let u = 0; u !== c; ++u) a[u].apply(r);
      return this;
    }
    setTime(e) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
      return this.update(e);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(e) {
      const t = this._actions, n = e.uuid, i = this._actionsByClip, s = i[n];
      if (s !== void 0) {
        const r = s.knownActions;
        for (let a = 0, c = r.length; a !== c; ++a) {
          const u = r[a];
          this._deactivateAction(u);
          const p = u._cacheIndex, f = t[t.length - 1];
          u._cacheIndex = null, u._byClipCacheIndex = null, f._cacheIndex = p, t[p] = f, t.pop(), this._removeInactiveBindingsForAction(u);
        }
        delete i[n];
      }
    }
    uncacheRoot(e) {
      const t = e.uuid, n = this._actionsByClip;
      for (const r in n) {
        const a = n[r].actionByRoot, c = a[t];
        c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
      }
      const i = this._bindingsByRootAndName, s = i[t];
      if (s !== void 0) for (const r in s) {
        const a = s[r];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
    uncacheAction(e, t) {
      const n = this.existingAction(e, t);
      n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  }
  class ou {
    constructor(e) {
      this.value = e;
    }
    clone() {
      return new ou(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  }
  let i1 = 0;
  class s1 extends zn {
    constructor() {
      super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", {
        value: i1++
      }), this.name = "", this.usage = no, this.uniforms = [];
    }
    add(e) {
      return this.uniforms.push(e), this;
    }
    remove(e) {
      const t = this.uniforms.indexOf(e);
      return t !== -1 && this.uniforms.splice(t, 1), this;
    }
    setName(e) {
      return this.name = e, this;
    }
    setUsage(e) {
      return this.usage = e, this;
    }
    dispose() {
      return this.dispatchEvent({
        type: "dispose"
      }), this;
    }
    copy(e) {
      this.name = e.name, this.usage = e.usage;
      const t = e.uniforms;
      this.uniforms.length = 0;
      for (let n = 0, i = t.length; n < i; n++) this.uniforms.push(t[n].clone());
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class r1 extends _o {
    constructor(e, t, n = 1) {
      super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = n;
    }
    copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
    }
    clone(e) {
      const t = super.clone(e);
      return t.meshPerAttribute = this.meshPerAttribute, t;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t;
    }
  }
  class o1 {
    constructor(e, t, n, i, s) {
      this.isGLBufferAttribute = true, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = s, this.version = 0;
    }
    set needsUpdate(e) {
      e === true && this.version++;
    }
    setBuffer(e) {
      return this.buffer = e, this;
    }
    setType(e, t) {
      return this.type = e, this.elementSize = t, this;
    }
    setItemSize(e) {
      return this.itemSize = e, this;
    }
    setCount(e) {
      return this.count = e, this;
    }
  }
  class a1 {
    constructor(e, t, n = 0, i = 1 / 0) {
      this.ray = new fo(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Za(), this.params = {
        Mesh: {},
        Line: {
          threshold: 1
        },
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
    }
    set(e, t) {
      this.ray.set(e, t);
    }
    setFromCamera(e, t) {
      t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
    }
    intersectObject(e, t = true, n = []) {
      return hh(e, this, n, t), n.sort(Ep), n;
    }
    intersectObjects(e, t = true, n = []) {
      for (let i = 0, s = e.length; i < s; i++) hh(e[i], this, n, t);
      return n.sort(Ep), n;
    }
  }
  function Ep(l, e) {
    return l.distance - e.distance;
  }
  function hh(l, e, t, n) {
    if (l.layers.test(e.layers) && l.raycast(e, t), n === true) {
      const i = l.children;
      for (let s = 0, r = i.length; s < r; s++) hh(i[s], e, t, true);
    }
  }
  class uh {
    constructor(e = 1, t = 0, n = 0) {
      return this.radius = e, this.phi = t, this.theta = n, this;
    }
    set(e, t, n) {
      return this.radius = e, this.phi = t, this.theta = n, this;
    }
    copy(e) {
      return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
    }
    makeSafe() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
      return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(At(t / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class l1 {
    constructor(e = 1, t = 0, n = 0) {
      return this.radius = e, this.theta = t, this.y = n, this;
    }
    set(e, t, n) {
      return this.radius = e, this.theta = t, this.y = n, this;
    }
    copy(e) {
      return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, n) {
      return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Tp = new te();
  class c1 {
    constructor(e = new te(1 / 0, 1 / 0), t = new te(-1 / 0, -1 / 0)) {
      this.isBox2 = true, this.min = e, this.max = t;
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const n = Tp.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(e) {
      return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    containsPoint(e) {
      return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
    }
    containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
    }
    getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(e) {
      return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return Tp.copy(e).clamp(this.min, this.max).sub(e).length();
    }
    intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this;
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const Cp = new P(), Sa = new P();
  class h1 {
    constructor(e = new P(), t = new P()) {
      this.start = e, this.end = t;
    }
    set(e, t) {
      return this.start.copy(e), this.end.copy(t), this;
    }
    copy(e) {
      return this.start.copy(e.start), this.end.copy(e.end), this;
    }
    getCenter(e) {
      return e.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(e) {
      return e.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(e, t) {
      return this.delta(t).multiplyScalar(e).add(this.start);
    }
    closestPointToPointParameter(e, t) {
      Cp.subVectors(e, this.start), Sa.subVectors(this.end, this.start);
      const n = Sa.dot(Sa);
      let s = Sa.dot(Cp) / n;
      return t && (s = At(s, 0, 1)), s;
    }
    closestPointToPoint(e, t, n) {
      const i = this.closestPointToPointParameter(e, t);
      return this.delta(n).multiplyScalar(i).add(this.start);
    }
    applyMatrix4(e) {
      return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
    }
    equals(e) {
      return e.start.equals(this.start) && e.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Ap = new P();
  class u1 extends rt {
    constructor(e, t) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = t, this.type = "SpotLightHelper";
      const n = new Xe(), i = [
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        1,
        0,
        0,
        0,
        0,
        -1,
        1
      ];
      for (let r = 0, a = 1, c = 32; r < c; r++, a++) {
        const u = r / c * Math.PI * 2, p = a / c * Math.PI * 2;
        i.push(Math.cos(u), Math.sin(u), 1, Math.cos(p), Math.sin(p), 1);
      }
      n.setAttribute("position", new Pe(i, 3));
      const s = new Zt({
        fog: false,
        toneMapped: false
      });
      this.cone = new Cn(n, s), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false);
      const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
      this.cone.scale.set(t, t, e), Ap.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Ap), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  }
  const _i = new P(), Ea = new ze(), vc = new ze();
  class d1 extends Cn {
    constructor(e) {
      const t = qm(e), n = new Xe(), i = [], s = [], r = new we(0, 0, 1), a = new we(0, 1, 0);
      for (let u = 0; u < t.length; u++) {
        const p = t[u];
        p.parent && p.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(r.r, r.g, r.b), s.push(a.r, a.g, a.b));
      }
      n.setAttribute("position", new Pe(i, 3)), n.setAttribute("color", new Pe(s, 3));
      const c = new Zt({
        vertexColors: true,
        depthTest: false,
        depthWrite: false,
        toneMapped: false,
        transparent: true
      });
      super(n, c), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(e) {
      const t = this.bones, n = this.geometry, i = n.getAttribute("position");
      vc.copy(this.root.matrixWorld).invert();
      for (let s = 0, r = 0; s < t.length; s++) {
        const a = t[s];
        a.parent && a.parent.isBone && (Ea.multiplyMatrices(vc, a.matrixWorld), _i.setFromMatrixPosition(Ea), i.setXYZ(r, _i.x, _i.y, _i.z), Ea.multiplyMatrices(vc, a.parent.matrixWorld), _i.setFromMatrixPosition(Ea), i.setXYZ(r + 1, _i.x, _i.y, _i.z), r += 2);
      }
      n.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function qm(l) {
    const e = [];
    l.isBone === true && e.push(l);
    for (let t = 0; t < l.children.length; t++) e.push.apply(e, qm(l.children[t]));
    return e;
  }
  class p1 extends kt {
    constructor(e, t, n) {
      const i = new mr(t, 4, 2), s = new $t({
        wireframe: true,
        fog: false,
        toneMapped: false
      });
      super(i, s), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  }
  const f1 = new P(), Pp = new we(), Lp = new we();
  class m1 extends rt {
    constructor(e, t, n) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, this.type = "HemisphereLightHelper";
      const i = new fr(t);
      i.rotateY(Math.PI * 0.5), this.material = new $t({
        wireframe: true,
        fog: false,
        toneMapped: false
      }), this.color === void 0 && (this.material.vertexColors = true);
      const s = i.getAttribute("position"), r = new Float32Array(s.count * 3);
      i.setAttribute("color", new ht(r, 3)), this.add(new kt(i, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      const e = this.children[0];
      if (this.color !== void 0) this.material.color.set(this.color);
      else {
        const t = e.geometry.getAttribute("color");
        Pp.copy(this.light.color), Lp.copy(this.light.groundColor);
        for (let n = 0, i = t.count; n < i; n++) {
          const s = n < i / 2 ? Pp : Lp;
          t.setXYZ(n, s.r, s.g, s.b);
        }
        t.needsUpdate = true;
      }
      this.light.updateWorldMatrix(true, false), e.lookAt(f1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  }
  class g1 extends Cn {
    constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
      n = new we(n), i = new we(i);
      const s = t / 2, r = e / t, a = e / 2, c = [], u = [];
      for (let m = 0, v = 0, b = -a; m <= t; m++, b += r) {
        c.push(-a, 0, b, a, 0, b), c.push(b, 0, -a, b, 0, a);
        const _ = m === s ? n : i;
        _.toArray(u, v), v += 3, _.toArray(u, v), v += 3, _.toArray(u, v), v += 3, _.toArray(u, v), v += 3;
      }
      const p = new Xe();
      p.setAttribute("position", new Pe(c, 3)), p.setAttribute("color", new Pe(u, 3));
      const f = new Zt({
        vertexColors: true,
        toneMapped: false
      });
      super(p, f), this.type = "GridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class v1 extends Cn {
    constructor(e = 10, t = 16, n = 8, i = 64, s = 4473924, r = 8947848) {
      s = new we(s), r = new we(r);
      const a = [], c = [];
      if (t > 1) for (let f = 0; f < t; f++) {
        const m = f / t * (Math.PI * 2), v = Math.sin(m) * e, b = Math.cos(m) * e;
        a.push(0, 0, 0), a.push(v, 0, b);
        const _ = f & 1 ? s : r;
        c.push(_.r, _.g, _.b), c.push(_.r, _.g, _.b);
      }
      for (let f = 0; f < n; f++) {
        const m = f & 1 ? s : r, v = e - e / n * f;
        for (let b = 0; b < i; b++) {
          let _ = b / i * (Math.PI * 2), x = Math.sin(_) * v, w = Math.cos(_) * v;
          a.push(x, 0, w), c.push(m.r, m.g, m.b), _ = (b + 1) / i * (Math.PI * 2), x = Math.sin(_) * v, w = Math.cos(_) * v, a.push(x, 0, w), c.push(m.r, m.g, m.b);
        }
      }
      const u = new Xe();
      u.setAttribute("position", new Pe(a, 3)), u.setAttribute("color", new Pe(c, 3));
      const p = new Zt({
        vertexColors: true,
        toneMapped: false
      });
      super(u, p), this.type = "PolarGridHelper";
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  const Rp = new P(), Ta = new P(), Ip = new P();
  class _1 extends rt {
    constructor(e, t, n) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
      let i = new Xe();
      i.setAttribute("position", new Pe([
        -t,
        t,
        0,
        t,
        t,
        0,
        t,
        -t,
        0,
        -t,
        -t,
        0,
        -t,
        t,
        0
      ], 3));
      const s = new Zt({
        fog: false,
        toneMapped: false
      });
      this.lightPlane = new si(i, s), this.add(this.lightPlane), i = new Xe(), i.setAttribute("position", new Pe([
        0,
        0,
        0,
        0,
        0,
        1
      ], 3)), this.targetLine = new si(i, s), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), Rp.setFromMatrixPosition(this.light.matrixWorld), Ta.setFromMatrixPosition(this.light.target.matrixWorld), Ip.subVectors(Ta, Rp), this.lightPlane.lookAt(Ta), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ta), this.targetLine.scale.z = Ip.length();
    }
  }
  const Ca = new P(), St = new Ja();
  class x1 extends Cn {
    constructor(e) {
      const t = new Xe(), n = new Zt({
        color: 16777215,
        vertexColors: true,
        toneMapped: false
      }), i = [], s = [], r = {};
      a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
      function a(b, _) {
        c(b), c(_);
      }
      function c(b) {
        i.push(0, 0, 0), s.push(0, 0, 0), r[b] === void 0 && (r[b] = []), r[b].push(i.length / 3 - 1);
      }
      t.setAttribute("position", new Pe(i, 3)), t.setAttribute("color", new Pe(s, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = r, this.update();
      const u = new we(16755200), p = new we(16711680), f = new we(43775), m = new we(16777215), v = new we(3355443);
      this.setColors(u, p, f, m, v);
    }
    setColors(e, t, n, i, s) {
      const a = this.geometry.getAttribute("color");
      a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = true;
    }
    update() {
      const e = this.geometry, t = this.pointMap, n = 1, i = 1;
      St.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Ct("c", t, e, St, 0, 0, -1), Ct("t", t, e, St, 0, 0, 1), Ct("n1", t, e, St, -n, -i, -1), Ct("n2", t, e, St, n, -i, -1), Ct("n3", t, e, St, -n, i, -1), Ct("n4", t, e, St, n, i, -1), Ct("f1", t, e, St, -n, -i, 1), Ct("f2", t, e, St, n, -i, 1), Ct("f3", t, e, St, -n, i, 1), Ct("f4", t, e, St, n, i, 1), Ct("u1", t, e, St, n * 0.7, i * 1.1, -1), Ct("u2", t, e, St, -n * 0.7, i * 1.1, -1), Ct("u3", t, e, St, 0, i * 2, -1), Ct("cf1", t, e, St, -n, 0, 1), Ct("cf2", t, e, St, n, 0, 1), Ct("cf3", t, e, St, 0, -i, 1), Ct("cf4", t, e, St, 0, i, 1), Ct("cn1", t, e, St, -n, 0, -1), Ct("cn2", t, e, St, n, 0, -1), Ct("cn3", t, e, St, 0, -i, -1), Ct("cn4", t, e, St, 0, i, -1), e.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  function Ct(l, e, t, n, i, s, r) {
    Ca.set(i, s, r).unproject(n);
    const a = e[l];
    if (a !== void 0) {
      const c = t.getAttribute("position");
      for (let u = 0, p = a.length; u < p; u++) c.setXYZ(a[u], Ca.x, Ca.y, Ca.z);
    }
  }
  const Aa = new Bn();
  class b1 extends Cn {
    constructor(e, t = 16776960) {
      const n = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]), i = new Float32Array(24), s = new Xe();
      s.setIndex(new ht(n, 1)), s.setAttribute("position", new ht(i, 3)), super(s, new Zt({
        color: t,
        toneMapped: false
      })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(e) {
      if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Aa.setFromObject(this.object), Aa.isEmpty()) return;
      const t = Aa.min, n = Aa.max, i = this.geometry.attributes.position, s = i.array;
      s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = t.x, s[4] = n.y, s[5] = n.z, s[6] = t.x, s[7] = t.y, s[8] = n.z, s[9] = n.x, s[10] = t.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = t.z, s[15] = t.x, s[16] = n.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = n.x, s[22] = t.y, s[23] = t.z, i.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(e) {
      return this.object = e, this.update(), this;
    }
    copy(e, t) {
      return super.copy(e, t), this.object = e.object, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class y1 extends Cn {
    constructor(e, t = 16776960) {
      const n = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]), i = [
        1,
        1,
        1,
        -1,
        1,
        1,
        -1,
        -1,
        1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1
      ], s = new Xe();
      s.setIndex(new ht(n, 1)), s.setAttribute("position", new Pe(i, 3)), super(s, new Zt({
        color: t,
        toneMapped: false
      })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(e) {
      const t = this.box;
      t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class w1 extends si {
    constructor(e, t = 1, n = 16776960) {
      const i = n, s = [
        1,
        -1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0,
        1,
        1,
        0
      ], r = new Xe();
      r.setAttribute("position", new Pe(s, 3)), r.computeBoundingSphere(), super(r, new Zt({
        color: i,
        toneMapped: false
      })), this.type = "PlaneHelper", this.plane = e, this.size = t;
      const a = [
        1,
        1,
        0,
        -1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        1,
        0,
        -1,
        -1,
        0,
        1,
        -1,
        0
      ], c = new Xe();
      c.setAttribute("position", new Pe(a, 3)), c.computeBoundingSphere(), this.add(new kt(c, new $t({
        color: i,
        opacity: 0.2,
        transparent: true,
        depthWrite: false,
        toneMapped: false
      })));
    }
    updateMatrixWorld(e) {
      this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
  }
  const Dp = new P();
  let Pa, _c;
  class M1 extends rt {
    constructor(e = new P(0, 0, 1), t = new P(0, 0, 0), n = 1, i = 16776960, s = n * 0.2, r = s * 0.2) {
      super(), this.type = "ArrowHelper", Pa === void 0 && (Pa = new Xe(), Pa.setAttribute("position", new Pe([
        0,
        0,
        0,
        0,
        1,
        0
      ], 3)), _c = new fs(0, 0.5, 1, 5, 1), _c.translate(0, -0.5, 0)), this.position.copy(t), this.line = new si(Pa, new Zt({
        color: i,
        toneMapped: false
      })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new kt(_c, new $t({
        color: i,
        toneMapped: false
      })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(n, s, r);
    }
    setDirection(e) {
      if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
      else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
      else {
        Dp.set(e.z, 0, -e.x).normalize();
        const t = Math.acos(e.y);
        this.quaternion.setFromAxisAngle(Dp, t);
      }
    }
    setLength(e, t = e * 0.2, n = t * 0.2) {
      this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
    }
    setColor(e) {
      this.line.material.color.set(e), this.cone.material.color.set(e);
    }
    copy(e) {
      return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
    }
    dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
    }
  }
  class S1 extends Cn {
    constructor(e = 1) {
      const t = [
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        0,
        e,
        0,
        0,
        0,
        0,
        0,
        0,
        e
      ], n = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
      ], i = new Xe();
      i.setAttribute("position", new Pe(t, 3)), i.setAttribute("color", new Pe(n, 3));
      const s = new Zt({
        vertexColors: true,
        toneMapped: false
      });
      super(i, s), this.type = "AxesHelper";
    }
    setColors(e, t, n) {
      const i = new we(), s = this.geometry.attributes.color.array;
      return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(t), i.toArray(s, 6), i.toArray(s, 9), i.set(n), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  }
  class E1 {
    constructor() {
      this.type = "ShapePath", this.color = new we(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(e, t) {
      return this.currentPath = new ro(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
    }
    lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this;
    }
    quadraticCurveTo(e, t, n, i) {
      return this.currentPath.quadraticCurveTo(e, t, n, i), this;
    }
    bezierCurveTo(e, t, n, i, s, r) {
      return this.currentPath.bezierCurveTo(e, t, n, i, s, r), this;
    }
    splineThru(e) {
      return this.currentPath.splineThru(e), this;
    }
    toShapes(e) {
      function t(w) {
        const S = [];
        for (let y = 0, M = w.length; y < M; y++) {
          const C = w[y], R = new cs();
          R.curves = C.curves, S.push(R);
        }
        return S;
      }
      function n(w, S) {
        const y = S.length;
        let M = false;
        for (let C = y - 1, R = 0; R < y; C = R++) {
          let k = S[C], T = S[R], L = T.x - k.x, F = T.y - k.y;
          if (Math.abs(F) > Number.EPSILON) {
            if (F < 0 && (k = S[R], L = -L, T = S[C], F = -F), w.y < k.y || w.y > T.y) continue;
            if (w.y === k.y) {
              if (w.x === k.x) return true;
            } else {
              const j = F * (w.x - k.x) - L * (w.y - k.y);
              if (j === 0) return true;
              if (j < 0) continue;
              M = !M;
            }
          } else {
            if (w.y !== k.y) continue;
            if (T.x <= w.x && w.x <= k.x || k.x <= w.x && w.x <= T.x) return true;
          }
        }
        return M;
      }
      const i = Nn.isClockWise, s = this.subPaths;
      if (s.length === 0) return [];
      let r, a, c;
      const u = [];
      if (s.length === 1) return a = s[0], c = new cs(), c.curves = a.curves, u.push(c), u;
      let p = !i(s[0].getPoints());
      p = e ? !p : p;
      const f = [], m = [];
      let v = [], b = 0, _;
      m[b] = void 0, v[b] = [];
      for (let w = 0, S = s.length; w < S; w++) a = s[w], _ = a.getPoints(), r = i(_), r = e ? !r : r, r ? (!p && m[b] && b++, m[b] = {
        s: new cs(),
        p: _
      }, m[b].s.curves = a.curves, p && b++, v[b] = []) : v[b].push({
        h: a,
        p: _[0]
      });
      if (!m[0]) return t(s);
      if (m.length > 1) {
        let w = false, S = 0;
        for (let y = 0, M = m.length; y < M; y++) f[y] = [];
        for (let y = 0, M = m.length; y < M; y++) {
          const C = v[y];
          for (let R = 0; R < C.length; R++) {
            const k = C[R];
            let T = true;
            for (let L = 0; L < m.length; L++) n(k.p, m[L].p) && (y !== L && S++, T ? (T = false, f[L].push(k)) : w = true);
            T && f[y].push(k);
          }
        }
        S > 0 && w === false && (v = f);
      }
      let x;
      for (let w = 0, S = m.length; w < S; w++) {
        c = m[w].s, u.push(c), x = v[w];
        for (let y = 0, M = x.length; y < M; y++) c.holes.push(x[y].h);
      }
      return u;
    }
  }
  const Qn = T1();
  function T1() {
    const l = new ArrayBuffer(4), e = new Float32Array(l), t = new Uint32Array(l), n = new Uint32Array(512), i = new Uint32Array(512);
    for (let c = 0; c < 256; ++c) {
      const u = c - 127;
      u < -27 ? (n[c] = 0, n[c | 256] = 32768, i[c] = 24, i[c | 256] = 24) : u < -14 ? (n[c] = 1024 >> -u - 14, n[c | 256] = 1024 >> -u - 14 | 32768, i[c] = -u - 1, i[c | 256] = -u - 1) : u <= 15 ? (n[c] = u + 15 << 10, n[c | 256] = u + 15 << 10 | 32768, i[c] = 13, i[c | 256] = 13) : u < 128 ? (n[c] = 31744, n[c | 256] = 64512, i[c] = 24, i[c | 256] = 24) : (n[c] = 31744, n[c | 256] = 64512, i[c] = 13, i[c | 256] = 13);
    }
    const s = new Uint32Array(2048), r = new Uint32Array(64), a = new Uint32Array(64);
    for (let c = 1; c < 1024; ++c) {
      let u = c << 13, p = 0;
      for (; (u & 8388608) === 0; ) u <<= 1, p -= 8388608;
      u &= -8388609, p += 947912704, s[c] = u | p;
    }
    for (let c = 1024; c < 2048; ++c) s[c] = 939524096 + (c - 1024 << 13);
    for (let c = 1; c < 31; ++c) r[c] = c << 23;
    r[31] = 1199570944, r[32] = 2147483648;
    for (let c = 33; c < 63; ++c) r[c] = 2147483648 + (c - 32 << 23);
    r[63] = 3347054592;
    for (let c = 1; c < 64; ++c) c !== 32 && (a[c] = 1024);
    return {
      floatView: e,
      uint32View: t,
      baseTable: n,
      shiftTable: i,
      mantissaTable: s,
      exponentTable: r,
      offsetTable: a
    };
  }
  function C1(l) {
    Math.abs(l) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), l = At(l, -65504, 65504), Qn.floatView[0] = l;
    const e = Qn.uint32View[0], t = e >> 23 & 511;
    return Qn.baseTable[t] + ((e & 8388607) >> Qn.shiftTable[t]);
  }
  function A1(l) {
    const e = l >> 10;
    return Qn.uint32View[0] = Qn.mantissaTable[Qn.offsetTable[e] + (l & 1023)] + Qn.exponentTable[e], Qn.floatView[0];
  }
  var P1 = Object.freeze({
    __proto__: null,
    fromHalfFloat: A1,
    toHalfFloat: C1
  });
  class L1 extends Vn {
    constructor(e, t, n, i, s, r) {
      console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."), super(e, t, n, i, s, r);
    }
  }
  class R1 extends bo {
    constructor(e, t, n, i) {
      console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."), super(e, t, n, i);
    }
  }
  class I1 extends yo {
    constructor(e, t, n, i) {
      console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."), super(e, t, n, i);
    }
  }
  class D1 extends wo {
    constructor(e, t, n, i, s, r, a) {
      console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."), super(e, t, n, i, s, r, a);
    }
  }
  class k1 extends fs {
    constructor(e, t, n, i, s, r, a, c) {
      console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."), super(e, t, n, i, s, r, a, c);
    }
  }
  class N1 extends Mo {
    constructor(e, t) {
      console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."), super(e, t);
    }
  }
  class O1 extends So {
    constructor(e, t) {
      console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."), super(e, t);
    }
  }
  class F1 extends Eo {
    constructor(e, t) {
      console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."), super(e, t);
    }
  }
  class B1 extends pr {
    constructor(e, t, n, i) {
      console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."), super(e, t, n, i);
    }
  }
  class U1 extends fr {
    constructor(e, t) {
      console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."), super(e, t);
    }
  }
  class z1 extends ur {
    constructor(e, t, n, i) {
      console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."), super(e, t, n, i);
    }
  }
  class V1 extends ri {
    constructor(e, t, n, i) {
      console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."), super(e, t, n, i);
    }
  }
  class G1 extends To {
    constructor(e, t, n, i, s, r) {
      console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."), super(e, t, n, i, s, r);
    }
  }
  class H1 extends Co {
    constructor(e, t) {
      console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."), super(e, t);
    }
  }
  class W1 extends mr {
    constructor(e, t, n, i, s, r, a) {
      console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."), super(e, t, n, i, s, r, a);
    }
  }
  class q1 extends Ao {
    constructor(e, t) {
      console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."), super(e, t);
    }
  }
  class X1 extends Po {
    constructor(e, t, n, i, s) {
      console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."), super(e, t, n, i, s);
    }
  }
  class j1 extends Lo {
    constructor(e, t, n, i, s, r) {
      console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."), super(e, t, n, i, s, r);
    }
  }
  class K1 extends Ro {
    constructor(e, t, n, i, s) {
      console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."), super(e, t, n, i, s);
    }
  }
  typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
      revision: Xa
    }
  }));
  typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Xa);
  const Y1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: bh,
    AddEquation: Qi,
    AddOperation: xf,
    AdditiveAnimationBlendMode: wh,
    AdditiveBlending: Ac,
    AlphaFormat: Pf,
    AlwaysDepth: df,
    AlwaysStencilFunc: Xf,
    AmbientLight: tu,
    AmbientLightProbe: BS,
    AnimationClip: lr,
    AnimationLoader: CS,
    AnimationMixer: Wm,
    AnimationObjectGroup: e1,
    AnimationUtils: MS,
    ArcCurve: pm,
    ArrayCamera: am,
    ArrowHelper: M1,
    Audio: Gm,
    AudioAnalyser: WS,
    AudioContext: nu,
    AudioListener: VS,
    AudioLoader: OS,
    AxesHelper: S1,
    BackSide: on,
    BasicDepthPacking: Hf,
    BasicShadowMap: J_,
    Bone: il,
    BooleanKeyframeTrack: ms,
    Box2: c1,
    Box3: Bn,
    Box3Helper: y1,
    BoxBufferGeometry: L1,
    BoxGeometry: Vn,
    BoxHelper: b1,
    BufferAttribute: ht,
    BufferGeometry: Xe,
    BufferGeometryLoader: zm,
    ByteType: Sf,
    Cache: ps,
    Camera: Ja,
    CameraHelper: x1,
    CanvasTexture: jM,
    CapsuleBufferGeometry: R1,
    CapsuleGeometry: bo,
    CatmullRomCurve3: fm,
    CineonToneMapping: wf,
    CircleBufferGeometry: I1,
    CircleGeometry: yo,
    ClampToEdgeWrapping: Xt,
    Clock: iu,
    Color: we,
    ColorKeyframeTrack: Yh,
    ColorManagement: Yt,
    CompressedArrayTexture: XM,
    CompressedTexture: Uh,
    CompressedTextureLoader: AS,
    ConeBufferGeometry: D1,
    ConeGeometry: wo,
    CubeCamera: Qf,
    CubeReflectionMapping: Si,
    CubeRefractionMapping: Ei,
    CubeTexture: go,
    CubeTextureLoader: PS,
    CubeUVReflectionMapping: hr,
    CubicBezierCurve: Vh,
    CubicBezierCurve3: mm,
    CubicInterpolant: Im,
    CullFaceBack: Cc,
    CullFaceFront: Zp,
    CullFaceFrontBack: Z_,
    CullFaceNone: $p,
    Curve: An,
    CurvePath: vm,
    CustomBlending: Jp,
    CustomToneMapping: Mf,
    CylinderBufferGeometry: k1,
    CylinderGeometry: fs,
    Cylindrical: l1,
    Data3DTexture: Th,
    DataArrayTexture: $a,
    DataTexture: Js,
    DataTextureLoader: LS,
    DataUtils: P1,
    DecrementStencilOp: l0,
    DecrementWrapStencilOp: h0,
    DefaultLoadingManager: Nm,
    DepthFormat: Mi,
    DepthStencilFormat: hs,
    DepthTexture: lm,
    DirectionalLight: ll,
    DirectionalLightHelper: _1,
    DiscreteInterpolant: Dm,
    DodecahedronBufferGeometry: N1,
    DodecahedronGeometry: Mo,
    DoubleSide: Dn,
    DstAlphaFactor: of,
    DstColorFactor: lf,
    DynamicCopyUsage: E0,
    DynamicDrawUsage: x0,
    DynamicReadUsage: w0,
    EdgesGeometry: _m,
    EllipseCurve: rl,
    EqualDepth: ff,
    EqualStencilFunc: f0,
    EquirectangularReflectionMapping: Jr,
    EquirectangularRefractionMapping: Qr,
    Euler: mo,
    EventDispatcher: zn,
    ExtrudeBufferGeometry: O1,
    ExtrudeGeometry: So,
    FileLoader: pn,
    Float16BufferAttribute: rx,
    Float32BufferAttribute: Pe,
    Float64BufferAttribute: ox,
    FloatType: ei,
    Fog: nl,
    FogExp2: tl,
    FramebufferTexture: qM,
    FrontSide: On,
    Frustum: Qa,
    GLBufferAttribute: o1,
    GLSL1: C0,
    GLSL3: nh,
    GreaterDepth: gf,
    GreaterEqualDepth: mf,
    GreaterEqualStencilFunc: _0,
    GreaterStencilFunc: g0,
    GridHelper: g1,
    Group: ni,
    HalfFloatType: tr,
    HemisphereLight: Om,
    HemisphereLightHelper: m1,
    HemisphereLightProbe: FS,
    IcosahedronBufferGeometry: F1,
    IcosahedronGeometry: Eo,
    ImageBitmapLoader: Vm,
    ImageLoader: co,
    ImageUtils: Eh,
    IncrementStencilOp: a0,
    IncrementWrapStencilOp: c0,
    InstancedBufferAttribute: rr,
    InstancedBufferGeometry: Um,
    InstancedInterleavedBuffer: r1,
    InstancedMesh: Oh,
    Int16BufferAttribute: ix,
    Int32BufferAttribute: sx,
    Int8BufferAttribute: ex,
    IntType: Tf,
    InterleavedBuffer: _o,
    InterleavedBufferAttribute: Pi,
    Interpolant: vr,
    InterpolateDiscrete: nr,
    InterpolateLinear: us,
    InterpolateSmooth: Na,
    InvertStencilOp: u0,
    KeepStencilOp: Oa,
    KeyframeTrack: Pn,
    LOD: dm,
    LatheBufferGeometry: B1,
    LatheGeometry: pr,
    Layers: Za,
    LessDepth: pf,
    LessEqualDepth: Va,
    LessEqualStencilFunc: m0,
    LessStencilFunc: p0,
    Light: Di,
    LightProbe: cl,
    Line: si,
    Line3: h1,
    LineBasicMaterial: Zt,
    LineCurve: ol,
    LineCurve3: gm,
    LineDashedMaterial: Lm,
    LineLoop: Fh,
    LineSegments: Cn,
    LinearEncoding: Ai,
    LinearFilter: yt,
    LinearInterpolant: Kh,
    LinearMipMapLinearFilter: i0,
    LinearMipMapNearestFilter: n0,
    LinearMipmapLinearFilter: Fn,
    LinearMipmapNearestFilter: Ka,
    LinearSRGBColorSpace: ir,
    LinearToneMapping: bf,
    Loader: sn,
    LoaderUtils: cr,
    LoadingManager: $h,
    LoopOnce: Uf,
    LoopPingPong: Vf,
    LoopRepeat: zf,
    LuminanceAlphaFormat: Rf,
    LuminanceFormat: Lf,
    MOUSE: $i,
    Material: Bt,
    MaterialLoader: hl,
    MathUtils: Kf,
    Matrix3: nn,
    Matrix4: ze,
    MaxEquation: Ic,
    Mesh: kt,
    MeshBasicMaterial: $t,
    MeshDepthMaterial: Lh,
    MeshDistanceMaterial: Rh,
    MeshLambertMaterial: Am,
    MeshMatcapMaterial: Pm,
    MeshNormalMaterial: Cm,
    MeshPhongMaterial: Em,
    MeshPhysicalMaterial: oi,
    MeshStandardMaterial: gr,
    MeshToonMaterial: Tm,
    MinEquation: Rc,
    MirroredRepeatWrapping: er,
    MixOperation: _f,
    MultiplyBlending: Lc,
    MultiplyOperation: po,
    NearestFilter: Et,
    NearestMipMapLinearFilter: t0,
    NearestMipMapNearestFilter: e0,
    NearestMipmapLinearFilter: Zs,
    NearestMipmapNearestFilter: eo,
    NeverDepth: uf,
    NeverStencilFunc: d0,
    NoBlending: ii,
    NoColorSpace: s0,
    NoToneMapping: kn,
    NormalAnimationBlendMode: Ya,
    NormalBlending: rs,
    NotEqualDepth: vf,
    NotEqualStencilFunc: v0,
    NumberKeyframeTrack: or,
    Object3D: rt,
    ObjectLoader: kS,
    ObjectSpaceNormalMap: qf,
    OctahedronBufferGeometry: U1,
    OctahedronGeometry: fr,
    OneFactor: nf,
    OneMinusDstAlphaFactor: af,
    OneMinusDstColorFactor: cf,
    OneMinusSrcAlphaFactor: xh,
    OneMinusSrcColorFactor: rf,
    OrthographicCamera: vo,
    PCFShadowMap: gh,
    PCFSoftShadowMap: vh,
    PMREMGenerator: sh,
    Path: ro,
    PerspectiveCamera: Ft,
    Plane: bi,
    PlaneBufferGeometry: z1,
    PlaneGeometry: ur,
    PlaneHelper: w1,
    PointLight: eu,
    PointLightHelper: p1,
    Points: Bh,
    PointsMaterial: sl,
    PolarGridHelper: v1,
    PolyhedronBufferGeometry: V1,
    PolyhedronGeometry: ri,
    PositionalAudio: HS,
    PropertyBinding: st,
    PropertyMixer: Hm,
    QuadraticBezierCurve: Gh,
    QuadraticBezierCurve3: Hh,
    Quaternion: xt,
    QuaternionKeyframeTrack: Li,
    QuaternionLinearInterpolant: km,
    RED_GREEN_RGTC2_Format: eh,
    RED_RGTC1_Format: Bf,
    REVISION: Xa,
    RGBADepthPacking: Wf,
    RGBAFormat: un,
    RGBAIntegerFormat: Of,
    RGBA_ASTC_10x10_Format: $c,
    RGBA_ASTC_10x5_Format: jc,
    RGBA_ASTC_10x6_Format: Kc,
    RGBA_ASTC_10x8_Format: Yc,
    RGBA_ASTC_12x10_Format: Zc,
    RGBA_ASTC_12x12_Format: Jc,
    RGBA_ASTC_4x4_Format: Uc,
    RGBA_ASTC_5x4_Format: zc,
    RGBA_ASTC_5x5_Format: Vc,
    RGBA_ASTC_6x5_Format: Gc,
    RGBA_ASTC_6x6_Format: Hc,
    RGBA_ASTC_8x5_Format: Wc,
    RGBA_ASTC_8x6_Format: qc,
    RGBA_ASTC_8x8_Format: Xc,
    RGBA_BPTC_Format: ka,
    RGBA_ETC2_EAC_Format: Bc,
    RGBA_PVRTC_2BPPV1_Format: Oc,
    RGBA_PVRTC_4BPPV1_Format: Nc,
    RGBA_S3TC_DXT1_Format: Ra,
    RGBA_S3TC_DXT3_Format: Ia,
    RGBA_S3TC_DXT5_Format: Da,
    RGB_ETC1_Format: Ff,
    RGB_ETC2_Format: Fc,
    RGB_PVRTC_2BPPV1_Format: kc,
    RGB_PVRTC_4BPPV1_Format: Dc,
    RGB_S3TC_DXT1_Format: La,
    RGFormat: kf,
    RGIntegerFormat: Nf,
    RawShaderMaterial: Sm,
    Ray: fo,
    Raycaster: a1,
    RectAreaLight: Fm,
    RedFormat: If,
    RedIntegerFormat: Df,
    ReinhardToneMapping: yf,
    RepeatWrapping: Ti,
    ReplaceStencilOp: o0,
    ReverseSubtractEquation: ef,
    RingBufferGeometry: G1,
    RingGeometry: To,
    SIGNED_RED_GREEN_RGTC2_Format: th,
    SIGNED_RED_RGTC1_Format: Qc,
    SRGBColorSpace: Sn,
    Scene: Dh,
    ShaderChunk: Ye,
    ShaderLib: En,
    ShaderMaterial: Un,
    ShadowMaterial: Mm,
    Shape: cs,
    ShapeBufferGeometry: H1,
    ShapeGeometry: Co,
    ShapePath: E1,
    ShapeUtils: Nn,
    ShortType: Ef,
    Skeleton: xo,
    SkeletonHelper: d1,
    SkinnedMesh: Nh,
    Source: is,
    Sphere: Ii,
    SphereBufferGeometry: W1,
    SphereGeometry: mr,
    Spherical: uh,
    SphericalHarmonics3: Bm,
    SplineCurve: Wh,
    SpotLight: Qh,
    SpotLightHelper: u1,
    Sprite: um,
    SpriteMaterial: kh,
    SrcAlphaFactor: _h,
    SrcAlphaSaturateFactor: hf,
    SrcColorFactor: sf,
    StaticCopyUsage: S0,
    StaticDrawUsage: no,
    StaticReadUsage: y0,
    StereoCamera: US,
    StreamCopyUsage: T0,
    StreamDrawUsage: b0,
    StreamReadUsage: M0,
    StringKeyframeTrack: gs,
    SubtractEquation: Qp,
    SubtractiveBlending: Pc,
    TOUCH: Zi,
    TangentSpaceNormalMap: Ri,
    TetrahedronBufferGeometry: q1,
    TetrahedronGeometry: Ao,
    Texture: Mt,
    TextureLoader: Zh,
    TorusBufferGeometry: X1,
    TorusGeometry: Po,
    TorusKnotBufferGeometry: j1,
    TorusKnotGeometry: Lo,
    Triangle: xn,
    TriangleFanDrawMode: Ga,
    TriangleStripDrawMode: Mh,
    TrianglesDrawMode: Gf,
    TubeBufferGeometry: K1,
    TubeGeometry: Ro,
    TwoPassDoubleSide: Q_,
    UVMapping: ja,
    Uint16BufferAttribute: Ch,
    Uint32BufferAttribute: Ah,
    Uint8BufferAttribute: tx,
    Uint8ClampedBufferAttribute: nx,
    Uniform: ou,
    UniformsGroup: s1,
    UniformsLib: _e,
    UniformsUtils: Jf,
    UnsignedByteType: Ci,
    UnsignedInt248Type: os,
    UnsignedIntType: wi,
    UnsignedShort4444Type: Cf,
    UnsignedShort5551Type: Af,
    UnsignedShortType: yh,
    VSMShadowMap: Xs,
    Vector2: te,
    Vector3: P,
    Vector4: ft,
    VectorKeyframeTrack: ar,
    VideoTexture: WM,
    WebGL1Renderer: cm,
    WebGL3DRenderTarget: W0,
    WebGLArrayRenderTarget: H0,
    WebGLCubeRenderTarget: em,
    WebGLMultipleRenderTargets: q0,
    WebGLRenderTarget: Tn,
    WebGLRenderer: Ih,
    WebGLUtils: om,
    WireframeGeometry: wm,
    WrapAroundEnding: to,
    ZeroCurvatureEnding: ts,
    ZeroFactor: tf,
    ZeroSlopeEnding: ns,
    ZeroStencilOp: r0,
    _SRGBAFormat: Ha,
    sRGBEncoding: ct
  }, Symbol.toStringTag, {
    value: "Module"
  })), kp = {
    type: "change"
  }, xc = {
    type: "start"
  }, Np = {
    type: "end"
  };
  class $1 extends zn {
    constructor(e, t) {
      super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = true, this.target = new P(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown"
      }, this.mouseButtons = {
        LEFT: $i.ROTATE,
        MIDDLE: $i.DOLLY,
        RIGHT: $i.PAN
      }, this.touches = {
        ONE: Zi.ROTATE,
        TWO: Zi.DOLLY_PAN
      }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
        return a.phi;
      }, this.getAzimuthalAngle = function() {
        return a.theta;
      }, this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      }, this.listenToKeyEvents = function(O) {
        O.addEventListener("keydown", it), this._domElementKeyEvents = O;
      }, this.saveState = function() {
        n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
      }, this.reset = function() {
        n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(kp), n.update(), s = i.NONE;
      }, this.update = (function() {
        const O = new P(), G = new xt().setFromUnitVectors(e.up, new P(0, 1, 0)), ye = G.clone().invert(), Me = new P(), be = new xt(), Ie = 2 * Math.PI;
        return function() {
          const qe = n.object.position;
          O.copy(qe).sub(n.target), O.applyQuaternion(G), a.setFromVector3(O), n.autoRotate && s === i.NONE && L(k()), n.enableDamping ? (a.theta += c.theta * n.dampingFactor, a.phi += c.phi * n.dampingFactor) : (a.theta += c.theta, a.phi += c.phi);
          let je = n.minAzimuthAngle, pt = n.maxAzimuthAngle;
          return isFinite(je) && isFinite(pt) && (je < -Math.PI ? je += Ie : je > Math.PI && (je -= Ie), pt < -Math.PI ? pt += Ie : pt > Math.PI && (pt -= Ie), je <= pt ? a.theta = Math.max(je, Math.min(pt, a.theta)) : a.theta = a.theta > (je + pt) / 2 ? Math.max(je, a.theta) : Math.min(pt, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), a.radius *= u, a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)), n.enableDamping === true ? n.target.addScaledVector(p, n.dampingFactor) : n.target.add(p), O.setFromSpherical(a), O.applyQuaternion(ye), qe.copy(n.target).add(O), n.object.lookAt(n.target), n.enableDamping === true ? (c.theta *= 1 - n.dampingFactor, c.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (c.set(0, 0, 0), p.set(0, 0, 0)), u = 1, f || Me.distanceToSquared(n.object.position) > r || 8 * (1 - be.dot(n.object.quaternion)) > r ? (n.dispatchEvent(kp), Me.copy(n.object.position), be.copy(n.object.quaternion), f = false, true) : false;
        };
      })(), this.dispose = function() {
        n.domElement.removeEventListener("contextmenu", $), n.domElement.removeEventListener("pointerdown", ge), n.domElement.removeEventListener("pointercancel", Fe), n.domElement.removeEventListener("wheel", dt), n.domElement.removeEventListener("pointermove", Ee), n.domElement.removeEventListener("pointerup", fe), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", it);
      };
      const n = this, i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let s = i.NONE;
      const r = 1e-6, a = new uh(), c = new uh();
      let u = 1;
      const p = new P();
      let f = false;
      const m = new te(), v = new te(), b = new te(), _ = new te(), x = new te(), w = new te(), S = new te(), y = new te(), M = new te(), C = [], R = {};
      function k() {
        return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
      }
      function T() {
        return Math.pow(0.95, n.zoomSpeed);
      }
      function L(O) {
        c.theta -= O;
      }
      function F(O) {
        c.phi -= O;
      }
      const j = (function() {
        const O = new P();
        return function(ye, Me) {
          O.setFromMatrixColumn(Me, 0), O.multiplyScalar(-ye), p.add(O);
        };
      })(), Y = (function() {
        const O = new P();
        return function(ye, Me) {
          n.screenSpacePanning === true ? O.setFromMatrixColumn(Me, 1) : (O.setFromMatrixColumn(Me, 0), O.crossVectors(n.object.up, O)), O.multiplyScalar(ye), p.add(O);
        };
      })(), z = (function() {
        const O = new P();
        return function(ye, Me) {
          const be = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const Ie = n.object.position;
            O.copy(Ie).sub(n.target);
            let Ae = O.length();
            Ae *= Math.tan(n.object.fov / 2 * Math.PI / 180), j(2 * ye * Ae / be.clientHeight, n.object.matrix), Y(2 * Me * Ae / be.clientHeight, n.object.matrix);
          } else n.object.isOrthographicCamera ? (j(ye * (n.object.right - n.object.left) / n.object.zoom / be.clientWidth, n.object.matrix), Y(Me * (n.object.top - n.object.bottom) / n.object.zoom / be.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = false);
        };
      })();
      function B(O) {
        n.object.isPerspectiveCamera ? u /= O : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * O)), n.object.updateProjectionMatrix(), f = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
      }
      function Z(O) {
        n.object.isPerspectiveCamera ? u *= O : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / O)), n.object.updateProjectionMatrix(), f = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = false);
      }
      function ie(O) {
        m.set(O.clientX, O.clientY);
      }
      function re(O) {
        S.set(O.clientX, O.clientY);
      }
      function W(O) {
        _.set(O.clientX, O.clientY);
      }
      function pe(O) {
        v.set(O.clientX, O.clientY), b.subVectors(v, m).multiplyScalar(n.rotateSpeed);
        const G = n.domElement;
        L(2 * Math.PI * b.x / G.clientHeight), F(2 * Math.PI * b.y / G.clientHeight), m.copy(v), n.update();
      }
      function ae(O) {
        y.set(O.clientX, O.clientY), M.subVectors(y, S), M.y > 0 ? B(T()) : M.y < 0 && Z(T()), S.copy(y), n.update();
      }
      function Te(O) {
        x.set(O.clientX, O.clientY), w.subVectors(x, _).multiplyScalar(n.panSpeed), z(w.x, w.y), _.copy(x), n.update();
      }
      function q(O) {
        O.deltaY < 0 ? Z(T()) : O.deltaY > 0 && B(T()), n.update();
      }
      function le(O) {
        let G = false;
        switch (O.code) {
          case n.keys.UP:
            O.ctrlKey || O.metaKey || O.shiftKey ? F(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(0, n.keyPanSpeed), G = true;
            break;
          case n.keys.BOTTOM:
            O.ctrlKey || O.metaKey || O.shiftKey ? F(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(0, -n.keyPanSpeed), G = true;
            break;
          case n.keys.LEFT:
            O.ctrlKey || O.metaKey || O.shiftKey ? L(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(n.keyPanSpeed, 0), G = true;
            break;
          case n.keys.RIGHT:
            O.ctrlKey || O.metaKey || O.shiftKey ? L(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : z(-n.keyPanSpeed, 0), G = true;
            break;
        }
        G && (O.preventDefault(), n.update());
      }
      function oe() {
        if (C.length === 1) m.set(C[0].pageX, C[0].pageY);
        else {
          const O = 0.5 * (C[0].pageX + C[1].pageX), G = 0.5 * (C[0].pageY + C[1].pageY);
          m.set(O, G);
        }
      }
      function ce() {
        if (C.length === 1) _.set(C[0].pageX, C[0].pageY);
        else {
          const O = 0.5 * (C[0].pageX + C[1].pageX), G = 0.5 * (C[0].pageY + C[1].pageY);
          _.set(O, G);
        }
      }
      function K() {
        const O = C[0].pageX - C[1].pageX, G = C[0].pageY - C[1].pageY, ye = Math.sqrt(O * O + G * G);
        S.set(0, ye);
      }
      function ke() {
        n.enableZoom && K(), n.enablePan && ce();
      }
      function Ce() {
        n.enableZoom && K(), n.enableRotate && oe();
      }
      function Le(O) {
        if (C.length == 1) v.set(O.pageX, O.pageY);
        else {
          const ye = Be(O), Me = 0.5 * (O.pageX + ye.x), be = 0.5 * (O.pageY + ye.y);
          v.set(Me, be);
        }
        b.subVectors(v, m).multiplyScalar(n.rotateSpeed);
        const G = n.domElement;
        L(2 * Math.PI * b.x / G.clientHeight), F(2 * Math.PI * b.y / G.clientHeight), m.copy(v);
      }
      function ve(O) {
        if (C.length === 1) x.set(O.pageX, O.pageY);
        else {
          const G = Be(O), ye = 0.5 * (O.pageX + G.x), Me = 0.5 * (O.pageY + G.y);
          x.set(ye, Me);
        }
        w.subVectors(x, _).multiplyScalar(n.panSpeed), z(w.x, w.y), _.copy(x);
      }
      function Ve(O) {
        const G = Be(O), ye = O.pageX - G.x, Me = O.pageY - G.y, be = Math.sqrt(ye * ye + Me * Me);
        y.set(0, be), M.set(0, Math.pow(y.y / S.y, n.zoomSpeed)), B(M.y), S.copy(y);
      }
      function se(O) {
        n.enableZoom && Ve(O), n.enablePan && ve(O);
      }
      function ne(O) {
        n.enableZoom && Ve(O), n.enableRotate && Le(O);
      }
      function ge(O) {
        n.enabled !== false && (C.length === 0 && (n.domElement.setPointerCapture(O.pointerId), n.domElement.addEventListener("pointermove", Ee), n.domElement.addEventListener("pointerup", fe)), he(O), O.pointerType === "touch" ? D(O) : Ne(O));
      }
      function Ee(O) {
        n.enabled !== false && (O.pointerType === "touch" ? A(O) : Re(O));
      }
      function fe(O) {
        me(O), C.length === 0 && (n.domElement.releasePointerCapture(O.pointerId), n.domElement.removeEventListener("pointermove", Ee), n.domElement.removeEventListener("pointerup", fe)), n.dispatchEvent(Np), s = i.NONE;
      }
      function Fe(O) {
        me(O);
      }
      function Ne(O) {
        let G;
        switch (O.button) {
          case 0:
            G = n.mouseButtons.LEFT;
            break;
          case 1:
            G = n.mouseButtons.MIDDLE;
            break;
          case 2:
            G = n.mouseButtons.RIGHT;
            break;
          default:
            G = -1;
        }
        switch (G) {
          case $i.DOLLY:
            if (n.enableZoom === false) return;
            re(O), s = i.DOLLY;
            break;
          case $i.ROTATE:
            if (O.ctrlKey || O.metaKey || O.shiftKey) {
              if (n.enablePan === false) return;
              W(O), s = i.PAN;
            } else {
              if (n.enableRotate === false) return;
              ie(O), s = i.ROTATE;
            }
            break;
          case $i.PAN:
            if (O.ctrlKey || O.metaKey || O.shiftKey) {
              if (n.enableRotate === false) return;
              ie(O), s = i.ROTATE;
            } else {
              if (n.enablePan === false) return;
              W(O), s = i.PAN;
            }
            break;
          default:
            s = i.NONE;
        }
        s !== i.NONE && n.dispatchEvent(xc);
      }
      function Re(O) {
        switch (s) {
          case i.ROTATE:
            if (n.enableRotate === false) return;
            pe(O);
            break;
          case i.DOLLY:
            if (n.enableZoom === false) return;
            ae(O);
            break;
          case i.PAN:
            if (n.enablePan === false) return;
            Te(O);
            break;
        }
      }
      function dt(O) {
        n.enabled === false || n.enableZoom === false || s !== i.NONE || (O.preventDefault(), n.dispatchEvent(xc), q(O), n.dispatchEvent(Np));
      }
      function it(O) {
        n.enabled === false || n.enablePan === false || le(O);
      }
      function D(O) {
        switch (xe(O), C.length) {
          case 1:
            switch (n.touches.ONE) {
              case Zi.ROTATE:
                if (n.enableRotate === false) return;
                oe(), s = i.TOUCH_ROTATE;
                break;
              case Zi.PAN:
                if (n.enablePan === false) return;
                ce(), s = i.TOUCH_PAN;
                break;
              default:
                s = i.NONE;
            }
            break;
          case 2:
            switch (n.touches.TWO) {
              case Zi.DOLLY_PAN:
                if (n.enableZoom === false && n.enablePan === false) return;
                ke(), s = i.TOUCH_DOLLY_PAN;
                break;
              case Zi.DOLLY_ROTATE:
                if (n.enableZoom === false && n.enableRotate === false) return;
                Ce(), s = i.TOUCH_DOLLY_ROTATE;
                break;
              default:
                s = i.NONE;
            }
            break;
          default:
            s = i.NONE;
        }
        s !== i.NONE && n.dispatchEvent(xc);
      }
      function A(O) {
        switch (xe(O), s) {
          case i.TOUCH_ROTATE:
            if (n.enableRotate === false) return;
            Le(O), n.update();
            break;
          case i.TOUCH_PAN:
            if (n.enablePan === false) return;
            ve(O), n.update();
            break;
          case i.TOUCH_DOLLY_PAN:
            if (n.enableZoom === false && n.enablePan === false) return;
            se(O), n.update();
            break;
          case i.TOUCH_DOLLY_ROTATE:
            if (n.enableZoom === false && n.enableRotate === false) return;
            ne(O), n.update();
            break;
          default:
            s = i.NONE;
        }
      }
      function $(O) {
        n.enabled !== false && O.preventDefault();
      }
      function he(O) {
        C.push(O);
      }
      function me(O) {
        delete R[O.pointerId];
        for (let G = 0; G < C.length; G++) if (C[G].pointerId == O.pointerId) {
          C.splice(G, 1);
          return;
        }
      }
      function xe(O) {
        let G = R[O.pointerId];
        G === void 0 && (G = new te(), R[O.pointerId] = G), G.set(O.pageX, O.pageY);
      }
      function Be(O) {
        const G = O.pointerId === C[0].pointerId ? C[1] : C[0];
        return R[G.pointerId];
      }
      n.domElement.addEventListener("contextmenu", $), n.domElement.addEventListener("pointerdown", ge), n.domElement.addEventListener("pointercancel", Fe), n.domElement.addEventListener("wheel", dt, {
        passive: false
      }), this.update();
    }
  }
  const Z1 = {}, Op = (l) => {
    let e;
    const t = /* @__PURE__ */ new Set(), n = (p, f) => {
      const m = typeof p == "function" ? p(e) : p;
      if (!Object.is(m, e)) {
        const v = e;
        e = f ?? (typeof m != "object" || m === null) ? m : Object.assign({}, e, m), t.forEach((b) => b(e, v));
      }
    }, i = () => e, c = {
      setState: n,
      getState: i,
      getInitialState: () => u,
      subscribe: (p) => (t.add(p), () => t.delete(p)),
      destroy: () => {
        (Z1 ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), t.clear();
      }
    }, u = e = l(n, i, c);
    return c;
  }, ul = (l) => l ? Op(l) : Op, au = ul(() => ({
    width: window.innerWidth,
    height: window.innerHeight,
    pixelRatio: Math.min(window.devicePixelRatio, 2)
  })), ho = ul(() => ({
    physicsReady: false,
    assetsReady: false,
    nippleReady: false
  })), We = ul(() => ({
    forward: false,
    backward: false,
    left: false,
    right: false
  }));
  class J1 {
    constructor() {
      this.app = new Ln(), this.canvas = this.app.canvas, this.sizesStore = au, this.sizes = this.sizesStore.getState(), this.setInstance(), this.setControls(), this.setResizeLister();
    }
    setInstance() {
      this.instance = new Ft(35, this.sizes.width / this.sizes.height, 1, 600), this.instance.position.z = 100, this.instance.position.y = 20;
    }
    setControls() {
      this.controls = new $1(this.instance, this.canvas), this.controls.enableDamping = false, this.controls.enableRotate = false, this.controls.enablePan = false, this.controls.enableZoom = false;
    }
    setResizeLister() {
      this.sizesStore.subscribe((e) => {
        this.instance.aspect = e.width / e.height, this.instance.updateProjectionMatrix();
      });
    }
    loop(e = 0) {
      var _a2;
      this.controls.update();
      const t = Math.max(0, Math.min(e || 0, 0.1)), n = 1 - Math.exp(-6 * t);
      if (this.characterController = (_a2 = this.app.world.characterController) == null ? void 0 : _a2.rigidBody, this.characterController) {
        const i = this.characterController.translation(), s = this.characterController.rotation(), r = new P(0, 28, 35);
        r.applyQuaternion(s), r.add(i);
        const a = new P(0, 8, 0);
        a.applyQuaternion(s), a.add(i), this.instance.position.lerp(r, n), this.controls.target.lerp(a, n);
      }
    }
  }
  class Q1 {
    constructor() {
      this.app = new Ln(), this.canvas = this.app.canvas, this.camera = this.app.camera, this.scene = this.app.scene, this.sizesStore = au, this.sizes = this.sizesStore.getState(), this.setInstance(), this.setResizeLister();
    }
    setInstance() {
      this.instance = new Ih({
        canvas: this.canvas,
        antialias: true
      }), this.instance.setSize(this.sizes.width, this.sizes.height), this.instance.setPixelRatio(this.sizes.pixelRatio), this.instance.outputEncoding = ct, this.instance.shadowMap.enabled = true, this.instance.shadowMap.type = vh, this.instance.toneMapping = bh, this.instance.toneMappingExposure = 0.8;
    }
    setResizeLister() {
      this.sizesStore.subscribe((e) => {
        this.instance.setSize(e.width, e.height), this.instance.setPixelRatio(e.pixelRatio);
      });
    }
    loop() {
      this.instance.render(this.scene, this.camera.instance);
    }
  }
  class eE {
    constructor() {
      this.app = new Ln(), this.camera = this.app.camera, this.renderer = this.app.renderer, this.world = this.app.world, this.clock = new iu(), this.previousElapsedTime = 0, this.loop();
    }
    loop() {
      const e = this.clock.getElapsedTime(), t = e - this.previousElapsedTime;
      this.previousElapsedTime = e, this.world.loop(t, e), this.camera.loop(t), this.renderer.loop(), window.requestAnimationFrame(() => this.loop());
    }
  }
  var Kr = {
    exports: {}
  };
  var tE = Kr.exports, Fp;
  function nE() {
    return Fp || (Fp = 1, (function(l, e) {
      (function(t, n) {
        n(e);
      })(tE, (function(t) {
        class n {
          constructor(o) {
            const [h, g] = o.split("-"), E = h.split(".");
            this.major = parseInt(E[0], 10), this.minor = parseInt(E[1], 10), this.patch = parseInt(E[2], 10), this.prerelease = g ?? null;
          }
          toString() {
            const o = [
              this.major,
              this.minor,
              this.patch
            ].join(".");
            return this.prerelease !== null ? [
              o,
              this.prerelease
            ].join("-") : o;
          }
        }
        class i {
          constructor(o) {
            this.controller_ = o;
          }
          get element() {
            return this.controller_.view.element;
          }
          get disabled() {
            return this.controller_.viewProps.get("disabled");
          }
          set disabled(o) {
            this.controller_.viewProps.set("disabled", o);
          }
          get hidden() {
            return this.controller_.viewProps.get("hidden");
          }
          set hidden(o) {
            this.controller_.viewProps.set("hidden", o);
          }
          dispose() {
            this.controller_.viewProps.set("disposed", true);
          }
        }
        class s {
          constructor(o) {
            this.target = o;
          }
        }
        class r extends s {
          constructor(o, h, g, E) {
            super(o), this.value = h, this.presetKey = g, this.last = E ?? true;
          }
        }
        class a extends s {
          constructor(o, h, g) {
            super(o), this.value = h, this.presetKey = g;
          }
        }
        class c extends s {
          constructor(o, h) {
            super(o), this.expanded = h;
          }
        }
        class u extends s {
          constructor(o, h) {
            super(o), this.index = h;
          }
        }
        function p(d) {
          return d;
        }
        function f(d) {
          return d == null;
        }
        function m(d, o) {
          if (d.length !== o.length) return false;
          for (let h = 0; h < d.length; h++) if (d[h] !== o[h]) return false;
          return true;
        }
        function v(d, o) {
          let h = d;
          do {
            const g = Object.getOwnPropertyDescriptor(h, o);
            if (g && (g.set !== void 0 || g.writable === true)) return true;
            h = Object.getPrototypeOf(h);
          } while (h !== null);
          return false;
        }
        const b = {
          alreadydisposed: () => "View has been already disposed",
          invalidparams: (d) => `Invalid parameters for '${d.name}'`,
          nomatchingcontroller: (d) => `No matching controller for '${d.key}'`,
          nomatchingview: (d) => `No matching view for '${JSON.stringify(d.params)}'`,
          notbindable: () => "Value is not bindable",
          propertynotfound: (d) => `Property '${d.name}' not found`,
          shouldneverhappen: () => "This error should never happen"
        };
        class _ {
          static alreadyDisposed() {
            return new _({
              type: "alreadydisposed"
            });
          }
          static notBindable() {
            return new _({
              type: "notbindable"
            });
          }
          static propertyNotFound(o) {
            return new _({
              type: "propertynotfound",
              context: {
                name: o
              }
            });
          }
          static shouldNeverHappen() {
            return new _({
              type: "shouldneverhappen"
            });
          }
          constructor(o) {
            var h;
            this.message = (h = b[o.type](o.context)) !== null && h !== void 0 ? h : "Unexpected error", this.name = this.constructor.name, this.stack = new Error(this.message).stack, this.type = o.type;
          }
        }
        class x {
          constructor(o, h, g) {
            this.obj_ = o, this.key_ = h, this.presetKey_ = g ?? h;
          }
          static isBindable(o) {
            return !(o === null || typeof o != "object" && typeof o != "function");
          }
          get key() {
            return this.key_;
          }
          get presetKey() {
            return this.presetKey_;
          }
          read() {
            return this.obj_[this.key_];
          }
          write(o) {
            this.obj_[this.key_] = o;
          }
          writeProperty(o, h) {
            const g = this.read();
            if (!x.isBindable(g)) throw _.notBindable();
            if (!(o in g)) throw _.propertyNotFound(o);
            g[o] = h;
          }
        }
        class w extends i {
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          get title() {
            var o;
            return (o = this.controller_.valueController.props.get("title")) !== null && o !== void 0 ? o : "";
          }
          set title(o) {
            this.controller_.valueController.props.set("title", o);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.controller_.valueController.emitter.on(o, () => {
              g(new s(this));
            }), this;
          }
        }
        class S {
          constructor() {
            this.observers_ = {};
          }
          on(o, h) {
            let g = this.observers_[o];
            return g || (g = this.observers_[o] = []), g.push({
              handler: h
            }), this;
          }
          off(o, h) {
            const g = this.observers_[o];
            return g && (this.observers_[o] = g.filter((E) => E.handler !== h)), this;
          }
          emit(o, h) {
            const g = this.observers_[o];
            g && g.forEach((E) => {
              E.handler(h);
            });
          }
        }
        const y = "tp";
        function M(d) {
          return (h, g) => [
            y,
            "-",
            d,
            "v",
            h ? `_${h}` : "",
            g ? `-${g}` : ""
          ].join("");
        }
        function C(d, o) {
          return (h) => o(d(h));
        }
        function R(d) {
          return d.rawValue;
        }
        function k(d, o) {
          d.emitter.on("change", C(R, o)), o(d.rawValue);
        }
        function T(d, o, h) {
          k(d.value(o), h);
        }
        function L(d, o, h) {
          h ? d.classList.add(o) : d.classList.remove(o);
        }
        function F(d, o) {
          return (h) => {
            L(d, o, h);
          };
        }
        function j(d, o) {
          k(d, (h) => {
            o.textContent = h ?? "";
          });
        }
        const Y = M("btn");
        class z {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(Y()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("button");
            g.classList.add(Y("b")), h.viewProps.bindDisabled(g), this.element.appendChild(g), this.buttonElement = g;
            const E = o.createElement("div");
            E.classList.add(Y("t")), j(h.props.value("title"), E), this.buttonElement.appendChild(E);
          }
        }
        class B {
          constructor(o, h) {
            this.emitter = new S(), this.onClick_ = this.onClick_.bind(this), this.props = h.props, this.viewProps = h.viewProps, this.view = new z(o, {
              props: this.props,
              viewProps: this.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class Z {
          constructor(o, h) {
            var g;
            this.constraint_ = h == null ? void 0 : h.constraint, this.equals_ = (g = h == null ? void 0 : h.equals) !== null && g !== void 0 ? g : ((E, N) => E === N), this.emitter = new S(), this.rawValue_ = o;
          }
          get constraint() {
            return this.constraint_;
          }
          get rawValue() {
            return this.rawValue_;
          }
          set rawValue(o) {
            this.setRawValue(o, {
              forceEmit: false,
              last: true
            });
          }
          setRawValue(o, h) {
            const g = h ?? {
              forceEmit: false,
              last: true
            }, E = this.constraint_ ? this.constraint_.constrain(o) : o, N = this.rawValue_;
            this.equals_(N, E) && !g.forceEmit || (this.emitter.emit("beforechange", {
              sender: this
            }), this.rawValue_ = E, this.emitter.emit("change", {
              options: g,
              previousRawValue: N,
              rawValue: E,
              sender: this
            }));
          }
        }
        class ie {
          constructor(o) {
            this.emitter = new S(), this.value_ = o;
          }
          get rawValue() {
            return this.value_;
          }
          set rawValue(o) {
            this.setRawValue(o, {
              forceEmit: false,
              last: true
            });
          }
          setRawValue(o, h) {
            const g = h ?? {
              forceEmit: false,
              last: true
            }, E = this.value_;
            E === o && !g.forceEmit || (this.emitter.emit("beforechange", {
              sender: this
            }), this.value_ = o, this.emitter.emit("change", {
              options: g,
              previousRawValue: E,
              rawValue: this.value_,
              sender: this
            }));
          }
        }
        function re(d, o) {
          const h = o == null ? void 0 : o.constraint, g = o == null ? void 0 : o.equals;
          return !h && !g ? new ie(d) : new Z(d, o);
        }
        class W {
          constructor(o) {
            this.emitter = new S(), this.valMap_ = o;
            for (const h in this.valMap_) this.valMap_[h].emitter.on("change", () => {
              this.emitter.emit("change", {
                key: h,
                sender: this
              });
            });
          }
          static createCore(o) {
            return Object.keys(o).reduce((g, E) => Object.assign(g, {
              [E]: re(o[E])
            }), {});
          }
          static fromObject(o) {
            const h = this.createCore(o);
            return new W(h);
          }
          get(o) {
            return this.valMap_[o].rawValue;
          }
          set(o, h) {
            this.valMap_[o].rawValue = h;
          }
          value(o) {
            return this.valMap_[o];
          }
        }
        function pe(d, o) {
          const g = Object.keys(o).reduce((E, N) => {
            if (E === void 0) return;
            const V = o[N], de = V(d[N]);
            return de.succeeded ? Object.assign(Object.assign({}, E), {
              [N]: de.value
            }) : void 0;
          }, {});
          return g;
        }
        function ae(d, o) {
          return d.reduce((h, g) => {
            if (h === void 0) return;
            const E = o(g);
            if (!(!E.succeeded || E.value === void 0)) return [
              ...h,
              E.value
            ];
          }, []);
        }
        function Te(d) {
          return d === null ? false : typeof d == "object";
        }
        function q(d) {
          return (o) => (h) => {
            if (!o && h === void 0) return {
              succeeded: false,
              value: void 0
            };
            if (o && h === void 0) return {
              succeeded: true,
              value: void 0
            };
            const g = d(h);
            return g !== void 0 ? {
              succeeded: true,
              value: g
            } : {
              succeeded: false,
              value: void 0
            };
          };
        }
        function le(d) {
          return {
            custom: (o) => q(o)(d),
            boolean: q((o) => typeof o == "boolean" ? o : void 0)(d),
            number: q((o) => typeof o == "number" ? o : void 0)(d),
            string: q((o) => typeof o == "string" ? o : void 0)(d),
            function: q((o) => typeof o == "function" ? o : void 0)(d),
            constant: (o) => q((h) => h === o ? o : void 0)(d),
            raw: q((o) => o)(d),
            object: (o) => q((h) => {
              if (Te(h)) return pe(h, o);
            })(d),
            array: (o) => q((h) => {
              if (Array.isArray(h)) return ae(h, o);
            })(d)
          };
        }
        const oe = {
          optional: le(true),
          required: le(false)
        };
        function ce(d, o) {
          const h = oe.required.object(o)(d);
          return h.succeeded ? h.value : void 0;
        }
        function K(d) {
          console.warn([
            `Missing '${d.key}' of ${d.target} in ${d.place}.`,
            "Please rebuild plugins with the latest core package."
          ].join(" "));
        }
        function ke(d) {
          return d && d.parentElement && d.parentElement.removeChild(d), null;
        }
        class Ce {
          constructor(o) {
            this.value_ = o;
          }
          static create(o) {
            return [
              new Ce(o),
              (h, g) => {
                o.setRawValue(h, g);
              }
            ];
          }
          get emitter() {
            return this.value_.emitter;
          }
          get rawValue() {
            return this.value_.rawValue;
          }
        }
        const Le = M("");
        function ve(d, o) {
          return F(d, Le(void 0, o));
        }
        class Ve extends W {
          constructor(o) {
            var h;
            super(o), this.onDisabledChange_ = this.onDisabledChange_.bind(this), this.onParentChange_ = this.onParentChange_.bind(this), this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this), [this.globalDisabled_, this.setGlobalDisabled_] = Ce.create(re(this.getGlobalDisabled_())), this.value("disabled").emitter.on("change", this.onDisabledChange_), this.value("parent").emitter.on("change", this.onParentChange_), (h = this.get("parent")) === null || h === void 0 || h.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_);
          }
          static create(o) {
            var h, g, E;
            const N = o ?? {};
            return new Ve(W.createCore({
              disabled: (h = N.disabled) !== null && h !== void 0 ? h : false,
              disposed: false,
              hidden: (g = N.hidden) !== null && g !== void 0 ? g : false,
              parent: (E = N.parent) !== null && E !== void 0 ? E : null
            }));
          }
          get globalDisabled() {
            return this.globalDisabled_;
          }
          bindClassModifiers(o) {
            k(this.globalDisabled_, ve(o, "disabled")), T(this, "hidden", ve(o, "hidden"));
          }
          bindDisabled(o) {
            k(this.globalDisabled_, (h) => {
              o.disabled = h;
            });
          }
          bindTabIndex(o) {
            k(this.globalDisabled_, (h) => {
              o.tabIndex = h ? -1 : 0;
            });
          }
          handleDispose(o) {
            this.value("disposed").emitter.on("change", (h) => {
              h && o();
            });
          }
          getGlobalDisabled_() {
            const o = this.get("parent");
            return (o ? o.globalDisabled.rawValue : false) || this.get("disabled");
          }
          updateGlobalDisabled_() {
            this.setGlobalDisabled_(this.getGlobalDisabled_());
          }
          onDisabledChange_() {
            this.updateGlobalDisabled_();
          }
          onParentGlobalDisabledChange_() {
            this.updateGlobalDisabled_();
          }
          onParentChange_(o) {
            var h;
            const g = o.previousRawValue;
            g == null ? void 0 : g.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_), (h = this.get("parent")) === null || h === void 0 || h.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_), this.updateGlobalDisabled_();
          }
        }
        function se() {
          return [
            "veryfirst",
            "first",
            "last",
            "verylast"
          ];
        }
        const ne = M(""), ge = {
          veryfirst: "vfst",
          first: "fst",
          last: "lst",
          verylast: "vlst"
        };
        class Ee {
          constructor(o) {
            this.parent_ = null, this.blade = o.blade, this.view = o.view, this.viewProps = o.viewProps;
            const h = this.view.element;
            this.blade.value("positions").emitter.on("change", () => {
              se().forEach((g) => {
                h.classList.remove(ne(void 0, ge[g]));
              }), this.blade.get("positions").forEach((g) => {
                h.classList.add(ne(void 0, ge[g]));
              });
            }), this.viewProps.handleDispose(() => {
              ke(h);
            });
          }
          get parent() {
            return this.parent_;
          }
          set parent(o) {
            if (this.parent_ = o, !("parent" in this.viewProps.valMap_)) {
              K({
                key: "parent",
                target: Ve.name,
                place: "BladeController.parent"
              });
              return;
            }
            this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
          }
        }
        const fe = "http://www.w3.org/2000/svg";
        function Fe(d) {
          d.offsetHeight;
        }
        function Ne(d, o) {
          const h = d.style.transition;
          d.style.transition = "none", o(), d.style.transition = h;
        }
        function Re(d) {
          return d.ontouchstart !== void 0;
        }
        function dt() {
          return globalThis;
        }
        function it() {
          return dt().document;
        }
        function D(d) {
          const o = d.ownerDocument.defaultView;
          return o && "document" in o ? d.getContext("2d", {
            willReadFrequently: true
          }) : null;
        }
        const A = {
          check: '<path d="M2 8l4 4l8 -8"/>',
          dropdown: '<path d="M5 7h6l-3 3 z"/>',
          p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
        };
        function $(d, o) {
          const h = d.createElementNS(fe, "svg");
          return h.innerHTML = A[o], h;
        }
        function he(d, o, h) {
          d.insertBefore(o, d.children[h]);
        }
        function me(d) {
          d.parentElement && d.parentElement.removeChild(d);
        }
        function xe(d) {
          for (; d.children.length > 0; ) d.removeChild(d.children[0]);
        }
        function Be(d) {
          for (; d.childNodes.length > 0; ) d.removeChild(d.childNodes[0]);
        }
        function O(d) {
          return d.relatedTarget ? d.relatedTarget : "explicitOriginalTarget" in d ? d.explicitOriginalTarget : null;
        }
        const G = M("lbl");
        function ye(d, o) {
          const h = d.createDocumentFragment();
          return o.split(`
`).map((E) => d.createTextNode(E)).forEach((E, N) => {
            N > 0 && h.appendChild(d.createElement("br")), h.appendChild(E);
          }), h;
        }
        class Me {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(G()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(G("l")), T(h.props, "label", (N) => {
              f(N) ? this.element.classList.add(G(void 0, "nol")) : (this.element.classList.remove(G(void 0, "nol")), Be(g), g.appendChild(ye(o, N)));
            }), this.element.appendChild(g), this.labelElement = g;
            const E = o.createElement("div");
            E.classList.add(G("v")), this.element.appendChild(E), this.valueElement = E;
          }
        }
        class be extends Ee {
          constructor(o, h) {
            const g = h.valueController.viewProps;
            super(Object.assign(Object.assign({}, h), {
              view: new Me(o, {
                props: h.props,
                viewProps: g
              }),
              viewProps: g
            })), this.props = h.props, this.valueController = h.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        const Ie = {
          id: "button",
          type: "blade",
          accept(d) {
            const o = oe, h = ce(d, {
              title: o.required.string,
              view: o.required.constant("button"),
              label: o.optional.string
            });
            return h ? {
              params: h
            } : null;
          },
          controller(d) {
            return new be(d.document, {
              blade: d.blade,
              props: W.fromObject({
                label: d.params.label
              }),
              valueController: new B(d.document, {
                props: W.fromObject({
                  title: d.params.title
                }),
                viewProps: d.viewProps
              })
            });
          },
          api(d) {
            return !(d.controller instanceof be) || !(d.controller.valueController instanceof B) ? null : new w(d.controller);
          }
        };
        class Ae extends Ee {
          constructor(o) {
            super(o), this.value = o.value;
          }
        }
        function qe() {
          return new W({
            positions: re([], {
              equals: m
            })
          });
        }
        class je extends W {
          constructor(o) {
            super(o);
          }
          static create(o) {
            const h = {
              completed: true,
              expanded: o,
              expandedHeight: null,
              shouldFixHeight: false,
              temporaryExpanded: null
            }, g = W.createCore(h);
            return new je(g);
          }
          get styleExpanded() {
            var o;
            return (o = this.get("temporaryExpanded")) !== null && o !== void 0 ? o : this.get("expanded");
          }
          get styleHeight() {
            if (!this.styleExpanded) return "0";
            const o = this.get("expandedHeight");
            return this.get("shouldFixHeight") && !f(o) ? `${o}px` : "auto";
          }
          bindExpandedClass(o, h) {
            const g = () => {
              this.styleExpanded ? o.classList.add(h) : o.classList.remove(h);
            };
            T(this, "expanded", g), T(this, "temporaryExpanded", g);
          }
          cleanUpTransition() {
            this.set("shouldFixHeight", false), this.set("expandedHeight", null), this.set("completed", true);
          }
        }
        function pt(d, o) {
          let h = 0;
          return Ne(o, () => {
            d.set("expandedHeight", null), d.set("temporaryExpanded", true), Fe(o), h = o.clientHeight, d.set("temporaryExpanded", null), Fe(o);
          }), h;
        }
        function U(d, o) {
          o.style.height = d.styleHeight;
        }
        function J(d, o) {
          d.value("expanded").emitter.on("beforechange", () => {
            if (d.set("completed", false), f(d.get("expandedHeight"))) {
              const h = pt(d, o);
              h > 0 && d.set("expandedHeight", h);
            }
            d.set("shouldFixHeight", true), Fe(o);
          }), d.emitter.on("change", () => {
            U(d, o);
          }), U(d, o), o.addEventListener("transitionend", (h) => {
            h.propertyName === "height" && d.cleanUpTransition();
          });
        }
        class ue extends i {
          constructor(o, h) {
            super(o), this.rackApi_ = h;
          }
        }
        function Se(d, o) {
          return d.addBlade(Object.assign(Object.assign({}, o), {
            view: "button"
          }));
        }
        function De(d, o) {
          return d.addBlade(Object.assign(Object.assign({}, o), {
            view: "folder"
          }));
        }
        function at(d, o) {
          const h = o ?? {};
          return d.addBlade(Object.assign(Object.assign({}, h), {
            view: "separator"
          }));
        }
        function Lt(d, o) {
          return d.addBlade(Object.assign(Object.assign({}, o), {
            view: "tab"
          }));
        }
        class Rt {
          constructor(o) {
            this.emitter = new S(), this.items_ = [], this.cache_ = /* @__PURE__ */ new Set(), this.onSubListAdd_ = this.onSubListAdd_.bind(this), this.onSubListRemove_ = this.onSubListRemove_.bind(this), this.extract_ = o;
          }
          get items() {
            return this.items_;
          }
          allItems() {
            return Array.from(this.cache_);
          }
          find(o) {
            for (const h of this.allItems()) if (o(h)) return h;
            return null;
          }
          includes(o) {
            return this.cache_.has(o);
          }
          add(o, h) {
            if (this.includes(o)) throw _.shouldNeverHappen();
            const g = h !== void 0 ? h : this.items_.length;
            this.items_.splice(g, 0, o), this.cache_.add(o);
            const E = this.extract_(o);
            E && (E.emitter.on("add", this.onSubListAdd_), E.emitter.on("remove", this.onSubListRemove_), E.allItems().forEach((N) => {
              this.cache_.add(N);
            })), this.emitter.emit("add", {
              index: g,
              item: o,
              root: this,
              target: this
            });
          }
          remove(o) {
            const h = this.items_.indexOf(o);
            if (h < 0) return;
            this.items_.splice(h, 1), this.cache_.delete(o);
            const g = this.extract_(o);
            g && (g.emitter.off("add", this.onSubListAdd_), g.emitter.off("remove", this.onSubListRemove_)), this.emitter.emit("remove", {
              index: h,
              item: o,
              root: this,
              target: this
            });
          }
          onSubListAdd_(o) {
            this.cache_.add(o.item), this.emitter.emit("add", {
              index: o.index,
              item: o.item,
              root: this,
              target: o.target
            });
          }
          onSubListRemove_(o) {
            this.cache_.delete(o.item), this.emitter.emit("remove", {
              index: o.index,
              item: o.item,
              root: this,
              target: o.target
            });
          }
        }
        class bn extends i {
          constructor(o) {
            super(o), this.onBindingChange_ = this.onBindingChange_.bind(this), this.emitter_ = new S(), this.controller_.binding.emitter.on("change", this.onBindingChange_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingChange_(o) {
            const h = o.sender.target.read();
            this.emitter_.emit("change", {
              event: new r(this, h, this.controller_.binding.target.presetKey, o.options.last)
            });
          }
        }
        class nt extends be {
          constructor(o, h) {
            super(o, h), this.binding = h.binding;
          }
        }
        class an extends i {
          constructor(o) {
            super(o), this.onBindingUpdate_ = this.onBindingUpdate_.bind(this), this.emitter_ = new S(), this.controller_.binding.emitter.on("update", this.onBindingUpdate_);
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
          refresh() {
            this.controller_.binding.read();
          }
          onBindingUpdate_(o) {
            const h = o.sender.target.read();
            this.emitter_.emit("update", {
              event: new a(this, h, this.controller_.binding.target.presetKey)
            });
          }
        }
        class Tt extends be {
          constructor(o, h) {
            super(o, h), this.binding = h.binding, this.viewProps.bindDisabled(this.binding.ticker), this.viewProps.handleDispose(() => {
              this.binding.dispose();
            });
          }
        }
        function Io(d) {
          return d instanceof vs ? d.apiSet_ : d instanceof ue ? d.rackApi_.apiSet_ : null;
        }
        function ki(d, o) {
          const h = d.find((g) => g.controller_ === o);
          if (!h) throw _.shouldNeverHappen();
          return h;
        }
        function Do(d, o, h) {
          if (!x.isBindable(d)) throw _.notBindable();
          return new x(d, o, h);
        }
        class vs extends i {
          constructor(o, h) {
            super(o), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this), this.onRackInputChange_ = this.onRackInputChange_.bind(this), this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this), this.emitter_ = new S(), this.apiSet_ = new Rt(Io), this.pool_ = h;
            const g = this.controller_.rack;
            g.emitter.on("add", this.onRackAdd_), g.emitter.on("remove", this.onRackRemove_), g.emitter.on("inputchange", this.onRackInputChange_), g.emitter.on("monitorupdate", this.onRackMonitorUpdate_), g.children.forEach((E) => {
              this.setUpApi_(E);
            });
          }
          get children() {
            return this.controller_.rack.children.map((o) => ki(this.apiSet_, o));
          }
          addInput(o, h, g) {
            const E = g ?? {}, N = this.controller_.view.element.ownerDocument, V = this.pool_.createInput(N, Do(o, h, E.presetKey), E), de = new bn(V);
            return this.add(de, E.index);
          }
          addMonitor(o, h, g) {
            const E = g ?? {}, N = this.controller_.view.element.ownerDocument, V = this.pool_.createMonitor(N, Do(o, h), E), de = new an(V);
            return this.add(de, E.index);
          }
          addFolder(o) {
            return De(this, o);
          }
          addButton(o) {
            return Se(this, o);
          }
          addSeparator(o) {
            return at(this, o);
          }
          addTab(o) {
            return Lt(this, o);
          }
          add(o, h) {
            this.controller_.rack.add(o.controller_, h);
            const g = this.apiSet_.find((E) => E.controller_ === o.controller_);
            return g && this.apiSet_.remove(g), this.apiSet_.add(o), o;
          }
          remove(o) {
            this.controller_.rack.remove(o.controller_);
          }
          addBlade(o) {
            const h = this.controller_.view.element.ownerDocument, g = this.pool_.createBlade(h, o), E = this.pool_.createBladeApi(g);
            return this.add(E, o.index);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
          setUpApi_(o) {
            this.apiSet_.find((g) => g.controller_ === o) || this.apiSet_.add(this.pool_.createBladeApi(o));
          }
          onRackAdd_(o) {
            this.setUpApi_(o.bladeController);
          }
          onRackRemove_(o) {
            if (o.isRoot) {
              const h = ki(this.apiSet_, o.bladeController);
              this.apiSet_.remove(h);
            }
          }
          onRackInputChange_(o) {
            const h = o.bladeController;
            if (h instanceof nt) {
              const g = ki(this.apiSet_, h), E = h.binding;
              this.emitter_.emit("change", {
                event: new r(g, E.target.read(), E.target.presetKey, o.options.last)
              });
            } else if (h instanceof Ae) {
              const g = ki(this.apiSet_, h);
              this.emitter_.emit("change", {
                event: new r(g, h.value.rawValue, void 0, o.options.last)
              });
            }
          }
          onRackMonitorUpdate_(o) {
            if (!(o.bladeController instanceof Tt)) throw _.shouldNeverHappen();
            const h = ki(this.apiSet_, o.bladeController), g = o.bladeController.binding;
            this.emitter_.emit("update", {
              event: new a(h, g.target.read(), g.target.presetKey)
            });
          }
        }
        class I extends ue {
          constructor(o, h) {
            super(o, new vs(o.rackController, h)), this.emitter_ = new S(), this.controller_.foldable.value("expanded").emitter.on("change", (g) => {
              this.emitter_.emit("fold", {
                event: new c(this, g.sender.rawValue)
              });
            }), this.rackApi_.on("change", (g) => {
              this.emitter_.emit("change", {
                event: g
              });
            }), this.rackApi_.on("update", (g) => {
              this.emitter_.emit("update", {
                event: g
              });
            });
          }
          get expanded() {
            return this.controller_.foldable.get("expanded");
          }
          set expanded(o) {
            this.controller_.foldable.set("expanded", o);
          }
          get title() {
            return this.controller_.props.get("title");
          }
          set title(o) {
            this.controller_.props.set("title", o);
          }
          get children() {
            return this.rackApi_.children;
          }
          addInput(o, h, g) {
            return this.rackApi_.addInput(o, h, g);
          }
          addMonitor(o, h, g) {
            return this.rackApi_.addMonitor(o, h, g);
          }
          addFolder(o) {
            return this.rackApi_.addFolder(o);
          }
          addButton(o) {
            return this.rackApi_.addButton(o);
          }
          addSeparator(o) {
            return this.rackApi_.addSeparator(o);
          }
          addTab(o) {
            return this.rackApi_.addTab(o);
          }
          add(o, h) {
            return this.rackApi_.add(o, h);
          }
          remove(o) {
            this.rackApi_.remove(o);
          }
          addBlade(o) {
            return this.rackApi_.addBlade(o);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
        }
        class X extends Ee {
          constructor(o) {
            super({
              blade: o.blade,
              view: o.view,
              viewProps: o.rackController.viewProps
            }), this.rackController = o.rackController;
          }
        }
        class Q {
          constructor(o, h) {
            const g = M(h.viewName);
            this.element = o.createElement("div"), this.element.classList.add(g()), h.viewProps.bindClassModifiers(this.element);
          }
        }
        function H(d, o) {
          for (let h = 0; h < d.length; h++) {
            const g = d[h];
            if (g instanceof nt && g.binding === o) return g;
          }
          return null;
        }
        function ee(d, o) {
          for (let h = 0; h < d.length; h++) {
            const g = d[h];
            if (g instanceof Tt && g.binding === o) return g;
          }
          return null;
        }
        function Oe(d, o) {
          for (let h = 0; h < d.length; h++) {
            const g = d[h];
            if (g instanceof Ae && g.value === o) return g;
          }
          return null;
        }
        function He(d) {
          return d instanceof Ze ? d.rack : d instanceof X ? d.rackController.rack : null;
        }
        function Ke(d) {
          const o = He(d);
          return o ? o.bcSet_ : null;
        }
        class $e {
          constructor(o) {
            var h, g;
            this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this), this.onSetAdd_ = this.onSetAdd_.bind(this), this.onSetRemove_ = this.onSetRemove_.bind(this), this.onChildDispose_ = this.onChildDispose_.bind(this), this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this), this.onChildInputChange_ = this.onChildInputChange_.bind(this), this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this), this.onChildValueChange_ = this.onChildValueChange_.bind(this), this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this), this.onDescendantLayout_ = this.onDescendantLayout_.bind(this), this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this), this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this), this.emitter = new S(), this.blade_ = (h = o.blade) !== null && h !== void 0 ? h : null, (g = this.blade_) === null || g === void 0 || g.value("positions").emitter.on("change", this.onBladePositionsChange_), this.viewProps = o.viewProps, this.bcSet_ = new Rt(Ke), this.bcSet_.emitter.on("add", this.onSetAdd_), this.bcSet_.emitter.on("remove", this.onSetRemove_);
          }
          get children() {
            return this.bcSet_.items;
          }
          add(o, h) {
            var g;
            (g = o.parent) === null || g === void 0 || g.remove(o), v(o, "parent") ? o.parent = this : (o.parent_ = this, K({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.add"
            })), this.bcSet_.add(o, h);
          }
          remove(o) {
            v(o, "parent") ? o.parent = null : (o.parent_ = null, K({
              key: "parent",
              target: "BladeController",
              place: "BladeRack.remove"
            })), this.bcSet_.remove(o);
          }
          find(o) {
            return this.bcSet_.allItems().filter((h) => h instanceof o);
          }
          onSetAdd_(o) {
            this.updatePositions_();
            const h = o.target === o.root;
            if (this.emitter.emit("add", {
              bladeController: o.item,
              index: o.index,
              isRoot: h,
              sender: this
            }), !h) return;
            const g = o.item;
            if (g.viewProps.emitter.on("change", this.onChildViewPropsChange_), g.blade.value("positions").emitter.on("change", this.onChildPositionsChange_), g.viewProps.handleDispose(this.onChildDispose_), g instanceof nt) g.binding.emitter.on("change", this.onChildInputChange_);
            else if (g instanceof Tt) g.binding.emitter.on("update", this.onChildMonitorUpdate_);
            else if (g instanceof Ae) g.value.emitter.on("change", this.onChildValueChange_);
            else {
              const E = He(g);
              if (E) {
                const N = E.emitter;
                N.on("layout", this.onDescendantLayout_), N.on("inputchange", this.onDescendantInputChange_), N.on("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          onSetRemove_(o) {
            this.updatePositions_();
            const h = o.target === o.root;
            if (this.emitter.emit("remove", {
              bladeController: o.item,
              isRoot: h,
              sender: this
            }), !h) return;
            const g = o.item;
            if (g instanceof nt) g.binding.emitter.off("change", this.onChildInputChange_);
            else if (g instanceof Tt) g.binding.emitter.off("update", this.onChildMonitorUpdate_);
            else if (g instanceof Ae) g.value.emitter.off("change", this.onChildValueChange_);
            else {
              const E = He(g);
              if (E) {
                const N = E.emitter;
                N.off("layout", this.onDescendantLayout_), N.off("inputchange", this.onDescendantInputChange_), N.off("monitorupdate", this.onDescendantMonitorUpdate_);
              }
            }
          }
          updatePositions_() {
            const o = this.bcSet_.items.filter((E) => !E.viewProps.get("hidden")), h = o[0], g = o[o.length - 1];
            this.bcSet_.items.forEach((E) => {
              const N = [];
              E === h && (N.push("first"), (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && N.push("veryfirst")), E === g && (N.push("last"), (!this.blade_ || this.blade_.get("positions").includes("verylast")) && N.push("verylast")), E.blade.set("positions", N);
            });
          }
          onChildPositionsChange_() {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildViewPropsChange_(o) {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onChildDispose_() {
            this.bcSet_.items.filter((h) => h.viewProps.get("disposed")).forEach((h) => {
              this.bcSet_.remove(h);
            });
          }
          onChildInputChange_(o) {
            const h = H(this.find(nt), o.sender);
            if (!h) throw _.alreadyDisposed();
            this.emitter.emit("inputchange", {
              bladeController: h,
              options: o.options,
              sender: this
            });
          }
          onChildMonitorUpdate_(o) {
            const h = ee(this.find(Tt), o.sender);
            if (!h) throw _.alreadyDisposed();
            this.emitter.emit("monitorupdate", {
              bladeController: h,
              sender: this
            });
          }
          onChildValueChange_(o) {
            const h = Oe(this.find(Ae), o.sender);
            if (!h) throw _.alreadyDisposed();
            this.emitter.emit("inputchange", {
              bladeController: h,
              options: o.options,
              sender: this
            });
          }
          onDescendantLayout_(o) {
            this.updatePositions_(), this.emitter.emit("layout", {
              sender: this
            });
          }
          onDescendantInputChange_(o) {
            this.emitter.emit("inputchange", {
              bladeController: o.bladeController,
              options: o.options,
              sender: this
            });
          }
          onDescendantMonitorUpdate_(o) {
            this.emitter.emit("monitorupdate", {
              bladeController: o.bladeController,
              sender: this
            });
          }
          onBladePositionsChange_() {
            this.updatePositions_();
          }
        }
        class Ze extends Ee {
          constructor(o, h) {
            super(Object.assign(Object.assign({}, h), {
              view: new Q(o, {
                viewName: "brk",
                viewProps: h.viewProps
              })
            })), this.onRackAdd_ = this.onRackAdd_.bind(this), this.onRackRemove_ = this.onRackRemove_.bind(this);
            const g = new $e({
              blade: h.root ? void 0 : h.blade,
              viewProps: h.viewProps
            });
            g.emitter.on("add", this.onRackAdd_), g.emitter.on("remove", this.onRackRemove_), this.rack = g, this.viewProps.handleDispose(() => {
              for (let E = this.rack.children.length - 1; E >= 0; E--) this.rack.children[E].viewProps.set("disposed", true);
            });
          }
          onRackAdd_(o) {
            o.isRoot && he(this.view.element, o.bladeController.view.element, o.index);
          }
          onRackRemove_(o) {
            o.isRoot && me(o.bladeController.view.element);
          }
        }
        const Je = M("cnt");
        class et {
          constructor(o, h) {
            var g;
            this.className_ = M((g = h.viewName) !== null && g !== void 0 ? g : "fld"), this.element = o.createElement("div"), this.element.classList.add(this.className_(), Je()), h.viewProps.bindClassModifiers(this.element), this.foldable_ = h.foldable, this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")), T(this.foldable_, "completed", F(this.element, this.className_(void 0, "cpl")));
            const E = o.createElement("button");
            E.classList.add(this.className_("b")), T(h.props, "title", (Ge) => {
              f(Ge) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"));
            }), h.viewProps.bindDisabled(E), this.element.appendChild(E), this.buttonElement = E;
            const N = o.createElement("div");
            N.classList.add(this.className_("i")), this.element.appendChild(N);
            const V = o.createElement("div");
            V.classList.add(this.className_("t")), j(h.props.value("title"), V), this.buttonElement.appendChild(V), this.titleElement = V;
            const de = o.createElement("div");
            de.classList.add(this.className_("m")), this.buttonElement.appendChild(de);
            const Ue = h.containerElement;
            Ue.classList.add(this.className_("c")), this.element.appendChild(Ue), this.containerElement = Ue;
          }
        }
        class vt extends X {
          constructor(o, h) {
            var g;
            const E = je.create((g = h.expanded) !== null && g !== void 0 ? g : true), N = new Ze(o, {
              blade: h.blade,
              root: h.root,
              viewProps: h.viewProps
            });
            super(Object.assign(Object.assign({}, h), {
              rackController: N,
              view: new et(o, {
                containerElement: N.view.element,
                foldable: E,
                props: h.props,
                viewName: h.root ? "rot" : void 0,
                viewProps: h.viewProps
              })
            })), this.onTitleClick_ = this.onTitleClick_.bind(this), this.props = h.props, this.foldable = E, J(this.foldable, this.view.containerElement), this.rackController.rack.emitter.on("add", () => {
              this.foldable.cleanUpTransition();
            }), this.rackController.rack.emitter.on("remove", () => {
              this.foldable.cleanUpTransition();
            }), this.view.buttonElement.addEventListener("click", this.onTitleClick_);
          }
          get document() {
            return this.view.element.ownerDocument;
          }
          onTitleClick_() {
            this.foldable.set("expanded", !this.foldable.get("expanded"));
          }
        }
        const Jt = {
          id: "folder",
          type: "blade",
          accept(d) {
            const o = oe, h = ce(d, {
              title: o.required.string,
              view: o.required.constant("folder"),
              expanded: o.optional.boolean
            });
            return h ? {
              params: h
            } : null;
          },
          controller(d) {
            return new vt(d.document, {
              blade: d.blade,
              expanded: d.params.expanded,
              props: W.fromObject({
                title: d.params.title
              }),
              viewProps: d.viewProps
            });
          },
          api(d) {
            return d.controller instanceof vt ? new I(d.controller, d.pool) : null;
          }
        };
        class jt extends Ae {
          constructor(o, h) {
            const g = h.valueController.viewProps;
            super(Object.assign(Object.assign({}, h), {
              value: h.valueController.value,
              view: new Me(o, {
                props: h.props,
                viewProps: g
              }),
              viewProps: g
            })), this.props = h.props, this.valueController = h.valueController, this.view.valueElement.appendChild(this.valueController.view.element);
          }
        }
        class Rn extends i {
        }
        const bt = M("spr");
        class tt {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(bt()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("hr");
            g.classList.add(bt("r")), this.element.appendChild(g);
          }
        }
        class _s extends Ee {
          constructor(o, h) {
            super(Object.assign(Object.assign({}, h), {
              view: new tt(o, {
                viewProps: h.viewProps
              })
            }));
          }
        }
        const It = {
          id: "separator",
          type: "blade",
          accept(d) {
            const h = ce(d, {
              view: oe.required.constant("separator")
            });
            return h ? {
              params: h
            } : null;
          },
          controller(d) {
            return new _s(d.document, {
              blade: d.blade,
              viewProps: d.viewProps
            });
          },
          api(d) {
            return d.controller instanceof _s ? new Rn(d.controller) : null;
          }
        }, ln = M("tbi");
        class ko {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(ln()), h.viewProps.bindClassModifiers(this.element), T(h.props, "selected", (N) => {
              N ? this.element.classList.add(ln(void 0, "sel")) : this.element.classList.remove(ln(void 0, "sel"));
            });
            const g = o.createElement("button");
            g.classList.add(ln("b")), h.viewProps.bindDisabled(g), this.element.appendChild(g), this.buttonElement = g;
            const E = o.createElement("div");
            E.classList.add(ln("t")), j(h.props.value("title"), E), this.buttonElement.appendChild(E), this.titleElement = E;
          }
        }
        class Ni {
          constructor(o, h) {
            this.emitter = new S(), this.onClick_ = this.onClick_.bind(this), this.props = h.props, this.viewProps = h.viewProps, this.view = new ko(o, {
              props: h.props,
              viewProps: h.viewProps
            }), this.view.buttonElement.addEventListener("click", this.onClick_);
          }
          onClick_() {
            this.emitter.emit("click", {
              sender: this
            });
          }
        }
        class xs {
          constructor(o, h) {
            this.onItemClick_ = this.onItemClick_.bind(this), this.ic_ = new Ni(o, {
              props: h.itemProps,
              viewProps: Ve.create()
            }), this.ic_.emitter.on("click", this.onItemClick_), this.cc_ = new Ze(o, {
              blade: qe(),
              viewProps: Ve.create()
            }), this.props = h.props, T(this.props, "selected", (g) => {
              this.itemController.props.set("selected", g), this.contentController.viewProps.set("hidden", !g);
            });
          }
          get itemController() {
            return this.ic_;
          }
          get contentController() {
            return this.cc_;
          }
          onItemClick_() {
            this.props.set("selected", true);
          }
        }
        class Gt {
          constructor(o, h) {
            this.controller_ = o, this.rackApi_ = h;
          }
          get title() {
            var o;
            return (o = this.controller_.itemController.props.get("title")) !== null && o !== void 0 ? o : "";
          }
          set title(o) {
            this.controller_.itemController.props.set("title", o);
          }
          get selected() {
            return this.controller_.props.get("selected");
          }
          set selected(o) {
            this.controller_.props.set("selected", o);
          }
          get children() {
            return this.rackApi_.children;
          }
          addButton(o) {
            return this.rackApi_.addButton(o);
          }
          addFolder(o) {
            return this.rackApi_.addFolder(o);
          }
          addSeparator(o) {
            return this.rackApi_.addSeparator(o);
          }
          addTab(o) {
            return this.rackApi_.addTab(o);
          }
          add(o, h) {
            this.rackApi_.add(o, h);
          }
          remove(o) {
            this.rackApi_.remove(o);
          }
          addInput(o, h, g) {
            return this.rackApi_.addInput(o, h, g);
          }
          addMonitor(o, h, g) {
            return this.rackApi_.addMonitor(o, h, g);
          }
          addBlade(o) {
            return this.rackApi_.addBlade(o);
          }
        }
        class In extends ue {
          constructor(o, h) {
            super(o, new vs(o.rackController, h)), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.onSelect_ = this.onSelect_.bind(this), this.emitter_ = new S(), this.pageApiMap_ = /* @__PURE__ */ new Map(), this.rackApi_.on("change", (g) => {
              this.emitter_.emit("change", {
                event: g
              });
            }), this.rackApi_.on("update", (g) => {
              this.emitter_.emit("update", {
                event: g
              });
            }), this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_), this.controller_.pageSet.emitter.on("add", this.onPageAdd_), this.controller_.pageSet.emitter.on("remove", this.onPageRemove_), this.controller_.pageSet.items.forEach((g) => {
              this.setUpPageApi_(g);
            });
          }
          get pages() {
            return this.controller_.pageSet.items.map((o) => {
              const h = this.pageApiMap_.get(o);
              if (!h) throw _.shouldNeverHappen();
              return h;
            });
          }
          addPage(o) {
            const h = this.controller_.view.element.ownerDocument, g = new xs(h, {
              itemProps: W.fromObject({
                selected: false,
                title: o.title
              }),
              props: W.fromObject({
                selected: false
              })
            });
            this.controller_.add(g, o.index);
            const E = this.pageApiMap_.get(g);
            if (!E) throw _.shouldNeverHappen();
            return E;
          }
          removePage(o) {
            this.controller_.remove(o);
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
          setUpPageApi_(o) {
            const h = this.rackApi_.apiSet_.find((E) => E.controller_ === o.contentController);
            if (!h) throw _.shouldNeverHappen();
            const g = new Gt(o, h);
            this.pageApiMap_.set(o, g);
          }
          onPageAdd_(o) {
            this.setUpPageApi_(o.item);
          }
          onPageRemove_(o) {
            if (!this.pageApiMap_.get(o.item)) throw _.shouldNeverHappen();
            this.pageApiMap_.delete(o.item);
          }
          onSelect_(o) {
            this.emitter_.emit("select", {
              event: new u(this, o.rawValue)
            });
          }
        }
        const bs = -1;
        class Qt {
          constructor() {
            this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this), this.empty = re(true), this.selectedIndex = re(bs), this.items_ = [];
          }
          add(o, h) {
            const g = h ?? this.items_.length;
            this.items_.splice(g, 0, o), o.emitter.on("change", this.onItemSelectedChange_), this.keepSelection_();
          }
          remove(o) {
            const h = this.items_.indexOf(o);
            h < 0 || (this.items_.splice(h, 1), o.emitter.off("change", this.onItemSelectedChange_), this.keepSelection_());
          }
          keepSelection_() {
            if (this.items_.length === 0) {
              this.selectedIndex.rawValue = bs, this.empty.rawValue = true;
              return;
            }
            const o = this.items_.findIndex((h) => h.rawValue);
            o < 0 ? (this.items_.forEach((h, g) => {
              h.rawValue = g === 0;
            }), this.selectedIndex.rawValue = 0) : (this.items_.forEach((h, g) => {
              h.rawValue = g === o;
            }), this.selectedIndex.rawValue = o), this.empty.rawValue = false;
          }
          onItemSelectedChange_(o) {
            if (o.rawValue) {
              const h = this.items_.findIndex((g) => g === o.sender);
              this.items_.forEach((g, E) => {
                g.rawValue = E === h;
              }), this.selectedIndex.rawValue = h;
            } else this.keepSelection_();
          }
        }
        const Gn = M("tab");
        class pl {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(Gn(), Je()), h.viewProps.bindClassModifiers(this.element), k(h.empty, F(this.element, Gn(void 0, "nop")));
            const g = o.createElement("div");
            g.classList.add(Gn("t")), this.element.appendChild(g), this.itemsElement = g;
            const E = o.createElement("div");
            E.classList.add(Gn("i")), this.element.appendChild(E);
            const N = h.contentsElement;
            N.classList.add(Gn("c")), this.element.appendChild(N), this.contentsElement = N;
          }
        }
        class _r extends X {
          constructor(o, h) {
            const g = new Ze(o, {
              blade: h.blade,
              viewProps: h.viewProps
            }), E = new Qt();
            super({
              blade: h.blade,
              rackController: g,
              view: new pl(o, {
                contentsElement: g.view.element,
                empty: E.empty,
                viewProps: h.viewProps
              })
            }), this.onPageAdd_ = this.onPageAdd_.bind(this), this.onPageRemove_ = this.onPageRemove_.bind(this), this.pageSet_ = new Rt(() => null), this.pageSet_.emitter.on("add", this.onPageAdd_), this.pageSet_.emitter.on("remove", this.onPageRemove_), this.tab = E;
          }
          get pageSet() {
            return this.pageSet_;
          }
          add(o, h) {
            this.pageSet_.add(o, h);
          }
          remove(o) {
            this.pageSet_.remove(this.pageSet_.items[o]);
          }
          onPageAdd_(o) {
            const h = o.item;
            he(this.view.itemsElement, h.itemController.view.element, o.index), h.itemController.viewProps.set("parent", this.viewProps), this.rackController.rack.add(h.contentController, o.index), this.tab.add(h.props.value("selected"));
          }
          onPageRemove_(o) {
            const h = o.item;
            me(h.itemController.view.element), h.itemController.viewProps.set("parent", null), this.rackController.rack.remove(h.contentController), this.tab.remove(h.props.value("selected"));
          }
        }
        const cu = {
          id: "tab",
          type: "blade",
          accept(d) {
            const o = oe, h = ce(d, {
              pages: o.required.array(o.required.object({
                title: o.required.string
              })),
              view: o.required.constant("tab")
            });
            return !h || h.pages.length === 0 ? null : {
              params: h
            };
          },
          controller(d) {
            const o = new _r(d.document, {
              blade: d.blade,
              viewProps: d.viewProps
            });
            return d.params.pages.forEach((h) => {
              const g = new xs(d.document, {
                itemProps: W.fromObject({
                  selected: false,
                  title: h.title
                }),
                props: W.fromObject({
                  selected: false
                })
              });
              o.add(g);
            }), o;
          },
          api(d) {
            return d.controller instanceof _r ? new In(d.controller, d.pool) : null;
          }
        };
        function Qm(d, o) {
          const h = d.accept(o.params);
          if (!h) return null;
          const g = oe.optional.boolean(o.params.disabled).value, E = oe.optional.boolean(o.params.hidden).value;
          return d.controller({
            blade: qe(),
            document: o.document,
            params: Object.assign(Object.assign({}, h.params), {
              disabled: g,
              hidden: E
            }),
            viewProps: Ve.create({
              disabled: g,
              hidden: E
            })
          });
        }
        class eg {
          constructor() {
            this.disabled = false, this.emitter = new S();
          }
          dispose() {
          }
          tick() {
            this.disabled || this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class tg {
          constructor(o, h) {
            this.disabled_ = false, this.timerId_ = null, this.onTick_ = this.onTick_.bind(this), this.doc_ = o, this.emitter = new S(), this.interval_ = h, this.setTimer_();
          }
          get disabled() {
            return this.disabled_;
          }
          set disabled(o) {
            this.disabled_ = o, this.disabled_ ? this.clearTimer_() : this.setTimer_();
          }
          dispose() {
            this.clearTimer_();
          }
          clearTimer_() {
            if (this.timerId_ === null) return;
            const o = this.doc_.defaultView;
            o && o.clearInterval(this.timerId_), this.timerId_ = null;
          }
          setTimer_() {
            if (this.clearTimer_(), this.interval_ <= 0) return;
            const o = this.doc_.defaultView;
            o && (this.timerId_ = o.setInterval(this.onTick_, this.interval_));
          }
          onTick_() {
            this.disabled_ || this.emitter.emit("tick", {
              sender: this
            });
          }
        }
        class ng {
          constructor(o) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.reader = o.reader, this.writer = o.writer, this.emitter = new S(), this.value = o.value, this.value.emitter.on("change", this.onValueChange_), this.target = o.target, this.read();
          }
          read() {
            const o = this.target.read();
            o !== void 0 && (this.value.rawValue = this.reader(o));
          }
          write_(o) {
            this.writer(this.target, o);
          }
          onValueChange_(o) {
            this.write_(o.rawValue), this.emitter.emit("change", {
              options: o.options,
              rawValue: o.rawValue,
              sender: this
            });
          }
        }
        function hu(d, o) {
          for (; d.length < o; ) d.push(void 0);
        }
        function ig(d) {
          const o = [];
          return hu(o, d), re(o);
        }
        function sg(d) {
          const o = d.indexOf(void 0);
          return o < 0 ? d : d.slice(0, o);
        }
        function rg(d, o) {
          const h = [
            ...sg(d),
            o
          ];
          return h.length > d.length ? h.splice(0, h.length - d.length) : hu(h, d.length), h;
        }
        class og {
          constructor(o) {
            this.onTick_ = this.onTick_.bind(this), this.reader_ = o.reader, this.target = o.target, this.emitter = new S(), this.value = o.value, this.ticker = o.ticker, this.ticker.emitter.on("tick", this.onTick_), this.read();
          }
          dispose() {
            this.ticker.dispose();
          }
          read() {
            const o = this.target.read();
            if (o === void 0) return;
            const h = this.value.rawValue, g = this.reader_(o);
            this.value.rawValue = rg(h, g), this.emitter.emit("update", {
              rawValue: g,
              sender: this
            });
          }
          onTick_(o) {
            this.read();
          }
        }
        class xr {
          constructor(o) {
            this.constraints = o;
          }
          constrain(o) {
            return this.constraints.reduce((h, g) => g.constrain(h), o);
          }
        }
        function Hn(d, o) {
          if (d instanceof o) return d;
          if (d instanceof xr) {
            const h = d.constraints.reduce((g, E) => g || (E instanceof o ? E : null), null);
            if (h) return h;
          }
          return null;
        }
        class ys {
          constructor(o) {
            this.values = W.fromObject({
              max: o.max,
              min: o.min
            });
          }
          constrain(o) {
            const h = this.values.get("max"), g = this.values.get("min");
            return Math.min(Math.max(o, g), h);
          }
        }
        class br {
          constructor(o) {
            this.values = W.fromObject({
              options: o
            });
          }
          get options() {
            return this.values.get("options");
          }
          constrain(o) {
            const h = this.values.get("options");
            return h.length === 0 || h.filter((E) => E.value === o).length > 0 ? o : h[0].value;
          }
        }
        class uu {
          constructor(o) {
            this.values = W.fromObject({
              max: o.max,
              min: o.min
            });
          }
          get maxValue() {
            return this.values.get("max");
          }
          get minValue() {
            return this.values.get("min");
          }
          constrain(o) {
            const h = this.values.get("max"), g = this.values.get("min");
            let E = o;
            return f(g) || (E = Math.max(E, g)), f(h) || (E = Math.min(E, h)), E;
          }
        }
        class No {
          constructor(o, h = 0) {
            this.step = o, this.origin = h;
          }
          constrain(o) {
            const h = this.origin % this.step, g = Math.round((o - h) / this.step);
            return h + g * this.step;
          }
        }
        const fl = M("lst");
        class ag {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.props_ = h.props, this.element = o.createElement("div"), this.element.classList.add(fl()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("select");
            g.classList.add(fl("s")), h.viewProps.bindDisabled(g), this.element.appendChild(g), this.selectElement = g;
            const E = o.createElement("div");
            E.classList.add(fl("m")), E.appendChild($(o, "dropdown")), this.element.appendChild(E), h.value.emitter.on("change", this.onValueChange_), this.value_ = h.value, T(this.props_, "options", (N) => {
              xe(this.selectElement), N.forEach((V) => {
                const de = o.createElement("option");
                de.textContent = V.text, this.selectElement.appendChild(de);
              }), this.update_();
            });
          }
          update_() {
            const o = this.props_.get("options").map((h) => h.value);
            this.selectElement.selectedIndex = o.indexOf(this.value_.rawValue);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class yr {
          constructor(o, h) {
            this.onSelectChange_ = this.onSelectChange_.bind(this), this.props = h.props, this.value = h.value, this.viewProps = h.viewProps, this.view = new ag(o, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.selectElement.addEventListener("change", this.onSelectChange_);
          }
          onSelectChange_(o) {
            const h = o.currentTarget;
            this.value.rawValue = this.props.get("options")[h.selectedIndex].value;
          }
        }
        const du = M("pop");
        class lg {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(du()), h.viewProps.bindClassModifiers(this.element), k(h.shows, F(this.element, du(void 0, "v")));
          }
        }
        class pu {
          constructor(o, h) {
            this.shows = re(false), this.viewProps = h.viewProps, this.view = new lg(o, {
              shows: this.shows,
              viewProps: this.viewProps
            });
          }
        }
        const fu = M("txt");
        class cg {
          constructor(o, h) {
            this.onChange_ = this.onChange_.bind(this), this.element = o.createElement("div"), this.element.classList.add(fu()), h.viewProps.bindClassModifiers(this.element), this.props_ = h.props, this.props_.emitter.on("change", this.onChange_);
            const g = o.createElement("input");
            g.classList.add(fu("i")), g.type = "text", h.viewProps.bindDisabled(g), this.element.appendChild(g), this.inputElement = g, h.value.emitter.on("change", this.onChange_), this.value_ = h.value, this.refresh();
          }
          refresh() {
            const o = this.props_.get("formatter");
            this.inputElement.value = o(this.value_.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class Oo {
          constructor(o, h) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.parser_ = h.parser, this.props = h.props, this.value = h.value, this.viewProps = h.viewProps, this.view = new cg(o, {
              props: h.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(o) {
            const g = o.currentTarget.value, E = this.parser_(g);
            f(E) || (this.value.rawValue = E), this.view.refresh();
          }
        }
        function hg(d) {
          return String(d);
        }
        function mu(d) {
          return d === "false" ? false : !!d;
        }
        function gu(d) {
          return hg(d);
        }
        class ug {
          constructor(o) {
            this.text = o;
          }
          evaluate() {
            return Number(this.text);
          }
          toString() {
            return this.text;
          }
        }
        const dg = {
          "**": (d, o) => Math.pow(d, o),
          "*": (d, o) => d * o,
          "/": (d, o) => d / o,
          "%": (d, o) => d % o,
          "+": (d, o) => d + o,
          "-": (d, o) => d - o,
          "<<": (d, o) => d << o,
          ">>": (d, o) => d >> o,
          ">>>": (d, o) => d >>> o,
          "&": (d, o) => d & o,
          "^": (d, o) => d ^ o,
          "|": (d, o) => d | o
        };
        class pg {
          constructor(o, h, g) {
            this.left = h, this.operator = o, this.right = g;
          }
          evaluate() {
            const o = dg[this.operator];
            if (!o) throw new Error(`unexpected binary operator: '${this.operator}`);
            return o(this.left.evaluate(), this.right.evaluate());
          }
          toString() {
            return [
              "b(",
              this.left.toString(),
              this.operator,
              this.right.toString(),
              ")"
            ].join(" ");
          }
        }
        const fg = {
          "+": (d) => d,
          "-": (d) => -d,
          "~": (d) => ~d
        };
        class mg {
          constructor(o, h) {
            this.operator = o, this.expression = h;
          }
          evaluate() {
            const o = fg[this.operator];
            if (!o) throw new Error(`unexpected unary operator: '${this.operator}`);
            return o(this.expression.evaluate());
          }
          toString() {
            return [
              "u(",
              this.operator,
              this.expression.toString(),
              ")"
            ].join(" ");
          }
        }
        function ml(d) {
          return (o, h) => {
            for (let g = 0; g < d.length; g++) {
              const E = d[g](o, h);
              if (E !== "") return E;
            }
            return "";
          };
        }
        function wr(d, o) {
          var h;
          const g = d.substr(o).match(/^\s+/);
          return (h = g && g[0]) !== null && h !== void 0 ? h : "";
        }
        function gg(d, o) {
          const h = d.substr(o, 1);
          return h.match(/^[1-9]$/) ? h : "";
        }
        function Mr(d, o) {
          var h;
          const g = d.substr(o).match(/^[0-9]+/);
          return (h = g && g[0]) !== null && h !== void 0 ? h : "";
        }
        function vg(d, o) {
          const h = Mr(d, o);
          if (h !== "") return h;
          const g = d.substr(o, 1);
          if (o += 1, g !== "-" && g !== "+") return "";
          const E = Mr(d, o);
          return E === "" ? "" : g + E;
        }
        function gl(d, o) {
          const h = d.substr(o, 1);
          if (o += 1, h.toLowerCase() !== "e") return "";
          const g = vg(d, o);
          return g === "" ? "" : h + g;
        }
        function vu(d, o) {
          const h = d.substr(o, 1);
          if (h === "0") return h;
          const g = gg(d, o);
          return o += g.length, g === "" ? "" : g + Mr(d, o);
        }
        function _g(d, o) {
          const h = vu(d, o);
          if (o += h.length, h === "") return "";
          const g = d.substr(o, 1);
          if (o += g.length, g !== ".") return "";
          const E = Mr(d, o);
          return o += E.length, h + g + E + gl(d, o);
        }
        function xg(d, o) {
          const h = d.substr(o, 1);
          if (o += h.length, h !== ".") return "";
          const g = Mr(d, o);
          return o += g.length, g === "" ? "" : h + g + gl(d, o);
        }
        function bg(d, o) {
          const h = vu(d, o);
          return o += h.length, h === "" ? "" : h + gl(d, o);
        }
        const yg = ml([
          _g,
          xg,
          bg
        ]);
        function wg(d, o) {
          var h;
          const g = d.substr(o).match(/^[01]+/);
          return (h = g && g[0]) !== null && h !== void 0 ? h : "";
        }
        function Mg(d, o) {
          const h = d.substr(o, 2);
          if (o += h.length, h.toLowerCase() !== "0b") return "";
          const g = wg(d, o);
          return g === "" ? "" : h + g;
        }
        function Sg(d, o) {
          var h;
          const g = d.substr(o).match(/^[0-7]+/);
          return (h = g && g[0]) !== null && h !== void 0 ? h : "";
        }
        function Eg(d, o) {
          const h = d.substr(o, 2);
          if (o += h.length, h.toLowerCase() !== "0o") return "";
          const g = Sg(d, o);
          return g === "" ? "" : h + g;
        }
        function Tg(d, o) {
          var h;
          const g = d.substr(o).match(/^[0-9a-f]+/i);
          return (h = g && g[0]) !== null && h !== void 0 ? h : "";
        }
        function Cg(d, o) {
          const h = d.substr(o, 2);
          if (o += h.length, h.toLowerCase() !== "0x") return "";
          const g = Tg(d, o);
          return g === "" ? "" : h + g;
        }
        const Ag = ml([
          Mg,
          Eg,
          Cg
        ]), Pg = ml([
          Ag,
          yg
        ]);
        function Lg(d, o) {
          const h = Pg(d, o);
          return o += h.length, h === "" ? null : {
            evaluable: new ug(h),
            cursor: o
          };
        }
        function Rg(d, o) {
          const h = d.substr(o, 1);
          if (o += h.length, h !== "(") return null;
          const g = xu(d, o);
          if (!g) return null;
          o = g.cursor, o += wr(d, o).length;
          const E = d.substr(o, 1);
          return o += E.length, E !== ")" ? null : {
            evaluable: g.evaluable,
            cursor: o
          };
        }
        function Ig(d, o) {
          var h;
          return (h = Lg(d, o)) !== null && h !== void 0 ? h : Rg(d, o);
        }
        function _u(d, o) {
          const h = Ig(d, o);
          if (h) return h;
          const g = d.substr(o, 1);
          if (o += g.length, g !== "+" && g !== "-" && g !== "~") return null;
          const E = _u(d, o);
          return E ? (o = E.cursor, {
            cursor: o,
            evaluable: new mg(g, E.evaluable)
          }) : null;
        }
        function Dg(d, o, h) {
          h += wr(o, h).length;
          const g = d.filter((E) => o.startsWith(E, h))[0];
          return g ? (h += g.length, h += wr(o, h).length, {
            cursor: h,
            operator: g
          }) : null;
        }
        function kg(d, o) {
          return (h, g) => {
            const E = d(h, g);
            if (!E) return null;
            g = E.cursor;
            let N = E.evaluable;
            for (; ; ) {
              const V = Dg(o, h, g);
              if (!V) break;
              g = V.cursor;
              const de = d(h, g);
              if (!de) return null;
              g = de.cursor, N = new pg(V.operator, N, de.evaluable);
            }
            return N ? {
              cursor: g,
              evaluable: N
            } : null;
          };
        }
        const Ng = [
          [
            "**"
          ],
          [
            "*",
            "/",
            "%"
          ],
          [
            "+",
            "-"
          ],
          [
            "<<",
            ">>>",
            ">>"
          ],
          [
            "&"
          ],
          [
            "^"
          ],
          [
            "|"
          ]
        ].reduce((d, o) => kg(d, o), _u);
        function xu(d, o) {
          return o += wr(d, o).length, Ng(d, o);
        }
        function Og(d) {
          const o = xu(d, 0);
          return !o || o.cursor + wr(d, o.cursor).length !== d.length ? null : o.evaluable;
        }
        function Wn(d) {
          var o;
          const h = Og(d);
          return (o = h == null ? void 0 : h.evaluate()) !== null && o !== void 0 ? o : null;
        }
        function bu(d) {
          if (typeof d == "number") return d;
          if (typeof d == "string") {
            const o = Wn(d);
            if (!f(o)) return o;
          }
          return 0;
        }
        function Fg(d) {
          return String(d);
        }
        function qt(d) {
          return (o) => o.toFixed(Math.max(Math.min(d, 20), 0));
        }
        const Bg = qt(0);
        function Fo(d) {
          return Bg(d) + "%";
        }
        function yu(d) {
          return String(d);
        }
        function vl(d) {
          return d;
        }
        function Sr({ primary: d, secondary: o, forward: h, backward: g }) {
          let E = false;
          function N(V) {
            E || (E = true, V(), E = false);
          }
          d.emitter.on("change", (V) => {
            N(() => {
              o.setRawValue(h(d, o), V.options);
            });
          }), o.emitter.on("change", (V) => {
            N(() => {
              d.setRawValue(g(d, o), V.options);
            }), N(() => {
              o.setRawValue(h(d, o), V.options);
            });
          }), N(() => {
            o.setRawValue(h(d, o), {
              forceEmit: false,
              last: true
            });
          });
        }
        function rn(d, o) {
          const h = d * (o.altKey ? 0.1 : 1) * (o.shiftKey ? 10 : 1);
          return o.upKey ? +h : o.downKey ? -h : 0;
        }
        function Er(d) {
          return {
            altKey: d.altKey,
            downKey: d.key === "ArrowDown",
            shiftKey: d.shiftKey,
            upKey: d.key === "ArrowUp"
          };
        }
        function qn(d) {
          return {
            altKey: d.altKey,
            downKey: d.key === "ArrowLeft",
            shiftKey: d.shiftKey,
            upKey: d.key === "ArrowRight"
          };
        }
        function Ug(d) {
          return d === "ArrowUp" || d === "ArrowDown";
        }
        function wu(d) {
          return Ug(d) || d === "ArrowLeft" || d === "ArrowRight";
        }
        function _l(d, o) {
          var h, g;
          const E = o.ownerDocument.defaultView, N = o.getBoundingClientRect();
          return {
            x: d.pageX - (((h = E && E.scrollX) !== null && h !== void 0 ? h : 0) + N.left),
            y: d.pageY - (((g = E && E.scrollY) !== null && g !== void 0 ? g : 0) + N.top)
          };
        }
        class Oi {
          constructor(o) {
            this.lastTouch_ = null, this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this), this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this), this.onMouseDown_ = this.onMouseDown_.bind(this), this.onTouchEnd_ = this.onTouchEnd_.bind(this), this.onTouchMove_ = this.onTouchMove_.bind(this), this.onTouchStart_ = this.onTouchStart_.bind(this), this.elem_ = o, this.emitter = new S(), o.addEventListener("touchstart", this.onTouchStart_, {
              passive: false
            }), o.addEventListener("touchmove", this.onTouchMove_, {
              passive: true
            }), o.addEventListener("touchend", this.onTouchEnd_), o.addEventListener("mousedown", this.onMouseDown_);
          }
          computePosition_(o) {
            const h = this.elem_.getBoundingClientRect();
            return {
              bounds: {
                width: h.width,
                height: h.height
              },
              point: o ? {
                x: o.x,
                y: o.y
              } : null
            };
          }
          onMouseDown_(o) {
            var h;
            o.preventDefault(), (h = o.currentTarget) === null || h === void 0 || h.focus();
            const g = this.elem_.ownerDocument;
            g.addEventListener("mousemove", this.onDocumentMouseMove_), g.addEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("down", {
              altKey: o.altKey,
              data: this.computePosition_(_l(o, this.elem_)),
              sender: this,
              shiftKey: o.shiftKey
            });
          }
          onDocumentMouseMove_(o) {
            this.emitter.emit("move", {
              altKey: o.altKey,
              data: this.computePosition_(_l(o, this.elem_)),
              sender: this,
              shiftKey: o.shiftKey
            });
          }
          onDocumentMouseUp_(o) {
            const h = this.elem_.ownerDocument;
            h.removeEventListener("mousemove", this.onDocumentMouseMove_), h.removeEventListener("mouseup", this.onDocumentMouseUp_), this.emitter.emit("up", {
              altKey: o.altKey,
              data: this.computePosition_(_l(o, this.elem_)),
              sender: this,
              shiftKey: o.shiftKey
            });
          }
          onTouchStart_(o) {
            o.preventDefault();
            const h = o.targetTouches.item(0), g = this.elem_.getBoundingClientRect();
            this.emitter.emit("down", {
              altKey: o.altKey,
              data: this.computePosition_(h ? {
                x: h.clientX - g.left,
                y: h.clientY - g.top
              } : void 0),
              sender: this,
              shiftKey: o.shiftKey
            }), this.lastTouch_ = h;
          }
          onTouchMove_(o) {
            const h = o.targetTouches.item(0), g = this.elem_.getBoundingClientRect();
            this.emitter.emit("move", {
              altKey: o.altKey,
              data: this.computePosition_(h ? {
                x: h.clientX - g.left,
                y: h.clientY - g.top
              } : void 0),
              sender: this,
              shiftKey: o.shiftKey
            }), this.lastTouch_ = h;
          }
          onTouchEnd_(o) {
            var h;
            const g = (h = o.targetTouches.item(0)) !== null && h !== void 0 ? h : this.lastTouch_, E = this.elem_.getBoundingClientRect();
            this.emitter.emit("up", {
              altKey: o.altKey,
              data: this.computePosition_(g ? {
                x: g.clientX - E.left,
                y: g.clientY - E.top
              } : void 0),
              sender: this,
              shiftKey: o.shiftKey
            });
          }
        }
        function _t(d, o, h, g, E) {
          const N = (d - o) / (h - o);
          return g + N * (E - g);
        }
        function Mu(d) {
          return String(d.toFixed(10)).split(".")[1].replace(/0+$/, "").length;
        }
        function Nt(d, o, h) {
          return Math.min(Math.max(d, o), h);
        }
        function Su(d, o) {
          return (d % o + o) % o;
        }
        const fn = M("txt");
        class zg {
          constructor(o, h) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = h.props, this.props_.emitter.on("change", this.onChange_), this.element = o.createElement("div"), this.element.classList.add(fn(), fn(void 0, "num")), h.arrayPosition && this.element.classList.add(fn(void 0, h.arrayPosition)), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("input");
            g.classList.add(fn("i")), g.type = "text", h.viewProps.bindDisabled(g), this.element.appendChild(g), this.inputElement = g, this.onDraggingChange_ = this.onDraggingChange_.bind(this), this.dragging_ = h.dragging, this.dragging_.emitter.on("change", this.onDraggingChange_), this.element.classList.add(fn()), this.inputElement.classList.add(fn("i"));
            const E = o.createElement("div");
            E.classList.add(fn("k")), this.element.appendChild(E), this.knobElement = E;
            const N = o.createElementNS(fe, "svg");
            N.classList.add(fn("g")), this.knobElement.appendChild(N);
            const V = o.createElementNS(fe, "path");
            V.classList.add(fn("gb")), N.appendChild(V), this.guideBodyElem_ = V;
            const de = o.createElementNS(fe, "path");
            de.classList.add(fn("gh")), N.appendChild(de), this.guideHeadElem_ = de;
            const Ue = o.createElement("div");
            Ue.classList.add(M("tt")()), this.knobElement.appendChild(Ue), this.tooltipElem_ = Ue, h.value.emitter.on("change", this.onChange_), this.value = h.value, this.refresh();
          }
          onDraggingChange_(o) {
            if (o.rawValue === null) {
              this.element.classList.remove(fn(void 0, "drg"));
              return;
            }
            this.element.classList.add(fn(void 0, "drg"));
            const h = o.rawValue / this.props_.get("draggingScale"), g = h + (h > 0 ? -1 : h < 0 ? 1 : 0), E = Nt(-g, -4, 4);
            this.guideHeadElem_.setAttributeNS(null, "d", [
              `M ${g + E},0 L${g},4 L${g + E},8`,
              `M ${h},-1 L${h},9`
            ].join(" ")), this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${h},4`);
            const N = this.props_.get("formatter");
            this.tooltipElem_.textContent = N(this.value.rawValue), this.tooltipElem_.style.left = `${h}px`;
          }
          refresh() {
            const o = this.props_.get("formatter");
            this.inputElement.value = o(this.value.rawValue);
          }
          onChange_() {
            this.refresh();
          }
        }
        class Tr {
          constructor(o, h) {
            var g;
            this.originRawValue_ = 0, this.onInputChange_ = this.onInputChange_.bind(this), this.onInputKeyDown_ = this.onInputKeyDown_.bind(this), this.onInputKeyUp_ = this.onInputKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = h.baseStep, this.parser_ = h.parser, this.props = h.props, this.sliderProps_ = (g = h.sliderProps) !== null && g !== void 0 ? g : null, this.value = h.value, this.viewProps = h.viewProps, this.dragging_ = re(null), this.view = new zg(o, {
              arrayPosition: h.arrayPosition,
              dragging: this.dragging_,
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_), this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_), this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
            const E = new Oi(this.view.knobElement);
            E.emitter.on("down", this.onPointerDown_), E.emitter.on("move", this.onPointerMove_), E.emitter.on("up", this.onPointerUp_);
          }
          constrainValue_(o) {
            var h, g;
            const E = (h = this.sliderProps_) === null || h === void 0 ? void 0 : h.get("minValue"), N = (g = this.sliderProps_) === null || g === void 0 ? void 0 : g.get("maxValue");
            let V = o;
            return E !== void 0 && (V = Math.max(V, E)), N !== void 0 && (V = Math.min(V, N)), V;
          }
          onInputChange_(o) {
            const g = o.currentTarget.value, E = this.parser_(g);
            f(E) || (this.value.rawValue = this.constrainValue_(E)), this.view.refresh();
          }
          onInputKeyDown_(o) {
            const h = rn(this.baseStep_, Er(o));
            h !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + h), {
              forceEmit: false,
              last: false
            });
          }
          onInputKeyUp_(o) {
            rn(this.baseStep_, Er(o)) !== 0 && this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
          onPointerDown_() {
            this.originRawValue_ = this.value.rawValue, this.dragging_.rawValue = 0;
          }
          computeDraggingValue_(o) {
            if (!o.point) return null;
            const h = o.point.x - o.bounds.width / 2;
            return this.constrainValue_(this.originRawValue_ + h * this.props.get("draggingScale"));
          }
          onPointerMove_(o) {
            const h = this.computeDraggingValue_(o.data);
            h !== null && (this.value.setRawValue(h, {
              forceEmit: false,
              last: false
            }), this.dragging_.rawValue = this.value.rawValue - this.originRawValue_);
          }
          onPointerUp_(o) {
            const h = this.computeDraggingValue_(o.data);
            h !== null && (this.value.setRawValue(h, {
              forceEmit: true,
              last: true
            }), this.dragging_.rawValue = null);
          }
        }
        const xl = M("sld");
        class Vg {
          constructor(o, h) {
            this.onChange_ = this.onChange_.bind(this), this.props_ = h.props, this.props_.emitter.on("change", this.onChange_), this.element = o.createElement("div"), this.element.classList.add(xl()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(xl("t")), h.viewProps.bindTabIndex(g), this.element.appendChild(g), this.trackElement = g;
            const E = o.createElement("div");
            E.classList.add(xl("k")), this.trackElement.appendChild(E), this.knobElement = E, h.value.emitter.on("change", this.onChange_), this.value = h.value, this.update_();
          }
          update_() {
            const o = Nt(_t(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
            this.knobElement.style.width = `${o}%`;
          }
          onChange_() {
            this.update_();
          }
        }
        class Gg {
          constructor(o, h) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.baseStep_ = h.baseStep, this.value = h.value, this.viewProps = h.viewProps, this.props = h.props, this.view = new Vg(o, {
              props: this.props,
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Oi(this.view.trackElement), this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.trackElement.addEventListener("keydown", this.onKeyDown_), this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(o, h) {
            o.point && this.value.setRawValue(_t(Nt(o.point.x, 0, o.bounds.width), 0, o.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), h);
          }
          onPointerDownOrMove_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(o) {
            const h = rn(this.baseStep_, qn(o));
            h !== 0 && this.value.setRawValue(this.value.rawValue + h, {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(o) {
            rn(this.baseStep_, qn(o)) !== 0 && this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const bl = M("sldtxt");
        class Hg {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(bl());
            const g = o.createElement("div");
            g.classList.add(bl("s")), this.sliderView_ = h.sliderView, g.appendChild(this.sliderView_.element), this.element.appendChild(g);
            const E = o.createElement("div");
            E.classList.add(bl("t")), this.textView_ = h.textView, E.appendChild(this.textView_.element), this.element.appendChild(E);
          }
        }
        class yl {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.sliderC_ = new Gg(o, {
              baseStep: h.baseStep,
              props: h.sliderProps,
              value: h.value,
              viewProps: this.viewProps
            }), this.textC_ = new Tr(o, {
              baseStep: h.baseStep,
              parser: h.parser,
              props: h.textProps,
              sliderProps: h.sliderProps,
              value: h.value,
              viewProps: h.viewProps
            }), this.view = new Hg(o, {
              sliderView: this.sliderC_.view,
              textView: this.textC_.view
            });
          }
          get sliderController() {
            return this.sliderC_;
          }
          get textController() {
            return this.textC_;
          }
        }
        function Cr(d, o) {
          d.write(o);
        }
        function Bo(d) {
          const o = oe;
          if (Array.isArray(d)) return o.required.array(o.required.object({
            text: o.required.string,
            value: o.required.raw
          }))(d).value;
          if (typeof d == "object") return o.required.raw(d).value;
        }
        function Eu(d) {
          if (d === "inline" || d === "popup") return d;
        }
        function li(d) {
          const o = oe;
          return o.required.object({
            max: o.optional.number,
            min: o.optional.number,
            step: o.optional.number
          })(d).value;
        }
        function Tu(d) {
          if (Array.isArray(d)) return d;
          const o = [];
          return Object.keys(d).forEach((h) => {
            o.push({
              text: h,
              value: d[h]
            });
          }), o;
        }
        function wl(d) {
          return f(d) ? null : new br(Tu(d));
        }
        function Wg(d) {
          const o = d ? Hn(d, No) : null;
          return o ? o.step : null;
        }
        function Uo(d, o) {
          const h = d && Hn(d, No);
          return h ? Mu(h.step) : Math.max(Mu(o), 2);
        }
        function ws(d) {
          const o = Wg(d);
          return o ?? 1;
        }
        function Ms(d, o) {
          var h;
          const g = d && Hn(d, No), E = Math.abs((h = g == null ? void 0 : g.step) !== null && h !== void 0 ? h : o);
          return E === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(E)) - 1);
        }
        const zo = M("ckb");
        class qg {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.element = o.createElement("div"), this.element.classList.add(zo()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("label");
            g.classList.add(zo("l")), this.element.appendChild(g);
            const E = o.createElement("input");
            E.classList.add(zo("i")), E.type = "checkbox", g.appendChild(E), this.inputElement = E, h.viewProps.bindDisabled(this.inputElement);
            const N = o.createElement("div");
            N.classList.add(zo("w")), g.appendChild(N);
            const V = $(o, "check");
            N.appendChild(V), h.value.emitter.on("change", this.onValueChange_), this.value = h.value, this.update_();
          }
          update_() {
            this.inputElement.checked = this.value.rawValue;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class Xg {
          constructor(o, h) {
            this.onInputChange_ = this.onInputChange_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.view = new qg(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.view.inputElement.addEventListener("change", this.onInputChange_);
          }
          onInputChange_(o) {
            const h = o.currentTarget;
            this.value.rawValue = h.checked;
          }
        }
        function jg(d) {
          const o = [], h = wl(d.options);
          return h && o.push(h), new xr(o);
        }
        const Kg = {
          id: "input-bool",
          type: "input",
          accept: (d, o) => {
            if (typeof d != "boolean") return null;
            const g = ce(o, {
              options: oe.optional.custom(Bo)
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => mu,
            constraint: (d) => jg(d.params),
            writer: (d) => Cr
          },
          controller: (d) => {
            const o = d.document, h = d.value, g = d.constraint, E = g && Hn(g, br);
            return E ? new yr(o, {
              props: new W({
                options: E.values.value("options")
              }),
              value: h,
              viewProps: d.viewProps
            }) : new Xg(o, {
              value: h,
              viewProps: d.viewProps
            });
          }
        }, Fi = M("col");
        class Yg {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(Fi()), h.foldable.bindExpandedClass(this.element, Fi(void 0, "expanded")), T(h.foldable, "completed", F(this.element, Fi(void 0, "cpl")));
            const g = o.createElement("div");
            g.classList.add(Fi("h")), this.element.appendChild(g);
            const E = o.createElement("div");
            E.classList.add(Fi("s")), g.appendChild(E), this.swatchElement = E;
            const N = o.createElement("div");
            if (N.classList.add(Fi("t")), g.appendChild(N), this.textElement = N, h.pickerLayout === "inline") {
              const V = o.createElement("div");
              V.classList.add(Fi("p")), this.element.appendChild(V), this.pickerElement = V;
            } else this.pickerElement = null;
          }
        }
        function $g(d, o, h) {
          const g = Nt(d / 255, 0, 1), E = Nt(o / 255, 0, 1), N = Nt(h / 255, 0, 1), V = Math.max(g, E, N), de = Math.min(g, E, N), Ue = V - de;
          let Ge = 0, lt = 0;
          const ut = (de + V) / 2;
          return Ue !== 0 && (lt = Ue / (1 - Math.abs(V + de - 1)), g === V ? Ge = (E - N) / Ue : E === V ? Ge = 2 + (N - g) / Ue : Ge = 4 + (g - E) / Ue, Ge = Ge / 6 + (Ge < 0 ? 1 : 0)), [
            Ge * 360,
            lt * 100,
            ut * 100
          ];
        }
        function Zg(d, o, h) {
          const g = (d % 360 + 360) % 360, E = Nt(o / 100, 0, 1), N = Nt(h / 100, 0, 1), V = (1 - Math.abs(2 * N - 1)) * E, de = V * (1 - Math.abs(g / 60 % 2 - 1)), Ue = N - V / 2;
          let Ge, lt, ut;
          return g >= 0 && g < 60 ? [Ge, lt, ut] = [
            V,
            de,
            0
          ] : g >= 60 && g < 120 ? [Ge, lt, ut] = [
            de,
            V,
            0
          ] : g >= 120 && g < 180 ? [Ge, lt, ut] = [
            0,
            V,
            de
          ] : g >= 180 && g < 240 ? [Ge, lt, ut] = [
            0,
            de,
            V
          ] : g >= 240 && g < 300 ? [Ge, lt, ut] = [
            de,
            0,
            V
          ] : [Ge, lt, ut] = [
            V,
            0,
            de
          ], [
            (Ge + Ue) * 255,
            (lt + Ue) * 255,
            (ut + Ue) * 255
          ];
        }
        function Jg(d, o, h) {
          const g = Nt(d / 255, 0, 1), E = Nt(o / 255, 0, 1), N = Nt(h / 255, 0, 1), V = Math.max(g, E, N), de = Math.min(g, E, N), Ue = V - de;
          let Ge;
          Ue === 0 ? Ge = 0 : V === g ? Ge = 60 * (((E - N) / Ue % 6 + 6) % 6) : V === E ? Ge = 60 * ((N - g) / Ue + 2) : Ge = 60 * ((g - E) / Ue + 4);
          const lt = V === 0 ? 0 : Ue / V, ut = V;
          return [
            Ge,
            lt * 100,
            ut * 100
          ];
        }
        function Cu(d, o, h) {
          const g = Su(d, 360), E = Nt(o / 100, 0, 1), N = Nt(h / 100, 0, 1), V = N * E, de = V * (1 - Math.abs(g / 60 % 2 - 1)), Ue = N - V;
          let Ge, lt, ut;
          return g >= 0 && g < 60 ? [Ge, lt, ut] = [
            V,
            de,
            0
          ] : g >= 60 && g < 120 ? [Ge, lt, ut] = [
            de,
            V,
            0
          ] : g >= 120 && g < 180 ? [Ge, lt, ut] = [
            0,
            V,
            de
          ] : g >= 180 && g < 240 ? [Ge, lt, ut] = [
            0,
            de,
            V
          ] : g >= 240 && g < 300 ? [Ge, lt, ut] = [
            de,
            0,
            V
          ] : [Ge, lt, ut] = [
            V,
            0,
            de
          ], [
            (Ge + Ue) * 255,
            (lt + Ue) * 255,
            (ut + Ue) * 255
          ];
        }
        function Qg(d, o, h) {
          const g = h + o * (100 - Math.abs(2 * h - 100)) / 200;
          return [
            d,
            g !== 0 ? o * (100 - Math.abs(2 * h - 100)) / g : 0,
            h + o * (100 - Math.abs(2 * h - 100)) / 200
          ];
        }
        function ev(d, o, h) {
          const g = 100 - Math.abs(h * (200 - o) / 100 - 100);
          return [
            d,
            g !== 0 ? o * h / g : 0,
            h * (200 - o) / 200
          ];
        }
        function Bi(d) {
          return [
            d[0],
            d[1],
            d[2]
          ];
        }
        function Au(d, o) {
          return [
            d[0],
            d[1],
            d[2],
            o
          ];
        }
        const tv = {
          hsl: {
            hsl: (d, o, h) => [
              d,
              o,
              h
            ],
            hsv: Qg,
            rgb: Zg
          },
          hsv: {
            hsl: ev,
            hsv: (d, o, h) => [
              d,
              o,
              h
            ],
            rgb: Cu
          },
          rgb: {
            hsl: $g,
            hsv: Jg,
            rgb: (d, o, h) => [
              d,
              o,
              h
            ]
          }
        };
        function Vo(d, o) {
          return [
            o === "float" ? 1 : d === "rgb" ? 255 : 360,
            o === "float" ? 1 : d === "rgb" ? 255 : 100,
            o === "float" ? 1 : d === "rgb" ? 255 : 100
          ];
        }
        function nv(d, o) {
          return d === o ? o : Su(d, o);
        }
        function iv(d, o, h) {
          var g;
          const E = Vo(o, h);
          return [
            o === "rgb" ? Nt(d[0], 0, E[0]) : nv(d[0], E[0]),
            Nt(d[1], 0, E[1]),
            Nt(d[2], 0, E[2]),
            Nt((g = d[3]) !== null && g !== void 0 ? g : 1, 0, 1)
          ];
        }
        function Pu(d, o, h, g) {
          const E = Vo(o, h), N = Vo(o, g);
          return d.map((V, de) => V / E[de] * N[de]);
        }
        function sv(d, o, h) {
          const g = Pu(d, o.mode, o.type, "int"), E = tv[o.mode][h.mode](...g);
          return Pu(E, h.mode, "int", h.type);
        }
        function Go(d, o) {
          return typeof d != "object" || f(d) ? false : o in d && typeof d[o] == "number";
        }
        class Qe {
          static black(o = "int") {
            return new Qe([
              0,
              0,
              0
            ], "rgb", o);
          }
          static fromObject(o, h = "int") {
            const g = "a" in o ? [
              o.r,
              o.g,
              o.b,
              o.a
            ] : [
              o.r,
              o.g,
              o.b
            ];
            return new Qe(g, "rgb", h);
          }
          static toRgbaObject(o, h = "int") {
            return o.toRgbaObject(h);
          }
          static isRgbColorObject(o) {
            return Go(o, "r") && Go(o, "g") && Go(o, "b");
          }
          static isRgbaColorObject(o) {
            return this.isRgbColorObject(o) && Go(o, "a");
          }
          static isColorObject(o) {
            return this.isRgbColorObject(o);
          }
          static equals(o, h) {
            if (o.mode !== h.mode) return false;
            const g = o.comps_, E = h.comps_;
            for (let N = 0; N < g.length; N++) if (g[N] !== E[N]) return false;
            return true;
          }
          constructor(o, h, g = "int") {
            this.mode = h, this.type = g, this.comps_ = iv(o, h, g);
          }
          getComponents(o, h = "int") {
            return Au(sv(Bi(this.comps_), {
              mode: this.mode,
              type: this.type
            }, {
              mode: o ?? this.mode,
              type: h
            }), this.comps_[3]);
          }
          toRgbaObject(o = "int") {
            const h = this.getComponents("rgb", o);
            return {
              r: h[0],
              g: h[1],
              b: h[2],
              a: h[3]
            };
          }
        }
        const ci = M("colp");
        class rv {
          constructor(o, h) {
            this.alphaViews_ = null, this.element = o.createElement("div"), this.element.classList.add(ci()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(ci("hsv"));
            const E = o.createElement("div");
            E.classList.add(ci("sv")), this.svPaletteView_ = h.svPaletteView, E.appendChild(this.svPaletteView_.element), g.appendChild(E);
            const N = o.createElement("div");
            N.classList.add(ci("h")), this.hPaletteView_ = h.hPaletteView, N.appendChild(this.hPaletteView_.element), g.appendChild(N), this.element.appendChild(g);
            const V = o.createElement("div");
            if (V.classList.add(ci("rgb")), this.textView_ = h.textView, V.appendChild(this.textView_.element), this.element.appendChild(V), h.alphaViews) {
              this.alphaViews_ = {
                palette: h.alphaViews.palette,
                text: h.alphaViews.text
              };
              const de = o.createElement("div");
              de.classList.add(ci("a"));
              const Ue = o.createElement("div");
              Ue.classList.add(ci("ap")), Ue.appendChild(this.alphaViews_.palette.element), de.appendChild(Ue);
              const Ge = o.createElement("div");
              Ge.classList.add(ci("at")), Ge.appendChild(this.alphaViews_.text.element), de.appendChild(Ge), this.element.appendChild(de);
            }
          }
          get allFocusableElements() {
            const o = [
              this.svPaletteView_.element,
              this.hPaletteView_.element,
              this.textView_.modeSelectElement,
              ...this.textView_.textViews.map((h) => h.inputElement)
            ];
            return this.alphaViews_ && o.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), o;
          }
        }
        function ov(d) {
          return d === "int" ? "int" : d === "float" ? "float" : void 0;
        }
        function Ml(d) {
          const o = oe;
          return ce(d, {
            alpha: o.optional.boolean,
            color: o.optional.object({
              alpha: o.optional.boolean,
              type: o.optional.custom(ov)
            }),
            expanded: o.optional.boolean,
            picker: o.optional.custom(Eu)
          });
        }
        function Ui(d) {
          return d ? 0.1 : 1;
        }
        function zi(d) {
          var o;
          return (o = d.color) === null || o === void 0 ? void 0 : o.type;
        }
        function av(d, o) {
          return d.alpha === o.alpha && d.mode === o.mode && d.notation === o.notation && d.type === o.type;
        }
        function mn(d, o) {
          const h = d.match(/^(.+)%$/);
          return Math.min(h ? parseFloat(h[1]) * 0.01 * o : parseFloat(d), o);
        }
        const lv = {
          deg: (d) => d,
          grad: (d) => d * 360 / 400,
          rad: (d) => d * 360 / (2 * Math.PI),
          turn: (d) => d * 360
        };
        function Lu(d) {
          const o = d.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
          if (!o) return parseFloat(d);
          const h = parseFloat(o[1]), g = o[2];
          return lv[g](h);
        }
        function Ru(d) {
          const o = d.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!o) return null;
          const h = [
            mn(o[1], 255),
            mn(o[2], 255),
            mn(o[3], 255)
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) ? null : h;
        }
        function Iu(d) {
          return (o) => {
            const h = Ru(o);
            return h ? new Qe(h, "rgb", d) : null;
          };
        }
        function Du(d) {
          const o = d.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!o) return null;
          const h = [
            mn(o[1], 255),
            mn(o[2], 255),
            mn(o[3], 255),
            mn(o[4], 1)
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) || isNaN(h[3]) ? null : h;
        }
        function ku(d) {
          return (o) => {
            const h = Du(o);
            return h ? new Qe(h, "rgb", d) : null;
          };
        }
        function Nu(d) {
          const o = d.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!o) return null;
          const h = [
            Lu(o[1]),
            mn(o[2], 100),
            mn(o[3], 100)
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) ? null : h;
        }
        function Ou(d) {
          return (o) => {
            const h = Nu(o);
            return h ? new Qe(h, "hsl", d) : null;
          };
        }
        function Fu(d) {
          const o = d.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
          if (!o) return null;
          const h = [
            Lu(o[1]),
            mn(o[2], 100),
            mn(o[3], 100),
            mn(o[4], 1)
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) || isNaN(h[3]) ? null : h;
        }
        function Bu(d) {
          return (o) => {
            const h = Fu(o);
            return h ? new Qe(h, "hsl", d) : null;
          };
        }
        function Uu(d) {
          const o = d.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
          if (o) return [
            parseInt(o[1] + o[1], 16),
            parseInt(o[2] + o[2], 16),
            parseInt(o[3] + o[3], 16)
          ];
          const h = d.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
          return h ? [
            parseInt(h[1], 16),
            parseInt(h[2], 16),
            parseInt(h[3], 16)
          ] : null;
        }
        function cv(d) {
          const o = Uu(d);
          return o ? new Qe(o, "rgb", "int") : null;
        }
        function zu(d) {
          const o = d.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
          if (o) return [
            parseInt(o[1] + o[1], 16),
            parseInt(o[2] + o[2], 16),
            parseInt(o[3] + o[3], 16),
            _t(parseInt(o[4] + o[4], 16), 0, 255, 0, 1)
          ];
          const h = d.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
          return h ? [
            parseInt(h[1], 16),
            parseInt(h[2], 16),
            parseInt(h[3], 16),
            _t(parseInt(h[4], 16), 0, 255, 0, 1)
          ] : null;
        }
        function hv(d) {
          const o = zu(d);
          return o ? new Qe(o, "rgb", "int") : null;
        }
        function Vu(d) {
          const o = d.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
          if (!o) return null;
          const h = [
            parseFloat(o[1]),
            parseFloat(o[2]),
            parseFloat(o[3])
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) ? null : h;
        }
        function Gu(d) {
          return (o) => {
            const h = Vu(o);
            return h ? new Qe(h, "rgb", d) : null;
          };
        }
        function Hu(d) {
          const o = d.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
          if (!o) return null;
          const h = [
            parseFloat(o[1]),
            parseFloat(o[2]),
            parseFloat(o[3]),
            parseFloat(o[4])
          ];
          return isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2]) || isNaN(h[3]) ? null : h;
        }
        function Wu(d) {
          return (o) => {
            const h = Hu(o);
            return h ? new Qe(h, "rgb", d) : null;
          };
        }
        const uv = [
          {
            parser: Uu,
            result: {
              alpha: false,
              mode: "rgb",
              notation: "hex"
            }
          },
          {
            parser: zu,
            result: {
              alpha: true,
              mode: "rgb",
              notation: "hex"
            }
          },
          {
            parser: Ru,
            result: {
              alpha: false,
              mode: "rgb",
              notation: "func"
            }
          },
          {
            parser: Du,
            result: {
              alpha: true,
              mode: "rgb",
              notation: "func"
            }
          },
          {
            parser: Nu,
            result: {
              alpha: false,
              mode: "hsl",
              notation: "func"
            }
          },
          {
            parser: Fu,
            result: {
              alpha: true,
              mode: "hsl",
              notation: "func"
            }
          },
          {
            parser: Vu,
            result: {
              alpha: false,
              mode: "rgb",
              notation: "object"
            }
          },
          {
            parser: Hu,
            result: {
              alpha: true,
              mode: "rgb",
              notation: "object"
            }
          }
        ];
        function dv(d) {
          return uv.reduce((o, { parser: h, result: g }) => o || (h(d) ? g : null), null);
        }
        function Sl(d, o = "int") {
          const h = dv(d);
          return h ? h.notation === "hex" && o !== "float" ? Object.assign(Object.assign({}, h), {
            type: "int"
          }) : h.notation === "func" ? Object.assign(Object.assign({}, h), {
            type: o
          }) : null : null;
        }
        const qu = {
          int: [
            cv,
            hv,
            Iu("int"),
            ku("int"),
            Ou("int"),
            Bu("int"),
            Gu("int"),
            Wu("int")
          ],
          float: [
            Iu("float"),
            ku("float"),
            Ou("float"),
            Bu("float"),
            Gu("float"),
            Wu("float")
          ]
        };
        function pv(d) {
          const o = qu[d];
          return (h) => {
            if (typeof h != "string") return Qe.black(d);
            const g = o.reduce((E, N) => E || N(h), null);
            return g ?? Qe.black(d);
          };
        }
        function El(d) {
          const o = qu[d];
          return (h) => o.reduce((g, E) => g || E(h), null);
        }
        function Xu(d) {
          const o = Nt(Math.floor(d), 0, 255).toString(16);
          return o.length === 1 ? `0${o}` : o;
        }
        function ju(d, o = "#") {
          const h = Bi(d.getComponents("rgb")).map(Xu).join("");
          return `${o}${h}`;
        }
        function Tl(d, o = "#") {
          const h = d.getComponents("rgb"), g = [
            h[0],
            h[1],
            h[2],
            h[3] * 255
          ].map(Xu).join("");
          return `${o}${g}`;
        }
        function Ku(d, o) {
          const h = qt(o === "float" ? 2 : 0);
          return `rgb(${Bi(d.getComponents("rgb", o)).map((E) => h(E)).join(", ")})`;
        }
        function fv(d) {
          return (o) => Ku(o, d);
        }
        function Ho(d, o) {
          const h = qt(2), g = qt(o === "float" ? 2 : 0);
          return `rgba(${d.getComponents("rgb", o).map((N, V) => (V === 3 ? h : g)(N)).join(", ")})`;
        }
        function mv(d) {
          return (o) => Ho(o, d);
        }
        function gv(d) {
          const o = [
            qt(0),
            Fo,
            Fo
          ];
          return `hsl(${Bi(d.getComponents("hsl")).map((g, E) => o[E](g)).join(", ")})`;
        }
        function vv(d) {
          const o = [
            qt(0),
            Fo,
            Fo,
            qt(2)
          ];
          return `hsla(${d.getComponents("hsl").map((g, E) => o[E](g)).join(", ")})`;
        }
        function Yu(d, o) {
          const h = qt(o === "float" ? 2 : 0), g = [
            "r",
            "g",
            "b"
          ];
          return `{${Bi(d.getComponents("rgb", o)).map((N, V) => `${g[V]}: ${h(N)}`).join(", ")}}`;
        }
        function _v(d) {
          return (o) => Yu(o, d);
        }
        function $u(d, o) {
          const h = qt(2), g = qt(o === "float" ? 2 : 0), E = [
            "r",
            "g",
            "b",
            "a"
          ];
          return `{${d.getComponents("rgb", o).map((V, de) => {
            const Ue = de === 3 ? h : g;
            return `${E[de]}: ${Ue(V)}`;
          }).join(", ")}}`;
        }
        function xv(d) {
          return (o) => $u(o, d);
        }
        const bv = [
          {
            format: {
              alpha: false,
              mode: "rgb",
              notation: "hex",
              type: "int"
            },
            stringifier: ju
          },
          {
            format: {
              alpha: true,
              mode: "rgb",
              notation: "hex",
              type: "int"
            },
            stringifier: Tl
          },
          {
            format: {
              alpha: false,
              mode: "hsl",
              notation: "func",
              type: "int"
            },
            stringifier: gv
          },
          {
            format: {
              alpha: true,
              mode: "hsl",
              notation: "func",
              type: "int"
            },
            stringifier: vv
          },
          ...[
            "int",
            "float"
          ].reduce((d, o) => [
            ...d,
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "func",
                type: o
              },
              stringifier: fv(o)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "func",
                type: o
              },
              stringifier: mv(o)
            },
            {
              format: {
                alpha: false,
                mode: "rgb",
                notation: "object",
                type: o
              },
              stringifier: _v(o)
            },
            {
              format: {
                alpha: true,
                mode: "rgb",
                notation: "object",
                type: o
              },
              stringifier: xv(o)
            }
          ], [])
        ];
        function Cl(d) {
          return bv.reduce((o, h) => o || (av(h.format, d) ? h.stringifier : null), null);
        }
        const Ar = M("apl");
        class yv {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = h.value, this.value.emitter.on("change", this.onValueChange_), this.element = o.createElement("div"), this.element.classList.add(Ar()), h.viewProps.bindClassModifiers(this.element), h.viewProps.bindTabIndex(this.element);
            const g = o.createElement("div");
            g.classList.add(Ar("b")), this.element.appendChild(g);
            const E = o.createElement("div");
            E.classList.add(Ar("c")), g.appendChild(E), this.colorElem_ = E;
            const N = o.createElement("div");
            N.classList.add(Ar("m")), this.element.appendChild(N), this.markerElem_ = N;
            const V = o.createElement("div");
            V.classList.add(Ar("p")), this.markerElem_.appendChild(V), this.previewElem_ = V, this.update_();
          }
          update_() {
            const o = this.value.rawValue, h = o.getComponents("rgb"), g = new Qe([
              h[0],
              h[1],
              h[2],
              0
            ], "rgb"), E = new Qe([
              h[0],
              h[1],
              h[2],
              255
            ], "rgb"), N = [
              "to right",
              Ho(g),
              Ho(E)
            ];
            this.colorElem_.style.background = `linear-gradient(${N.join(",")})`, this.previewElem_.style.backgroundColor = Ho(o);
            const V = _t(h[3], 0, 1, 0, 100);
            this.markerElem_.style.left = `${V}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class wv {
          constructor(o, h) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.view = new yv(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(o, h) {
            if (!o.point) return;
            const g = o.point.x / o.bounds.width, E = this.value.rawValue, [N, V, de] = E.getComponents("hsv");
            this.value.setRawValue(new Qe([
              N,
              V,
              de,
              g
            ], "hsv"), h);
          }
          onPointerDown_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(o) {
            const h = rn(Ui(true), qn(o));
            if (h === 0) return;
            const g = this.value.rawValue, [E, N, V, de] = g.getComponents("hsv");
            this.value.setRawValue(new Qe([
              E,
              N,
              V,
              de + h
            ], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(o) {
            rn(Ui(true), qn(o)) !== 0 && this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const Ss = M("coltxt");
        function Mv(d) {
          const o = d.createElement("select"), h = [
            {
              text: "RGB",
              value: "rgb"
            },
            {
              text: "HSL",
              value: "hsl"
            },
            {
              text: "HSV",
              value: "hsv"
            }
          ];
          return o.appendChild(h.reduce((g, E) => {
            const N = d.createElement("option");
            return N.textContent = E.text, N.value = E.value, g.appendChild(N), g;
          }, d.createDocumentFragment())), o;
        }
        class Sv {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(Ss()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(Ss("m")), this.modeElem_ = Mv(o), this.modeElem_.classList.add(Ss("ms")), g.appendChild(this.modeSelectElement), h.viewProps.bindDisabled(this.modeElem_);
            const E = o.createElement("div");
            E.classList.add(Ss("mm")), E.appendChild($(o, "dropdown")), g.appendChild(E), this.element.appendChild(g);
            const N = o.createElement("div");
            N.classList.add(Ss("w")), this.element.appendChild(N), this.textsElem_ = N, this.textViews_ = h.textViews, this.applyTextViews_(), k(h.colorMode, (V) => {
              this.modeElem_.value = V;
            });
          }
          get modeSelectElement() {
            return this.modeElem_;
          }
          get textViews() {
            return this.textViews_;
          }
          set textViews(o) {
            this.textViews_ = o, this.applyTextViews_();
          }
          applyTextViews_() {
            xe(this.textsElem_);
            const o = this.element.ownerDocument;
            this.textViews_.forEach((h) => {
              const g = o.createElement("div");
              g.classList.add(Ss("c")), g.appendChild(h.element), this.textsElem_.appendChild(g);
            });
          }
        }
        function Ev(d) {
          return qt(d === "float" ? 2 : 0);
        }
        function Tv(d, o, h) {
          const g = Vo(d, o)[h];
          return new ys({
            min: 0,
            max: g
          });
        }
        function Al(d, o, h) {
          return new Tr(d, {
            arrayPosition: h === 0 ? "fst" : h === 2 ? "lst" : "mid",
            baseStep: Ui(false),
            parser: o.parser,
            props: W.fromObject({
              draggingScale: o.colorType === "float" ? 0.01 : 1,
              formatter: Ev(o.colorType)
            }),
            value: re(0, {
              constraint: Tv(o.colorMode, o.colorType, h)
            }),
            viewProps: o.viewProps
          });
        }
        class Cv {
          constructor(o, h) {
            this.onModeSelectChange_ = this.onModeSelectChange_.bind(this), this.colorType_ = h.colorType, this.parser_ = h.parser, this.value = h.value, this.viewProps = h.viewProps, this.colorMode = re(this.value.rawValue.mode), this.ccs_ = this.createComponentControllers_(o), this.view = new Sv(o, {
              colorMode: this.colorMode,
              textViews: [
                this.ccs_[0].view,
                this.ccs_[1].view,
                this.ccs_[2].view
              ],
              viewProps: this.viewProps
            }), this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_);
          }
          createComponentControllers_(o) {
            const h = {
              colorMode: this.colorMode.rawValue,
              colorType: this.colorType_,
              parser: this.parser_,
              viewProps: this.viewProps
            }, g = [
              Al(o, h, 0),
              Al(o, h, 1),
              Al(o, h, 2)
            ];
            return g.forEach((E, N) => {
              Sr({
                primary: this.value,
                secondary: E.value,
                forward: (V) => V.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[N],
                backward: (V, de) => {
                  const Ue = this.colorMode.rawValue, Ge = V.rawValue.getComponents(Ue, this.colorType_);
                  return Ge[N] = de.rawValue, new Qe(Au(Bi(Ge), Ge[3]), Ue, this.colorType_);
                }
              });
            }), g;
          }
          onModeSelectChange_(o) {
            const h = o.currentTarget;
            this.colorMode.rawValue = h.value, this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument), this.view.textViews = [
              this.ccs_[0].view,
              this.ccs_[1].view,
              this.ccs_[2].view
            ];
          }
        }
        const Pl = M("hpl");
        class Av {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = h.value, this.value.emitter.on("change", this.onValueChange_), this.element = o.createElement("div"), this.element.classList.add(Pl()), h.viewProps.bindClassModifiers(this.element), h.viewProps.bindTabIndex(this.element);
            const g = o.createElement("div");
            g.classList.add(Pl("c")), this.element.appendChild(g);
            const E = o.createElement("div");
            E.classList.add(Pl("m")), this.element.appendChild(E), this.markerElem_ = E, this.update_();
          }
          update_() {
            const o = this.value.rawValue, [h] = o.getComponents("hsv");
            this.markerElem_.style.backgroundColor = Ku(new Qe([
              h,
              100,
              100
            ], "hsv"));
            const g = _t(h, 0, 360, 0, 100);
            this.markerElem_.style.left = `${g}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class Pv {
          constructor(o, h) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.view = new Av(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(o, h) {
            if (!o.point) return;
            const g = _t(Nt(o.point.x, 0, o.bounds.width), 0, o.bounds.width, 0, 360), E = this.value.rawValue, [, N, V, de] = E.getComponents("hsv");
            this.value.setRawValue(new Qe([
              g,
              N,
              V,
              de
            ], "hsv"), h);
          }
          onPointerDown_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(o) {
            const h = rn(Ui(false), qn(o));
            if (h === 0) return;
            const g = this.value.rawValue, [E, N, V, de] = g.getComponents("hsv");
            this.value.setRawValue(new Qe([
              E + h,
              N,
              V,
              de
            ], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(o) {
            rn(Ui(false), qn(o)) !== 0 && this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        const Ll = M("svp"), Zu = 64;
        class Lv {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), this.value = h.value, this.value.emitter.on("change", this.onValueChange_), this.element = o.createElement("div"), this.element.classList.add(Ll()), h.viewProps.bindClassModifiers(this.element), h.viewProps.bindTabIndex(this.element);
            const g = o.createElement("canvas");
            g.height = Zu, g.width = Zu, g.classList.add(Ll("c")), this.element.appendChild(g), this.canvasElement = g;
            const E = o.createElement("div");
            E.classList.add(Ll("m")), this.element.appendChild(E), this.markerElem_ = E, this.update_();
          }
          update_() {
            const o = D(this.canvasElement);
            if (!o) return;
            const g = this.value.rawValue.getComponents("hsv"), E = this.canvasElement.width, N = this.canvasElement.height, V = o.getImageData(0, 0, E, N), de = V.data;
            for (let lt = 0; lt < N; lt++) for (let ut = 0; ut < E; ut++) {
              const Vi = _t(ut, 0, E, 0, 100), Lr = _t(lt, 0, N, 100, 0), Rr = Cu(g[0], Vi, Lr), Wo = (lt * E + ut) * 4;
              de[Wo] = Rr[0], de[Wo + 1] = Rr[1], de[Wo + 2] = Rr[2], de[Wo + 3] = 255;
            }
            o.putImageData(V, 0, 0);
            const Ue = _t(g[1], 0, 100, 0, 100);
            this.markerElem_.style.left = `${Ue}%`;
            const Ge = _t(g[2], 0, 100, 100, 0);
            this.markerElem_.style.top = `${Ge}%`;
          }
          onValueChange_() {
            this.update_();
          }
        }
        class Rv {
          constructor(o, h) {
            this.onKeyDown_ = this.onKeyDown_.bind(this), this.onKeyUp_ = this.onKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.view = new Lv(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Oi(this.view.element), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.element.addEventListener("keydown", this.onKeyDown_), this.view.element.addEventListener("keyup", this.onKeyUp_);
          }
          handlePointerEvent_(o, h) {
            if (!o.point) return;
            const g = _t(o.point.x, 0, o.bounds.width, 0, 100), E = _t(o.point.y, 0, o.bounds.height, 100, 0), [N, , , V] = this.value.rawValue.getComponents("hsv");
            this.value.setRawValue(new Qe([
              N,
              g,
              E,
              V
            ], "hsv"), h);
          }
          onPointerDown_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: true,
              last: true
            });
          }
          onKeyDown_(o) {
            wu(o.key) && o.preventDefault();
            const [h, g, E, N] = this.value.rawValue.getComponents("hsv"), V = Ui(false), de = rn(V, qn(o)), Ue = rn(V, Er(o));
            de === 0 && Ue === 0 || this.value.setRawValue(new Qe([
              h,
              g + de,
              E + Ue,
              N
            ], "hsv"), {
              forceEmit: false,
              last: false
            });
          }
          onKeyUp_(o) {
            const h = Ui(false), g = rn(h, qn(o)), E = rn(h, Er(o));
            g === 0 && E === 0 || this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        class Iv {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.hPaletteC_ = new Pv(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.svPaletteC_ = new Rv(o, {
              value: this.value,
              viewProps: this.viewProps
            }), this.alphaIcs_ = h.supportsAlpha ? {
              palette: new wv(o, {
                value: this.value,
                viewProps: this.viewProps
              }),
              text: new Tr(o, {
                parser: Wn,
                baseStep: 0.1,
                props: W.fromObject({
                  draggingScale: 0.01,
                  formatter: qt(2)
                }),
                value: re(0, {
                  constraint: new ys({
                    min: 0,
                    max: 1
                  })
                }),
                viewProps: this.viewProps
              })
            } : null, this.alphaIcs_ && Sr({
              primary: this.value,
              secondary: this.alphaIcs_.text.value,
              forward: (g) => g.rawValue.getComponents()[3],
              backward: (g, E) => {
                const N = g.rawValue.getComponents();
                return N[3] = E.rawValue, new Qe(N, g.rawValue.mode);
              }
            }), this.textC_ = new Cv(o, {
              colorType: h.colorType,
              parser: Wn,
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new rv(o, {
              alphaViews: this.alphaIcs_ ? {
                palette: this.alphaIcs_.palette.view,
                text: this.alphaIcs_.text.view
              } : null,
              hPaletteView: this.hPaletteC_.view,
              supportsAlpha: h.supportsAlpha,
              svPaletteView: this.svPaletteC_.view,
              textView: this.textC_.view,
              viewProps: this.viewProps
            });
          }
          get textController() {
            return this.textC_;
          }
        }
        const Rl = M("colsw");
        class Dv {
          constructor(o, h) {
            this.onValueChange_ = this.onValueChange_.bind(this), h.value.emitter.on("change", this.onValueChange_), this.value = h.value, this.element = o.createElement("div"), this.element.classList.add(Rl()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(Rl("sw")), this.element.appendChild(g), this.swatchElem_ = g;
            const E = o.createElement("button");
            E.classList.add(Rl("b")), h.viewProps.bindDisabled(E), this.element.appendChild(E), this.buttonElement = E, this.update_();
          }
          update_() {
            const o = this.value.rawValue;
            this.swatchElem_.style.backgroundColor = Tl(o);
          }
          onValueChange_() {
            this.update_();
          }
        }
        class kv {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.view = new Dv(o, {
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        class Il {
          constructor(o, h) {
            this.onButtonBlur_ = this.onButtonBlur_.bind(this), this.onButtonClick_ = this.onButtonClick_.bind(this), this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.foldable_ = je.create(h.expanded), this.swatchC_ = new kv(o, {
              value: this.value,
              viewProps: this.viewProps
            });
            const g = this.swatchC_.view.buttonElement;
            g.addEventListener("blur", this.onButtonBlur_), g.addEventListener("click", this.onButtonClick_), this.textC_ = new Oo(o, {
              parser: h.parser,
              props: W.fromObject({
                formatter: h.formatter
              }),
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new Yg(o, {
              foldable: this.foldable_,
              pickerLayout: h.pickerLayout
            }), this.view.swatchElement.appendChild(this.swatchC_.view.element), this.view.textElement.appendChild(this.textC_.view.element), this.popC_ = h.pickerLayout === "popup" ? new pu(o, {
              viewProps: this.viewProps
            }) : null;
            const E = new Iv(o, {
              colorType: h.colorType,
              supportsAlpha: h.supportsAlpha,
              value: this.value,
              viewProps: this.viewProps
            });
            E.view.allFocusableElements.forEach((N) => {
              N.addEventListener("blur", this.onPopupChildBlur_), N.addEventListener("keydown", this.onPopupChildKeydown_);
            }), this.pickerC_ = E, this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(E.view.element), Sr({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (N) => N.rawValue,
              backward: (N, V) => V.rawValue
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), J(this.foldable_, this.view.pickerElement));
          }
          get textController() {
            return this.textC_;
          }
          onButtonBlur_(o) {
            if (!this.popC_) return;
            const h = this.view.element, g = o.relatedTarget;
            (!g || !h.contains(g)) && (this.popC_.shows.rawValue = false);
          }
          onButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
          }
          onPopupChildBlur_(o) {
            if (!this.popC_) return;
            const h = this.popC_.view.element, g = O(o);
            g && h.contains(g) || g && g === this.swatchC_.view.buttonElement && !Re(h.ownerDocument) || (this.popC_.shows.rawValue = false);
          }
          onPopupChildKeydown_(o) {
            this.popC_ ? o.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && o.key === "Escape" && this.swatchC_.view.buttonElement.focus();
          }
        }
        function Nv(d, o) {
          return Qe.isColorObject(d) ? Qe.fromObject(d, o) : Qe.black(o);
        }
        function Ov(d) {
          return Bi(d.getComponents("rgb")).reduce((o, h) => o << 8 | Math.floor(h) & 255, 0);
        }
        function Fv(d) {
          return d.getComponents("rgb").reduce((o, h, g) => {
            const E = Math.floor(g === 3 ? h * 255 : h) & 255;
            return o << 8 | E;
          }, 0) >>> 0;
        }
        function Bv(d) {
          return new Qe([
            d >> 16 & 255,
            d >> 8 & 255,
            d & 255
          ], "rgb");
        }
        function Uv(d) {
          return new Qe([
            d >> 24 & 255,
            d >> 16 & 255,
            d >> 8 & 255,
            _t(d & 255, 0, 255, 0, 1)
          ], "rgb");
        }
        function zv(d) {
          return typeof d != "number" ? Qe.black() : Bv(d);
        }
        function Vv(d) {
          return typeof d != "number" ? Qe.black() : Uv(d);
        }
        function Gv(d) {
          const o = Cl(d);
          return o ? (h, g) => {
            Cr(h, o(g));
          } : null;
        }
        function Hv(d) {
          const o = d ? Fv : Ov;
          return (h, g) => {
            Cr(h, o(g));
          };
        }
        function Wv(d, o, h) {
          const g = o.toRgbaObject(h);
          d.writeProperty("r", g.r), d.writeProperty("g", g.g), d.writeProperty("b", g.b), d.writeProperty("a", g.a);
        }
        function qv(d, o, h) {
          const g = o.toRgbaObject(h);
          d.writeProperty("r", g.r), d.writeProperty("g", g.g), d.writeProperty("b", g.b);
        }
        function Xv(d, o) {
          return (h, g) => {
            d ? Wv(h, g, o) : qv(h, g, o);
          };
        }
        function Dl(d) {
          var o;
          return !!((d == null ? void 0 : d.alpha) || !((o = d == null ? void 0 : d.color) === null || o === void 0) && o.alpha);
        }
        function jv(d) {
          return d ? (o) => Tl(o, "0x") : (o) => ju(o, "0x");
        }
        function Kv(d) {
          return "color" in d || "view" in d && d.view === "color";
        }
        const Yv = {
          id: "input-color-number",
          type: "input",
          accept: (d, o) => {
            if (typeof d != "number" || !Kv(o)) return null;
            const h = Ml(o);
            return h ? {
              initialValue: d,
              params: h
            } : null;
          },
          binding: {
            reader: (d) => Dl(d.params) ? Vv : zv,
            equals: Qe.equals,
            writer: (d) => Hv(Dl(d.params))
          },
          controller: (d) => {
            const o = Dl(d.params), h = "expanded" in d.params ? d.params.expanded : void 0, g = "picker" in d.params ? d.params.picker : void 0;
            return new Il(d.document, {
              colorType: "int",
              expanded: h ?? false,
              formatter: jv(o),
              parser: El("int"),
              pickerLayout: g ?? "popup",
              supportsAlpha: o,
              value: d.value,
              viewProps: d.viewProps
            });
          }
        };
        function $v(d) {
          return Qe.isRgbaColorObject(d);
        }
        function Zv(d) {
          return (o) => Nv(o, d);
        }
        function Jv(d, o) {
          return (h) => d ? $u(h, o) : Yu(h, o);
        }
        const Qv = {
          id: "input-color-object",
          type: "input",
          accept: (d, o) => {
            if (!Qe.isColorObject(d)) return null;
            const h = Ml(o);
            return h ? {
              initialValue: d,
              params: h
            } : null;
          },
          binding: {
            reader: (d) => Zv(zi(d.params)),
            equals: Qe.equals,
            writer: (d) => Xv($v(d.initialValue), zi(d.params))
          },
          controller: (d) => {
            var o;
            const h = Qe.isRgbaColorObject(d.initialValue), g = "expanded" in d.params ? d.params.expanded : void 0, E = "picker" in d.params ? d.params.picker : void 0, N = (o = zi(d.params)) !== null && o !== void 0 ? o : "int";
            return new Il(d.document, {
              colorType: N,
              expanded: g ?? false,
              formatter: Jv(h, N),
              parser: El(N),
              pickerLayout: E ?? "popup",
              supportsAlpha: h,
              value: d.value,
              viewProps: d.viewProps
            });
          }
        }, e_ = {
          id: "input-color-string",
          type: "input",
          accept: (d, o) => {
            if (typeof d != "string" || "view" in o && o.view === "text") return null;
            const h = Sl(d, zi(o));
            if (!h || !Cl(h)) return null;
            const E = Ml(o);
            return E ? {
              initialValue: d,
              params: E
            } : null;
          },
          binding: {
            reader: (d) => {
              var o;
              return pv((o = zi(d.params)) !== null && o !== void 0 ? o : "int");
            },
            equals: Qe.equals,
            writer: (d) => {
              const o = Sl(d.initialValue, zi(d.params));
              if (!o) throw _.shouldNeverHappen();
              const h = Gv(o);
              if (!h) throw _.notBindable();
              return h;
            }
          },
          controller: (d) => {
            const o = Sl(d.initialValue, zi(d.params));
            if (!o) throw _.shouldNeverHappen();
            const h = Cl(o);
            if (!h) throw _.shouldNeverHappen();
            const g = "expanded" in d.params ? d.params.expanded : void 0, E = "picker" in d.params ? d.params.picker : void 0;
            return new Il(d.document, {
              colorType: o.type,
              expanded: g ?? false,
              formatter: h,
              parser: El(o.type),
              pickerLayout: E ?? "popup",
              supportsAlpha: o.alpha,
              value: d.value,
              viewProps: d.viewProps
            });
          }
        };
        class hi {
          constructor(o) {
            this.components = o.components, this.asm_ = o.assembly;
          }
          constrain(o) {
            const h = this.asm_.toComponents(o).map((g, E) => {
              var N, V;
              return (V = (N = this.components[E]) === null || N === void 0 ? void 0 : N.constrain(g)) !== null && V !== void 0 ? V : g;
            });
            return this.asm_.fromComponents(h);
          }
        }
        const Ju = M("pndtxt");
        class t_ {
          constructor(o, h) {
            this.textViews = h.textViews, this.element = o.createElement("div"), this.element.classList.add(Ju()), this.textViews.forEach((g) => {
              const E = o.createElement("div");
              E.classList.add(Ju("a")), E.appendChild(g.element), this.element.appendChild(E);
            });
          }
        }
        function n_(d, o, h) {
          return new Tr(d, {
            arrayPosition: h === 0 ? "fst" : h === o.axes.length - 1 ? "lst" : "mid",
            baseStep: o.axes[h].baseStep,
            parser: o.parser,
            props: o.axes[h].textProps,
            value: re(0, {
              constraint: o.axes[h].constraint
            }),
            viewProps: o.viewProps
          });
        }
        class kl {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.acs_ = h.axes.map((g, E) => n_(o, h, E)), this.acs_.forEach((g, E) => {
              Sr({
                primary: this.value,
                secondary: g.value,
                forward: (N) => h.assembly.toComponents(N.rawValue)[E],
                backward: (N, V) => {
                  const de = h.assembly.toComponents(N.rawValue);
                  return de[E] = V.rawValue, h.assembly.fromComponents(de);
                }
              });
            }), this.view = new t_(o, {
              textViews: this.acs_.map((g) => g.view)
            });
          }
        }
        function Qu(d, o) {
          return "step" in d && !f(d.step) ? new No(d.step, o) : null;
        }
        function ed(d) {
          return !f(d.max) && !f(d.min) ? new ys({
            max: d.max,
            min: d.min
          }) : !f(d.max) || !f(d.min) ? new uu({
            max: d.max,
            min: d.min
          }) : null;
        }
        function i_(d) {
          const o = Hn(d, ys);
          if (o) return [
            o.values.get("min"),
            o.values.get("max")
          ];
          const h = Hn(d, uu);
          return h ? [
            h.minValue,
            h.maxValue
          ] : [
            void 0,
            void 0
          ];
        }
        function s_(d, o) {
          const h = [], g = Qu(d, o);
          g && h.push(g);
          const E = ed(d);
          E && h.push(E);
          const N = wl(d.options);
          return N && h.push(N), new xr(h);
        }
        const r_ = {
          id: "input-number",
          type: "input",
          accept: (d, o) => {
            if (typeof d != "number") return null;
            const h = oe, g = ce(o, {
              format: h.optional.function,
              max: h.optional.number,
              min: h.optional.number,
              options: h.optional.custom(Bo),
              step: h.optional.number
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => bu,
            constraint: (d) => s_(d.params, d.initialValue),
            writer: (d) => Cr
          },
          controller: (d) => {
            var o;
            const h = d.value, g = d.constraint, E = g && Hn(g, br);
            if (E) return new yr(d.document, {
              props: new W({
                options: E.values.value("options")
              }),
              value: h,
              viewProps: d.viewProps
            });
            const N = (o = "format" in d.params ? d.params.format : void 0) !== null && o !== void 0 ? o : qt(Uo(g, h.rawValue)), V = g && Hn(g, ys);
            return V ? new yl(d.document, {
              baseStep: ws(g),
              parser: Wn,
              sliderProps: new W({
                maxValue: V.values.value("max"),
                minValue: V.values.value("min")
              }),
              textProps: W.fromObject({
                draggingScale: Ms(g, h.rawValue),
                formatter: N
              }),
              value: h,
              viewProps: d.viewProps
            }) : new Tr(d.document, {
              baseStep: ws(g),
              parser: Wn,
              props: W.fromObject({
                draggingScale: Ms(g, h.rawValue),
                formatter: N
              }),
              value: h,
              viewProps: d.viewProps
            });
          }
        };
        class ui {
          constructor(o = 0, h = 0) {
            this.x = o, this.y = h;
          }
          getComponents() {
            return [
              this.x,
              this.y
            ];
          }
          static isObject(o) {
            if (f(o)) return false;
            const h = o.x, g = o.y;
            return !(typeof h != "number" || typeof g != "number");
          }
          static equals(o, h) {
            return o.x === h.x && o.y === h.y;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y
            };
          }
        }
        const td = {
          toComponents: (d) => d.getComponents(),
          fromComponents: (d) => new ui(...d)
        }, Es = M("p2d");
        class o_ {
          constructor(o, h) {
            this.element = o.createElement("div"), this.element.classList.add(Es()), h.viewProps.bindClassModifiers(this.element), k(h.expanded, F(this.element, Es(void 0, "expanded")));
            const g = o.createElement("div");
            g.classList.add(Es("h")), this.element.appendChild(g);
            const E = o.createElement("button");
            E.classList.add(Es("b")), E.appendChild($(o, "p2dpad")), h.viewProps.bindDisabled(E), g.appendChild(E), this.buttonElement = E;
            const N = o.createElement("div");
            if (N.classList.add(Es("t")), g.appendChild(N), this.textElement = N, h.pickerLayout === "inline") {
              const V = o.createElement("div");
              V.classList.add(Es("p")), this.element.appendChild(V), this.pickerElement = V;
            } else this.pickerElement = null;
          }
        }
        const di = M("p2dp");
        class a_ {
          constructor(o, h) {
            this.onFoldableChange_ = this.onFoldableChange_.bind(this), this.onValueChange_ = this.onValueChange_.bind(this), this.invertsY_ = h.invertsY, this.maxValue_ = h.maxValue, this.element = o.createElement("div"), this.element.classList.add(di()), h.layout === "popup" && this.element.classList.add(di(void 0, "p")), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("div");
            g.classList.add(di("p")), h.viewProps.bindTabIndex(g), this.element.appendChild(g), this.padElement = g;
            const E = o.createElementNS(fe, "svg");
            E.classList.add(di("g")), this.padElement.appendChild(E), this.svgElem_ = E;
            const N = o.createElementNS(fe, "line");
            N.classList.add(di("ax")), N.setAttributeNS(null, "x1", "0"), N.setAttributeNS(null, "y1", "50%"), N.setAttributeNS(null, "x2", "100%"), N.setAttributeNS(null, "y2", "50%"), this.svgElem_.appendChild(N);
            const V = o.createElementNS(fe, "line");
            V.classList.add(di("ax")), V.setAttributeNS(null, "x1", "50%"), V.setAttributeNS(null, "y1", "0"), V.setAttributeNS(null, "x2", "50%"), V.setAttributeNS(null, "y2", "100%"), this.svgElem_.appendChild(V);
            const de = o.createElementNS(fe, "line");
            de.classList.add(di("l")), de.setAttributeNS(null, "x1", "50%"), de.setAttributeNS(null, "y1", "50%"), this.svgElem_.appendChild(de), this.lineElem_ = de;
            const Ue = o.createElement("div");
            Ue.classList.add(di("m")), this.padElement.appendChild(Ue), this.markerElem_ = Ue, h.value.emitter.on("change", this.onValueChange_), this.value = h.value, this.update_();
          }
          get allFocusableElements() {
            return [
              this.padElement
            ];
          }
          update_() {
            const [o, h] = this.value.rawValue.getComponents(), g = this.maxValue_, E = _t(o, -g, +g, 0, 100), N = _t(h, -g, +g, 0, 100), V = this.invertsY_ ? 100 - N : N;
            this.lineElem_.setAttributeNS(null, "x2", `${E}%`), this.lineElem_.setAttributeNS(null, "y2", `${V}%`), this.markerElem_.style.left = `${E}%`, this.markerElem_.style.top = `${V}%`;
          }
          onValueChange_() {
            this.update_();
          }
          onFoldableChange_() {
            this.update_();
          }
        }
        function nd(d, o, h) {
          return [
            rn(o[0], qn(d)),
            rn(o[1], Er(d)) * (h ? 1 : -1)
          ];
        }
        class l_ {
          constructor(o, h) {
            this.onPadKeyDown_ = this.onPadKeyDown_.bind(this), this.onPadKeyUp_ = this.onPadKeyUp_.bind(this), this.onPointerDown_ = this.onPointerDown_.bind(this), this.onPointerMove_ = this.onPointerMove_.bind(this), this.onPointerUp_ = this.onPointerUp_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.baseSteps_ = h.baseSteps, this.maxValue_ = h.maxValue, this.invertsY_ = h.invertsY, this.view = new a_(o, {
              invertsY: this.invertsY_,
              layout: h.layout,
              maxValue: this.maxValue_,
              value: this.value,
              viewProps: this.viewProps
            }), this.ptHandler_ = new Oi(this.view.padElement), this.ptHandler_.emitter.on("down", this.onPointerDown_), this.ptHandler_.emitter.on("move", this.onPointerMove_), this.ptHandler_.emitter.on("up", this.onPointerUp_), this.view.padElement.addEventListener("keydown", this.onPadKeyDown_), this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
          }
          handlePointerEvent_(o, h) {
            if (!o.point) return;
            const g = this.maxValue_, E = _t(o.point.x, 0, o.bounds.width, -g, +g), N = _t(this.invertsY_ ? o.bounds.height - o.point.y : o.point.y, 0, o.bounds.height, -g, +g);
            this.value.setRawValue(new ui(E, N), h);
          }
          onPointerDown_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerMove_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: false,
              last: false
            });
          }
          onPointerUp_(o) {
            this.handlePointerEvent_(o.data, {
              forceEmit: true,
              last: true
            });
          }
          onPadKeyDown_(o) {
            wu(o.key) && o.preventDefault();
            const [h, g] = nd(o, this.baseSteps_, this.invertsY_);
            h === 0 && g === 0 || this.value.setRawValue(new ui(this.value.rawValue.x + h, this.value.rawValue.y + g), {
              forceEmit: false,
              last: false
            });
          }
          onPadKeyUp_(o) {
            const [h, g] = nd(o, this.baseSteps_, this.invertsY_);
            h === 0 && g === 0 || this.value.setRawValue(this.value.rawValue, {
              forceEmit: true,
              last: true
            });
          }
        }
        class c_ {
          constructor(o, h) {
            var g, E;
            this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this), this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this), this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this), this.onPadButtonClick_ = this.onPadButtonClick_.bind(this), this.value = h.value, this.viewProps = h.viewProps, this.foldable_ = je.create(h.expanded), this.popC_ = h.pickerLayout === "popup" ? new pu(o, {
              viewProps: this.viewProps
            }) : null;
            const N = new l_(o, {
              baseSteps: [
                h.axes[0].baseStep,
                h.axes[1].baseStep
              ],
              invertsY: h.invertsY,
              layout: h.pickerLayout,
              maxValue: h.maxValue,
              value: this.value,
              viewProps: this.viewProps
            });
            N.view.allFocusableElements.forEach((V) => {
              V.addEventListener("blur", this.onPopupChildBlur_), V.addEventListener("keydown", this.onPopupChildKeydown_);
            }), this.pickerC_ = N, this.textC_ = new kl(o, {
              assembly: td,
              axes: h.axes,
              parser: h.parser,
              value: this.value,
              viewProps: this.viewProps
            }), this.view = new o_(o, {
              expanded: this.foldable_.value("expanded"),
              pickerLayout: h.pickerLayout,
              viewProps: this.viewProps
            }), this.view.textElement.appendChild(this.textC_.view.element), (g = this.view.buttonElement) === null || g === void 0 || g.addEventListener("blur", this.onPadButtonBlur_), (E = this.view.buttonElement) === null || E === void 0 || E.addEventListener("click", this.onPadButtonClick_), this.popC_ ? (this.view.element.appendChild(this.popC_.view.element), this.popC_.view.element.appendChild(this.pickerC_.view.element), Sr({
              primary: this.foldable_.value("expanded"),
              secondary: this.popC_.shows,
              forward: (V) => V.rawValue,
              backward: (V, de) => de.rawValue
            })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element), J(this.foldable_, this.view.pickerElement));
          }
          onPadButtonBlur_(o) {
            if (!this.popC_) return;
            const h = this.view.element, g = o.relatedTarget;
            (!g || !h.contains(g)) && (this.popC_.shows.rawValue = false);
          }
          onPadButtonClick_() {
            this.foldable_.set("expanded", !this.foldable_.get("expanded")), this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus();
          }
          onPopupChildBlur_(o) {
            if (!this.popC_) return;
            const h = this.popC_.view.element, g = O(o);
            g && h.contains(g) || g && g === this.view.buttonElement && !Re(h.ownerDocument) || (this.popC_.shows.rawValue = false);
          }
          onPopupChildKeydown_(o) {
            this.popC_ ? o.key === "Escape" && (this.popC_.shows.rawValue = false) : this.view.pickerElement && o.key === "Escape" && this.view.buttonElement.focus();
          }
        }
        class Ts {
          constructor(o = 0, h = 0, g = 0) {
            this.x = o, this.y = h, this.z = g;
          }
          getComponents() {
            return [
              this.x,
              this.y,
              this.z
            ];
          }
          static isObject(o) {
            if (f(o)) return false;
            const h = o.x, g = o.y, E = o.z;
            return !(typeof h != "number" || typeof g != "number" || typeof E != "number");
          }
          static equals(o, h) {
            return o.x === h.x && o.y === h.y && o.z === h.z;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z
            };
          }
        }
        const id = {
          toComponents: (d) => d.getComponents(),
          fromComponents: (d) => new Ts(...d)
        };
        function h_(d) {
          return Ts.isObject(d) ? new Ts(d.x, d.y, d.z) : new Ts();
        }
        function u_(d, o) {
          d.writeProperty("x", o.x), d.writeProperty("y", o.y), d.writeProperty("z", o.z);
        }
        function d_(d, o) {
          return new hi({
            assembly: id,
            components: [
              Xn("x" in d ? d.x : void 0, o.x),
              Xn("y" in d ? d.y : void 0, o.y),
              Xn("z" in d ? d.z : void 0, o.z)
            ]
          });
        }
        function Nl(d, o) {
          return {
            baseStep: ws(o),
            constraint: o,
            textProps: W.fromObject({
              draggingScale: Ms(o, d),
              formatter: qt(Uo(o, d))
            })
          };
        }
        const p_ = {
          id: "input-point3d",
          type: "input",
          accept: (d, o) => {
            if (!Ts.isObject(d)) return null;
            const h = oe, g = ce(o, {
              x: h.optional.custom(li),
              y: h.optional.custom(li),
              z: h.optional.custom(li)
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => h_,
            constraint: (d) => d_(d.params, d.initialValue),
            equals: Ts.equals,
            writer: (d) => u_
          },
          controller: (d) => {
            const o = d.value, h = d.constraint;
            if (!(h instanceof hi)) throw _.shouldNeverHappen();
            return new kl(d.document, {
              assembly: id,
              axes: [
                Nl(o.rawValue.x, h.components[0]),
                Nl(o.rawValue.y, h.components[1]),
                Nl(o.rawValue.z, h.components[2])
              ],
              parser: Wn,
              value: o,
              viewProps: d.viewProps
            });
          }
        };
        class Cs {
          constructor(o = 0, h = 0, g = 0, E = 0) {
            this.x = o, this.y = h, this.z = g, this.w = E;
          }
          getComponents() {
            return [
              this.x,
              this.y,
              this.z,
              this.w
            ];
          }
          static isObject(o) {
            if (f(o)) return false;
            const h = o.x, g = o.y, E = o.z, N = o.w;
            return !(typeof h != "number" || typeof g != "number" || typeof E != "number" || typeof N != "number");
          }
          static equals(o, h) {
            return o.x === h.x && o.y === h.y && o.z === h.z && o.w === h.w;
          }
          toObject() {
            return {
              x: this.x,
              y: this.y,
              z: this.z,
              w: this.w
            };
          }
        }
        const sd = {
          toComponents: (d) => d.getComponents(),
          fromComponents: (d) => new Cs(...d)
        };
        function f_(d) {
          return Cs.isObject(d) ? new Cs(d.x, d.y, d.z, d.w) : new Cs();
        }
        function m_(d, o) {
          d.writeProperty("x", o.x), d.writeProperty("y", o.y), d.writeProperty("z", o.z), d.writeProperty("w", o.w);
        }
        function g_(d, o) {
          return new hi({
            assembly: sd,
            components: [
              Xn("x" in d ? d.x : void 0, o.x),
              Xn("y" in d ? d.y : void 0, o.y),
              Xn("z" in d ? d.z : void 0, o.z),
              Xn("w" in d ? d.w : void 0, o.w)
            ]
          });
        }
        function v_(d, o) {
          return {
            baseStep: ws(o),
            constraint: o,
            textProps: W.fromObject({
              draggingScale: Ms(o, d),
              formatter: qt(Uo(o, d))
            })
          };
        }
        const __ = {
          id: "input-point4d",
          type: "input",
          accept: (d, o) => {
            if (!Cs.isObject(d)) return null;
            const h = oe, g = ce(o, {
              x: h.optional.custom(li),
              y: h.optional.custom(li),
              z: h.optional.custom(li),
              w: h.optional.custom(li)
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => f_,
            constraint: (d) => g_(d.params, d.initialValue),
            equals: Cs.equals,
            writer: (d) => m_
          },
          controller: (d) => {
            const o = d.value, h = d.constraint;
            if (!(h instanceof hi)) throw _.shouldNeverHappen();
            return new kl(d.document, {
              assembly: sd,
              axes: o.rawValue.getComponents().map((g, E) => v_(g, h.components[E])),
              parser: Wn,
              value: o,
              viewProps: d.viewProps
            });
          }
        };
        function x_(d) {
          const o = [], h = wl(d.options);
          return h && o.push(h), new xr(o);
        }
        const b_ = {
          id: "input-string",
          type: "input",
          accept: (d, o) => {
            if (typeof d != "string") return null;
            const g = ce(o, {
              options: oe.optional.custom(Bo)
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => yu,
            constraint: (d) => x_(d.params),
            writer: (d) => Cr
          },
          controller: (d) => {
            const o = d.document, h = d.value, g = d.constraint, E = g && Hn(g, br);
            return E ? new yr(o, {
              props: new W({
                options: E.values.value("options")
              }),
              value: h,
              viewProps: d.viewProps
            }) : new Oo(o, {
              parser: (N) => N,
              props: W.fromObject({
                formatter: vl
              }),
              value: h,
              viewProps: d.viewProps
            });
          }
        }, Pr = {
          monitor: {
            defaultInterval: 200,
            defaultLineCount: 3
          }
        }, rd = M("mll");
        class y_ {
          constructor(o, h) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = h.formatter, this.element = o.createElement("div"), this.element.classList.add(rd()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("textarea");
            g.classList.add(rd("i")), g.style.height = `calc(var(--bld-us) * ${h.lineCount})`, g.readOnly = true, h.viewProps.bindDisabled(g), this.element.appendChild(g), this.textareaElem_ = g, h.value.emitter.on("change", this.onValueUpdate_), this.value = h.value, this.update_();
          }
          update_() {
            const o = this.textareaElem_, h = o.scrollTop === o.scrollHeight - o.clientHeight, g = [];
            this.value.rawValue.forEach((E) => {
              E !== void 0 && g.push(this.formatter_(E));
            }), o.textContent = g.join(`
`), h && (o.scrollTop = o.scrollHeight);
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class Ol {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.view = new y_(o, {
              formatter: h.formatter,
              lineCount: h.lineCount,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const od = M("sgl");
        class w_ {
          constructor(o, h) {
            this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.formatter_ = h.formatter, this.element = o.createElement("div"), this.element.classList.add(od()), h.viewProps.bindClassModifiers(this.element);
            const g = o.createElement("input");
            g.classList.add(od("i")), g.readOnly = true, g.type = "text", h.viewProps.bindDisabled(g), this.element.appendChild(g), this.inputElement = g, h.value.emitter.on("change", this.onValueUpdate_), this.value = h.value, this.update_();
          }
          update_() {
            const o = this.value.rawValue, h = o[o.length - 1];
            this.inputElement.value = h !== void 0 ? this.formatter_(h) : "";
          }
          onValueUpdate_() {
            this.update_();
          }
        }
        class Fl {
          constructor(o, h) {
            this.value = h.value, this.viewProps = h.viewProps, this.view = new w_(o, {
              formatter: h.formatter,
              value: this.value,
              viewProps: this.viewProps
            });
          }
        }
        const M_ = {
          id: "monitor-bool",
          type: "monitor",
          accept: (d, o) => {
            if (typeof d != "boolean") return null;
            const g = ce(o, {
              lineCount: oe.optional.number
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => mu
          },
          controller: (d) => {
            var o;
            return d.value.rawValue.length === 1 ? new Fl(d.document, {
              formatter: gu,
              value: d.value,
              viewProps: d.viewProps
            }) : new Ol(d.document, {
              formatter: gu,
              lineCount: (o = d.params.lineCount) !== null && o !== void 0 ? o : Pr.monitor.defaultLineCount,
              value: d.value,
              viewProps: d.viewProps
            });
          }
        }, pi = M("grl");
        class S_ {
          constructor(o, h) {
            this.onCursorChange_ = this.onCursorChange_.bind(this), this.onValueUpdate_ = this.onValueUpdate_.bind(this), this.element = o.createElement("div"), this.element.classList.add(pi()), h.viewProps.bindClassModifiers(this.element), this.formatter_ = h.formatter, this.props_ = h.props, this.cursor_ = h.cursor, this.cursor_.emitter.on("change", this.onCursorChange_);
            const g = o.createElementNS(fe, "svg");
            g.classList.add(pi("g")), g.style.height = `calc(var(--bld-us) * ${h.lineCount})`, this.element.appendChild(g), this.svgElem_ = g;
            const E = o.createElementNS(fe, "polyline");
            this.svgElem_.appendChild(E), this.lineElem_ = E;
            const N = o.createElement("div");
            N.classList.add(pi("t"), M("tt")()), this.element.appendChild(N), this.tooltipElem_ = N, h.value.emitter.on("change", this.onValueUpdate_), this.value = h.value, this.update_();
          }
          get graphElement() {
            return this.svgElem_;
          }
          update_() {
            const o = this.svgElem_.getBoundingClientRect(), h = this.value.rawValue.length - 1, g = this.props_.get("minValue"), E = this.props_.get("maxValue"), N = [];
            this.value.rawValue.forEach((lt, ut) => {
              if (lt === void 0) return;
              const Vi = _t(ut, 0, h, 0, o.width), Lr = _t(lt, g, E, o.height, 0);
              N.push([
                Vi,
                Lr
              ].join(","));
            }), this.lineElem_.setAttributeNS(null, "points", N.join(" "));
            const V = this.tooltipElem_, de = this.value.rawValue[this.cursor_.rawValue];
            if (de === void 0) {
              V.classList.remove(pi("t", "a"));
              return;
            }
            const Ue = _t(this.cursor_.rawValue, 0, h, 0, o.width), Ge = _t(de, g, E, o.height, 0);
            V.style.left = `${Ue}px`, V.style.top = `${Ge}px`, V.textContent = `${this.formatter_(de)}`, V.classList.contains(pi("t", "a")) || (V.classList.add(pi("t", "a"), pi("t", "in")), Fe(V), V.classList.remove(pi("t", "in")));
          }
          onValueUpdate_() {
            this.update_();
          }
          onCursorChange_() {
            this.update_();
          }
        }
        class E_ {
          constructor(o, h) {
            if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this), this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this), this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this), this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this), this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this), this.props_ = h.props, this.value = h.value, this.viewProps = h.viewProps, this.cursor_ = re(-1), this.view = new S_(o, {
              cursor: this.cursor_,
              formatter: h.formatter,
              lineCount: h.lineCount,
              props: this.props_,
              value: this.value,
              viewProps: this.viewProps
            }), !Re(o)) this.view.element.addEventListener("mousemove", this.onGraphMouseMove_), this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
            else {
              const g = new Oi(this.view.element);
              g.emitter.on("down", this.onGraphPointerDown_), g.emitter.on("move", this.onGraphPointerMove_), g.emitter.on("up", this.onGraphPointerUp_);
            }
          }
          onGraphMouseLeave_() {
            this.cursor_.rawValue = -1;
          }
          onGraphMouseMove_(o) {
            const h = this.view.element.getBoundingClientRect();
            this.cursor_.rawValue = Math.floor(_t(o.offsetX, 0, h.width, 0, this.value.rawValue.length));
          }
          onGraphPointerDown_(o) {
            this.onGraphPointerMove_(o);
          }
          onGraphPointerMove_(o) {
            if (!o.data.point) {
              this.cursor_.rawValue = -1;
              return;
            }
            this.cursor_.rawValue = Math.floor(_t(o.data.point.x, 0, o.data.bounds.width, 0, this.value.rawValue.length));
          }
          onGraphPointerUp_() {
            this.cursor_.rawValue = -1;
          }
        }
        function Bl(d) {
          return "format" in d && !f(d.format) ? d.format : qt(2);
        }
        function T_(d) {
          var o;
          return d.value.rawValue.length === 1 ? new Fl(d.document, {
            formatter: Bl(d.params),
            value: d.value,
            viewProps: d.viewProps
          }) : new Ol(d.document, {
            formatter: Bl(d.params),
            lineCount: (o = d.params.lineCount) !== null && o !== void 0 ? o : Pr.monitor.defaultLineCount,
            value: d.value,
            viewProps: d.viewProps
          });
        }
        function C_(d) {
          var o, h, g;
          return new E_(d.document, {
            formatter: Bl(d.params),
            lineCount: (o = d.params.lineCount) !== null && o !== void 0 ? o : Pr.monitor.defaultLineCount,
            props: W.fromObject({
              maxValue: (h = "max" in d.params ? d.params.max : null) !== null && h !== void 0 ? h : 100,
              minValue: (g = "min" in d.params ? d.params.min : null) !== null && g !== void 0 ? g : 0
            }),
            value: d.value,
            viewProps: d.viewProps
          });
        }
        function ad(d) {
          return "view" in d && d.view === "graph";
        }
        const A_ = {
          id: "monitor-number",
          type: "monitor",
          accept: (d, o) => {
            if (typeof d != "number") return null;
            const h = oe, g = ce(o, {
              format: h.optional.function,
              lineCount: h.optional.number,
              max: h.optional.number,
              min: h.optional.number,
              view: h.optional.string
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            defaultBufferSize: (d) => ad(d) ? 64 : 1,
            reader: (d) => bu
          },
          controller: (d) => ad(d.params) ? C_(d) : T_(d)
        }, P_ = {
          id: "monitor-string",
          type: "monitor",
          accept: (d, o) => {
            if (typeof d != "string") return null;
            const h = oe, g = ce(o, {
              lineCount: h.optional.number,
              multiline: h.optional.boolean
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => yu
          },
          controller: (d) => {
            var o;
            const h = d.value;
            return h.rawValue.length > 1 || "multiline" in d.params && d.params.multiline ? new Ol(d.document, {
              formatter: vl,
              lineCount: (o = d.params.lineCount) !== null && o !== void 0 ? o : Pr.monitor.defaultLineCount,
              value: h,
              viewProps: d.viewProps
            }) : new Fl(d.document, {
              formatter: vl,
              value: h,
              viewProps: d.viewProps
            });
          }
        };
        function L_(d, o) {
          var h;
          const g = d.accept(o.target.read(), o.params);
          if (f(g)) return null;
          const E = oe, N = {
            target: o.target,
            initialValue: g.initialValue,
            params: g.params
          }, V = d.binding.reader(N), de = d.binding.constraint ? d.binding.constraint(N) : void 0, Ue = re(V(g.initialValue), {
            constraint: de,
            equals: d.binding.equals
          }), Ge = new ng({
            reader: V,
            target: o.target,
            value: Ue,
            writer: d.binding.writer(N)
          }), lt = E.optional.boolean(o.params.disabled).value, ut = E.optional.boolean(o.params.hidden).value, Vi = d.controller({
            constraint: de,
            document: o.document,
            initialValue: g.initialValue,
            params: g.params,
            value: Ge.value,
            viewProps: Ve.create({
              disabled: lt,
              hidden: ut
            })
          });
          return new nt(o.document, {
            binding: Ge,
            blade: qe(),
            props: W.fromObject({
              label: "label" in o.params ? (h = E.optional.string(o.params.label).value) !== null && h !== void 0 ? h : null : o.target.key
            }),
            valueController: Vi
          });
        }
        function R_(d, o) {
          return o === 0 ? new eg() : new tg(d, o ?? Pr.monitor.defaultInterval);
        }
        function I_(d, o) {
          var h, g, E;
          const N = oe, V = d.accept(o.target.read(), o.params);
          if (f(V)) return null;
          const de = {
            target: o.target,
            initialValue: V.initialValue,
            params: V.params
          }, Ue = d.binding.reader(de), Ge = (g = (h = N.optional.number(o.params.bufferSize).value) !== null && h !== void 0 ? h : d.binding.defaultBufferSize && d.binding.defaultBufferSize(V.params)) !== null && g !== void 0 ? g : 1, lt = N.optional.number(o.params.interval).value, ut = new og({
            reader: Ue,
            target: o.target,
            ticker: R_(o.document, lt),
            value: ig(Ge)
          }), Vi = N.optional.boolean(o.params.disabled).value, Lr = N.optional.boolean(o.params.hidden).value, Rr = d.controller({
            document: o.document,
            params: V.params,
            value: ut.value,
            viewProps: Ve.create({
              disabled: Vi,
              hidden: Lr
            })
          });
          return new Tt(o.document, {
            binding: ut,
            blade: qe(),
            props: W.fromObject({
              label: "label" in o.params ? (E = N.optional.string(o.params.label).value) !== null && E !== void 0 ? E : null : o.target.key
            }),
            valueController: Rr
          });
        }
        class D_ {
          constructor() {
            this.pluginsMap_ = {
              blades: [],
              inputs: [],
              monitors: []
            };
          }
          getAll() {
            return [
              ...this.pluginsMap_.blades,
              ...this.pluginsMap_.inputs,
              ...this.pluginsMap_.monitors
            ];
          }
          register(o) {
            o.type === "blade" ? this.pluginsMap_.blades.unshift(o) : o.type === "input" ? this.pluginsMap_.inputs.unshift(o) : o.type === "monitor" && this.pluginsMap_.monitors.unshift(o);
          }
          createInput(o, h, g) {
            const E = h.read();
            if (f(E)) throw new _({
              context: {
                key: h.key
              },
              type: "nomatchingcontroller"
            });
            const N = this.pluginsMap_.inputs.reduce((V, de) => V ?? L_(de, {
              document: o,
              target: h,
              params: g
            }), null);
            if (N) return N;
            throw new _({
              context: {
                key: h.key
              },
              type: "nomatchingcontroller"
            });
          }
          createMonitor(o, h, g) {
            const E = this.pluginsMap_.monitors.reduce((N, V) => N ?? I_(V, {
              document: o,
              params: g,
              target: h
            }), null);
            if (E) return E;
            throw new _({
              context: {
                key: h.key
              },
              type: "nomatchingcontroller"
            });
          }
          createBlade(o, h) {
            const g = this.pluginsMap_.blades.reduce((E, N) => E ?? Qm(N, {
              document: o,
              params: h
            }), null);
            if (!g) throw new _({
              type: "nomatchingview",
              context: {
                params: h
              }
            });
            return g;
          }
          createBladeApi(o) {
            if (o instanceof nt) return new bn(o);
            if (o instanceof Tt) return new an(o);
            if (o instanceof Ze) return new vs(o, this);
            const h = this.pluginsMap_.blades.reduce((g, E) => g ?? E.api({
              controller: o,
              pool: this
            }), null);
            if (!h) throw _.shouldNeverHappen();
            return h;
          }
        }
        function k_() {
          const d = new D_();
          return [
            z_,
            p_,
            __,
            b_,
            r_,
            e_,
            Qv,
            Yv,
            Kg,
            M_,
            P_,
            A_,
            Ie,
            Jt,
            It,
            cu
          ].forEach((o) => {
            d.register(o);
          }), d;
        }
        function N_(d) {
          return ui.isObject(d) ? new ui(d.x, d.y) : new ui();
        }
        function O_(d, o) {
          d.writeProperty("x", o.x), d.writeProperty("y", o.y);
        }
        function Xn(d, o) {
          if (!d) return;
          const h = [], g = Qu(d, o);
          g && h.push(g);
          const E = ed(d);
          return E && h.push(E), new xr(h);
        }
        function F_(d, o) {
          return new hi({
            assembly: td,
            components: [
              Xn("x" in d ? d.x : void 0, o.x),
              Xn("y" in d ? d.y : void 0, o.y)
            ]
          });
        }
        function ld(d, o) {
          const [h, g] = d ? i_(d) : [];
          if (!f(h) || !f(g)) return Math.max(Math.abs(h ?? 0), Math.abs(g ?? 0));
          const E = ws(d);
          return Math.max(Math.abs(E) * 10, Math.abs(o) * 10);
        }
        function B_(d, o) {
          const h = o instanceof hi ? o.components[0] : void 0, g = o instanceof hi ? o.components[1] : void 0, E = ld(h, d.x), N = ld(g, d.y);
          return Math.max(E, N);
        }
        function cd(d, o) {
          return {
            baseStep: ws(o),
            constraint: o,
            textProps: W.fromObject({
              draggingScale: Ms(o, d),
              formatter: qt(Uo(o, d))
            })
          };
        }
        function U_(d) {
          if (!("y" in d)) return false;
          const o = d.y;
          return o && "inverted" in o ? !!o.inverted : false;
        }
        const z_ = {
          id: "input-point2d",
          type: "input",
          accept: (d, o) => {
            if (!ui.isObject(d)) return null;
            const h = oe, g = ce(o, {
              expanded: h.optional.boolean,
              picker: h.optional.custom(Eu),
              x: h.optional.custom(li),
              y: h.optional.object({
                inverted: h.optional.boolean,
                max: h.optional.number,
                min: h.optional.number,
                step: h.optional.number
              })
            });
            return g ? {
              initialValue: d,
              params: g
            } : null;
          },
          binding: {
            reader: (d) => N_,
            constraint: (d) => F_(d.params, d.initialValue),
            equals: ui.equals,
            writer: (d) => O_
          },
          controller: (d) => {
            const o = d.document, h = d.value, g = d.constraint;
            if (!(g instanceof hi)) throw _.shouldNeverHappen();
            const E = "expanded" in d.params ? d.params.expanded : void 0, N = "picker" in d.params ? d.params.picker : void 0;
            return new c_(o, {
              axes: [
                cd(h.rawValue.x, g.components[0]),
                cd(h.rawValue.y, g.components[1])
              ],
              expanded: E ?? false,
              invertsY: U_(d.params),
              maxValue: B_(h.rawValue, g),
              parser: Wn,
              pickerLayout: N ?? "popup",
              value: h,
              viewProps: d.viewProps
            });
          }
        };
        class hd extends i {
          constructor(o) {
            super(o), this.emitter_ = new S(), this.controller_.valueController.value.emitter.on("change", (h) => {
              this.emitter_.emit("change", {
                event: new r(this, h.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          get options() {
            return this.controller_.valueController.props.get("options");
          }
          set options(o) {
            this.controller_.valueController.props.set("options", o);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(o) {
            this.controller_.valueController.value.rawValue = o;
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
        }
        class ud extends i {
          constructor(o) {
            super(o), this.emitter_ = new S(), this.controller_.valueController.value.emitter.on("change", (h) => {
              this.emitter_.emit("change", {
                event: new r(this, h.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          get maxValue() {
            return this.controller_.valueController.sliderController.props.get("maxValue");
          }
          set maxValue(o) {
            this.controller_.valueController.sliderController.props.set("maxValue", o);
          }
          get minValue() {
            return this.controller_.valueController.sliderController.props.get("minValue");
          }
          set minValue(o) {
            this.controller_.valueController.sliderController.props.set("minValue", o);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(o) {
            this.controller_.valueController.value.rawValue = o;
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
        }
        class dd extends i {
          constructor(o) {
            super(o), this.emitter_ = new S(), this.controller_.valueController.value.emitter.on("change", (h) => {
              this.emitter_.emit("change", {
                event: new r(this, h.rawValue)
              });
            });
          }
          get label() {
            return this.controller_.props.get("label");
          }
          set label(o) {
            this.controller_.props.set("label", o);
          }
          get formatter() {
            return this.controller_.valueController.props.get("formatter");
          }
          set formatter(o) {
            this.controller_.valueController.props.set("formatter", o);
          }
          get value() {
            return this.controller_.valueController.value.rawValue;
          }
          set value(o) {
            this.controller_.valueController.value.rawValue = o;
          }
          on(o, h) {
            const g = h.bind(this);
            return this.emitter_.on(o, (E) => {
              g(E.event);
            }), this;
          }
        }
        const V_ = /* @__PURE__ */ (function() {
          return {
            id: "list",
            type: "blade",
            accept(d) {
              const o = oe, h = ce(d, {
                options: o.required.custom(Bo),
                value: o.required.raw,
                view: o.required.constant("list"),
                label: o.optional.string
              });
              return h ? {
                params: h
              } : null;
            },
            controller(d) {
              const o = new br(Tu(d.params.options)), h = re(d.params.value, {
                constraint: o
              }), g = new yr(d.document, {
                props: new W({
                  options: o.values.value("options")
                }),
                value: h,
                viewProps: d.viewProps
              });
              return new jt(d.document, {
                blade: d.blade,
                props: W.fromObject({
                  label: d.params.label
                }),
                valueController: g
              });
            },
            api(d) {
              return !(d.controller instanceof jt) || !(d.controller.valueController instanceof yr) ? null : new hd(d.controller);
            }
          };
        })();
        function G_(d) {
          return d.reduce((o, h) => Object.assign(o, {
            [h.presetKey]: h.read()
          }), {});
        }
        function H_(d, o) {
          d.forEach((h) => {
            const g = o[h.target.presetKey];
            g !== void 0 && h.writer(h.target, h.reader(g));
          });
        }
        class W_ extends I {
          constructor(o, h) {
            super(o, h);
          }
          get element() {
            return this.controller_.view.element;
          }
          importPreset(o) {
            const h = this.controller_.rackController.rack.find(nt).map((g) => g.binding);
            H_(h, o), this.refresh();
          }
          exportPreset() {
            const o = this.controller_.rackController.rack.find(nt).map((h) => h.binding.target);
            return G_(o);
          }
          refresh() {
            this.controller_.rackController.rack.find(nt).forEach((o) => {
              o.binding.read();
            }), this.controller_.rackController.rack.find(Tt).forEach((o) => {
              o.binding.read();
            });
          }
        }
        class q_ extends vt {
          constructor(o, h) {
            super(o, {
              expanded: h.expanded,
              blade: h.blade,
              props: h.props,
              root: true,
              viewProps: h.viewProps
            });
          }
        }
        const X_ = {
          id: "slider",
          type: "blade",
          accept(d) {
            const o = oe, h = ce(d, {
              max: o.required.number,
              min: o.required.number,
              view: o.required.constant("slider"),
              format: o.optional.function,
              label: o.optional.string,
              value: o.optional.number
            });
            return h ? {
              params: h
            } : null;
          },
          controller(d) {
            var o, h;
            const g = (o = d.params.value) !== null && o !== void 0 ? o : 0, E = new ys({
              max: d.params.max,
              min: d.params.min
            }), N = new yl(d.document, {
              baseStep: 1,
              parser: Wn,
              sliderProps: new W({
                maxValue: E.values.value("max"),
                minValue: E.values.value("min")
              }),
              textProps: W.fromObject({
                draggingScale: Ms(void 0, g),
                formatter: (h = d.params.format) !== null && h !== void 0 ? h : Fg
              }),
              value: re(g, {
                constraint: E
              }),
              viewProps: d.viewProps
            });
            return new jt(d.document, {
              blade: d.blade,
              props: W.fromObject({
                label: d.params.label
              }),
              valueController: N
            });
          },
          api(d) {
            return !(d.controller instanceof jt) || !(d.controller.valueController instanceof yl) ? null : new ud(d.controller);
          }
        }, j_ = /* @__PURE__ */ (function() {
          return {
            id: "text",
            type: "blade",
            accept(d) {
              const o = oe, h = ce(d, {
                parse: o.required.function,
                value: o.required.raw,
                view: o.required.constant("text"),
                format: o.optional.function,
                label: o.optional.string
              });
              return h ? {
                params: h
              } : null;
            },
            controller(d) {
              var o;
              const h = new Oo(d.document, {
                parser: d.params.parse,
                props: W.fromObject({
                  formatter: (o = d.params.format) !== null && o !== void 0 ? o : ((g) => String(g))
                }),
                value: re(d.params.value),
                viewProps: d.viewProps
              });
              return new jt(d.document, {
                blade: d.blade,
                props: W.fromObject({
                  label: d.params.label
                }),
                valueController: h
              });
            },
            api(d) {
              return !(d.controller instanceof jt) || !(d.controller.valueController instanceof Oo) ? null : new dd(d.controller);
            }
          };
        })();
        function K_(d) {
          const o = d.createElement("div");
          return o.classList.add(M("dfw")()), d.body && d.body.appendChild(o), o;
        }
        function pd(d, o, h) {
          if (d.querySelector(`style[data-tp-style=${o}]`)) return;
          const g = d.createElement("style");
          g.dataset.tpStyle = o, g.textContent = h, d.head.appendChild(g);
        }
        class Y_ extends W_ {
          constructor(o) {
            var h, g;
            const E = o ?? {}, N = (h = E.document) !== null && h !== void 0 ? h : it(), V = k_(), de = new q_(N, {
              expanded: E.expanded,
              blade: qe(),
              props: W.fromObject({
                title: E.title
              }),
              viewProps: Ve.create()
            });
            super(de, V), this.pool_ = V, this.containerElem_ = (g = E.container) !== null && g !== void 0 ? g : K_(N), this.containerElem_.appendChild(this.element), this.doc_ = N, this.usesDefaultWrapper_ = !E.container, this.setUpDefaultPlugins_();
          }
          get document() {
            if (!this.doc_) throw _.alreadyDisposed();
            return this.doc_;
          }
          dispose() {
            const o = this.containerElem_;
            if (!o) throw _.alreadyDisposed();
            if (this.usesDefaultWrapper_) {
              const h = o.parentElement;
              h && h.removeChild(o);
            }
            this.containerElem_ = null, this.doc_ = null, super.dispose();
          }
          registerPlugin(o) {
            ("plugin" in o ? [
              o.plugin
            ] : "plugins" in o ? o.plugins : []).forEach((g) => {
              this.pool_.register(g), this.embedPluginStyle_(g);
            });
          }
          embedPluginStyle_(o) {
            o.css && pd(this.document, `plugin-${o.id}`, o.css);
          }
          setUpDefaultPlugins_() {
            pd(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'), this.pool_.getAll().forEach((o) => {
              this.embedPluginStyle_(o);
            }), this.registerPlugin({
              plugins: [
                X_,
                V_,
                cu,
                j_
              ]
            });
          }
        }
        const $_ = new n("3.1.10");
        t.BladeApi = i, t.ButtonApi = w, t.FolderApi = I, t.InputBindingApi = bn, t.ListApi = hd, t.MonitorBindingApi = an, t.Pane = Y_, t.SeparatorApi = Rn, t.SliderApi = ud, t.TabApi = In, t.TabPageApi = Gt, t.TextApi = dd, t.TpChangeEvent = r, t.VERSION = $_, Object.defineProperty(t, "__esModule", {
          value: true
        });
      }));
    })(Kr, Kr.exports)), Kr.exports;
  }
  nE();
  class iE {
    constructor() {
    }
  }
  const sE = "modulepreload", rE = function(l, e) {
    return new URL(l, e).href;
  }, Bp = {}, Ua = function(e, t, n) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
      let r = function(p) {
        return Promise.all(p.map((f) => Promise.resolve(f).then((m) => ({
          status: "fulfilled",
          value: m
        }), (m) => ({
          status: "rejected",
          reason: m
        }))));
      };
      const a = document.getElementsByTagName("link"), c = document.querySelector("meta[property=csp-nonce]"), u = (c == null ? void 0 : c.nonce) || (c == null ? void 0 : c.getAttribute("nonce"));
      i = r(t.map((p) => {
        if (p = rE(p, n), p in Bp) return;
        Bp[p] = true;
        const f = p.endsWith(".css"), m = f ? '[rel="stylesheet"]' : "";
        if (!!n) for (let _ = a.length - 1; _ >= 0; _--) {
          const x = a[_];
          if (x.href === p && (!f || x.rel === "stylesheet")) return;
        }
        else if (document.querySelector(`link[href="${p}"]${m}`)) return;
        const b = document.createElement("link");
        if (b.rel = f ? "stylesheet" : sE, f || (b.as = "script"), b.crossOrigin = "", b.href = p, u && b.setAttribute("nonce", u), document.head.appendChild(b), f) return new Promise((_, x) => {
          b.addEventListener("load", _), b.addEventListener("error", () => x(new Error(`Unable to preload CSS for ${p}`)));
        });
      }));
    }
    function s(r) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = r, window.dispatchEvent(a), !a.defaultPrevented) throw r;
    }
    return i.then((r) => {
      for (const a of r || []) a.status === "rejected" && s(a.reason);
      return e().catch(s);
    });
  };
  class oE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.meshMap = /* @__PURE__ */ new Map(), Ua(() => import("./rapier-BgbPAKZ2.js").then(async (m) => {
        await m.__tla;
        return m;
      }), [], import.meta.url).then((e) => {
        const t = {
          x: 0,
          y: -9.81,
          z: 0
        };
        this.world = new e.World(t), this.rapier = e, this.rapierLoaded = true, ho.setState({
          physicsReady: true
        });
      });
    }
    add(e, t, n, i = {}) {
      let s;
      switch (t) {
        case "dynamic":
          s = this.rapier.RigidBodyDesc.dynamic();
          break;
        case "fixed":
          s = this.rapier.RigidBodyDesc.fixed();
          break;
        case "kinematic":
          s = this.rapier.RigidBodyDesc.kinematicPositionBased();
          break;
      }
      this.rigidBody = this.world.createRigidBody(s), i.linearDamping !== void 0 && this.rigidBody.setLinearDamping(i.linearDamping), i.angularDamping !== void 0 && this.rigidBody.setAngularDamping(i.angularDamping);
      let r, a;
      switch (n) {
        case "cuboid":
          const p = this.computeCuboidDimensions(e);
          r = this.rapier.ColliderDesc.cuboid(p.x / 2, p.y / 2, p.z / 2), a = this.world.createCollider(r, this.rigidBody);
          break;
        case "ball":
          const f = this.computeBallDimensions(e);
          r = this.rapier.ColliderDesc.ball(f), a = this.world.createCollider(r, this.rigidBody);
          break;
        case "trimesh":
          const { scaledVertices: m, indices: v } = this.computeTrimeshDimensions(e);
          r = this.rapier.ColliderDesc.trimesh(m, v), a = this.world.createCollider(r, this.rigidBody);
          break;
      }
      a && (i.sensor && a.setSensor(true), i.restitution !== void 0 && a.setRestitution(i.restitution), i.friction !== void 0 && a.setFriction(i.friction));
      const c = e.getWorldPosition(new P()), u = e.getWorldQuaternion(new xt());
      return this.rigidBody.setTranslation(c), this.rigidBody.setRotation(u), this.meshMap.set(e, this.rigidBody), this.rigidBody;
    }
    computeCuboidDimensions(e) {
      e.geometry.computeBoundingBox();
      const t = e.geometry.boundingBox.getSize(new P()), n = e.getWorldScale(new P());
      return t.multiply(n), t;
    }
    computeBallDimensions(e) {
      e.geometry.computeBoundingSphere();
      const t = e.geometry.boundingSphere.radius, n = e.getWorldScale(new P()), i = Math.max(n.x, n.y, n.z);
      return t * i;
    }
    computeTrimeshDimensions(e) {
      var _a2;
      const t = (_a2 = e.geometry.attributes) == null ? void 0 : _a2.position;
      if (!t) return {
        scaledVertices: [],
        indices: []
      };
      const n = t.array;
      let i;
      if (e.geometry.index && e.geometry.index.array) i = e.geometry.index.array;
      else {
        const a = t.count;
        if (i = new (n.constructor === Float32Array ? Uint32Array : Array)(a), i instanceof Uint32Array) for (let c = 0; c < a; c++) i[c] = c;
        else i = Array.from({
          length: a
        }, (c, u) => u);
      }
      const s = e.getWorldScale(new P());
      return {
        scaledVertices: n.map((a, c) => a * s.getComponent(c % 3)),
        indices: i
      };
    }
    loop() {
      this.rapierLoaded && (this.world.step(), this.meshMap.forEach((e, t) => {
        const n = new P().copy(e.translation()), i = new xt().copy(e.rotation());
        n.applyMatrix4(new ze().copy(t.parent.matrixWorld).invert());
        const s = new ze().extractRotation(t.parent.matrixWorld).invert(), r = new xt().setFromRotationMatrix(s);
        i.premultiply(r), t.position.copy(n), t.quaternion.copy(i);
      }));
    }
  }
  const aE = [
    {
      id: "avatar",
      path: "/models/avatar.glb",
      type: "model"
    },
    {
      id: "environment",
      path: "/models/new_env.glb",
      type: "model"
    }
  ], dl = ul((l) => ({
    assetsToLoad: aE,
    loadedAssets: {},
    addLoadedAsset: (e, t) => l((n) => ({
      loadedAssets: {
        ...n.loadedAssets,
        [t]: e
      }
    }))
  }));
  class lE {
    constructor() {
      this.modal = document.getElementById("myModal"), this.close = document.getElementsByClassName("close")[0], this.close.onclick = () => {
        this.closeModal();
      };
    }
    openModal(e, t) {
      document.getElementById("modalTitle").innerHTML = e, document.getElementById("modalDescription").innerHTML = t, this.modal.style.display = "block", this.modal.classList.remove("fadeOut"), this.modal.classList.add("fadeIn");
    }
    closeModal() {
      this.modal.classList.remove("fadeIn"), this.modal.classList.add("fadeOut"), setTimeout(() => {
        this.modal.style.display = "none";
      }, 600);
    }
  }
  class bc {
    constructor(e, t) {
      this.app = new Ln(), this.portalMesh = e, this.modalInfo = t, this.modalManager = new lE(), this.portalNearMaterial = new $t({
        color: 16777215,
        transparent: true,
        opacity: 0.8
      }), this.portalFarMaterial = new $t({
        color: 65535,
        transparent: true,
        opacity: 0.8
      }), this.portalMesh.material = this.portalFarMaterial, this.prevIsNear = false;
    }
    loop() {
      if (this.character = this.app.world.character.instance, this.character) {
        const e = new P();
        this.portalMesh.getWorldPosition(e), this.character.position.distanceTo(e) < 1.5 ? (this.prevIsNear || (this.modalManager.openModal(this.modalInfo.title, this.modalInfo.description), this.portalMesh.material = this.portalNearMaterial), this.prevIsNear = true) : (this.prevIsNear && (this.modalManager.closeModal(), this.portalMesh.material = this.portalFarMaterial), this.prevIsNear = false);
      }
    }
  }
  class cE {
    constructor() {
      this.modalContents = {
        intro: {
          title: "Introduction",
          description: "Nice to meet you! I am Gustavo Kang Shim, a 4th year CS student at TRU."
        },
        projects: {
          title: "Projects",
          description: `
            <div class="projects-grid">
              <article class="project-card">
                <div class="project-body">
                  <h3>IoT Workplace Safety & Security (Cloud)</h3>
                  <p>Cloud-based monitoring platform using AWS (IoT Core, Lambda, Analytics) with a secure user web UI.</p>
                  <div class="project-meta">
                    <span class="project-tag">AWS</span>
                    <span class="project-tag">IoT</span>
                    <span class="project-tag">Serverless</span>
                  </div>
                  <div class="project-actions">
                    <a href="https://github.com/ZionC27/IoT-Workplace-Safety-and-Security--Monitoring-with-Cloud-Processing" target="_blank" rel="noreferrer noopener">View</a>
                  </div>
                </div>
              </article>
              <article class="project-card">
                <div class="project-body">
                  <h3>Dungeoneer</h3>
                  <p>Team-built dungeon crawler featuring procedural map generation and cohesive multi-discipline collaboration.</p>
                  <div class="project-meta">
                    <span class="project-tag">Game Dev</span>
                    <span class="project-tag">PCG</span>
                    <span class="project-tag">Teamwork</span>
                  </div>
                  <div class="project-actions">
                    <a href="https://darthpackman.itch.io/dungeoneer" target="_blank" rel="noreferrer noopener">View</a>
                  </div>
                </div>
              </article>
              <article class="project-card">
                <div class="project-body">
                  <h3>Computer Science Club\u2019s Website</h3>
                  <p>Developed and implemented market-level features for the Computer Science Club\u2019s website improving user engagement</p>
                  <div class="project-meta">
                    <span class="project-tag">TailwindCSS</span>
                    <span class="project-tag">Web Dev</span>
                    <span class="project-tag">NodeJS</span>
                  </div>
                  <div class="project-actions">
                    <a href="https://trucsclub.github.io/" target="_blank" rel="noreferrer noopener">View</a>
                  </div>
                </div>
              </article>
            </div>
          `
        },
        contactMe: {
          title: "Contact Me",
          description: `
            <div class="contact-grid">
              <a class="contact-card" href="https://github.com/shimuraii" target="_blank" rel="noreferrer noopener" aria-label="Open GitHub profile">
                <span class="contact-icon" aria-hidden="true">
                  <svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><path d="M12 .5a11.5 11.5 0 0 0-3.64 22.41c.58.11.79-.25.79-.55v-2.1c-3.2.7-3.88-1.37-3.88-1.37-.53-1.35-1.29-1.7-1.29-1.7-1.05-.72.08-.71.08-.71 1.16.08 1.77 1.2 1.77 1.2 1.03 1.76 2.7 1.25 3.35.96.1-.76.4-1.25.72-1.54-2.55-.29-5.24-1.28-5.24-5.71 0-1.26.45-2.28 1.2-3.08-.12-.29-.52-1.45.11-3.02 0 0 .98-.31 3.2 1.18a11.1 11.1 0 0 1 5.82 0c2.22-1.49 3.2-1.18 3.2-1.18.63 1.57.23 2.73.11 3.02.75.8 1.2 1.82 1.2 3.08 0 4.44-2.69 5.41-5.25 5.7.41.35.77 1.04.77 2.11v3.13c0 .31.21.67.8.55A11.5 11.5 0 0 0 12 .5Z"/></svg>
                </span>
                <span class="contact-text">
                  <span class="contact-label">GitHub</span>
                  <span class="contact-value">@shimuraii</span>
                </span>
              </a>
              <a class="contact-card" href="https://www.linkedin.com/in/gkangshim/" target="_blank" rel="noreferrer noopener" aria-label="Open LinkedIn profile">
                <span class="contact-icon" aria-hidden="true">
                  <svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><path d="M4.98 3.5C4.98 4.88 3.86 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1 4.98 2.12 4.98 3.5zM.5 8.5h4V24h-4V8.5zM8.5 8.5h3.83v2.11h.05c.53-1 1.83-2.05 3.78-2.05 4.04 0 4.79 2.66 4.79 6.12V24h-4v-6.76c0-1.61-.03-3.68-2.24-3.68-2.24 0-2.58 1.75-2.58 3.56V24h-4V8.5z"/></svg>
                </span>
                <span class="contact-text">
                  <span class="contact-label">LinkedIn</span>
                  <span class="contact-value">/in/gkangshim</span>
                </span>
              </a>
              <a class="contact-card" href="https://linktr.ee/gkangshim" target="_blank" rel="noreferrer noopener" aria-label="Open resume PDF">
                <span class="contact-icon" aria-hidden="true">
                  <svg viewBox="0 0 24 24" width="22" height="22" fill="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8Zm0 0v6h6"/><path d="M16 13H8m8 4H8M9 9h1" stroke="currentColor" stroke-width="1" stroke-linecap="round"/></svg>
                </span>
                <span class="contact-text">
                  <span class="contact-label">Resume</span>
                  <span class="contact-value">PDF</span>
                </span>
              </a>
            </div>
          `
        },
        aboutMe: {
          title: "About Me",
          description: `
            <div class="about-layout">
              <div class="about-portrait" aria-hidden="true">GKS</div>
              <div class="about-body">
                <p>
                  I\u2019m Gustavo Kang Shim \u2014 born and raised in Brazil with Korean roots. I\u2019m a 4th\u2011year Computer Science student at TRU, passionate about Web Development, Three.js, Software Development and bringing playful, interactive ideas to life. When I\u2019m not building, I\u2019m likely out going to the gym or exploring tech that blends design and engineering.
                </p>
                <ul class="about-list">
                  <li>Brazil \u2192 Canada journey; bilingual background</li>
                  <li>Enjoys Soccer, Gym, Rock Climbing, Volleyball, Videogames</li>
                  <li>Focus on polished Software Development</li>
                </ul>
              </div>
            </div>
          `
        },
        interests: {
          title: "Interests",
          description: "<ul><li>Gym</li> <li>Japanese culture</li> <li>ThreeJS</li> <li>Web Development</li><li>Software Development</li> <li>Computers</li> <li>Videogames</li> <li>Technology</li></ul>"
        }
      };
    }
    getModalInfo(e) {
      return this.modalContents[e];
    }
  }
  class hE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.physics = this.app.world.physics, this.pane = this.app.gui.pane, this.assetStore = dl.getState(), this.environment = this.assetStore.loadedAssets.environment, this.loadEnvironment(), this.addLights(), this.addPortals(), this.setupSoccer();
    }
    loadEnvironment() {
      const e = this.environment.scene;
      this.scene.add(e), e.position.set(-4.8, 0, -7.4), e.rotation.set(0, -0.6, 0), e.scale.setScalar(1.3);
      const t = [
        "trees",
        "terrain",
        "rocks",
        "stairs",
        "gates",
        "floor",
        "bushes"
      ], n = [
        "trees",
        "terrain",
        "rocks",
        "stairs",
        "gates",
        "bushes"
      ], i = [
        "floor",
        "terrain"
      ];
      for (const s of e.children) s.traverse((r) => {
        r.isMesh && (r.castShadow = n.some((c) => s.name.includes(c)), r.receiveShadow = i.some((c) => s.name.includes(c)), !/net|frame|goal|soccer/i.test(s.name) && t.some((c) => s.name.includes(c)) && this.physics.add(r, "fixed", "cuboid"));
      });
    }
    addLights() {
      const e = new tu(16777215, 0.5);
      this.scene.add(e), this.directionalLight = new ll(16777215, 0.5), this.directionalLight.position.set(1, 1, 1), this.directionalLight.castShadow = true, this.directionalLight.shadow.camera.top = 30, this.directionalLight.shadow.camera.right = 30, this.directionalLight.shadow.camera.left = -30, this.directionalLight.shadow.camera.bottom = -30, this.directionalLight.shadow.bias = -2e-3, this.directionalLight.shadow.normalBias = 0.072, this.scene.add(this.directionalLight);
    }
    addPortals() {
      const e = this.environment.scene.getObjectByName("portals"), t = this.environment.scene.getObjectByName("portals001"), n = this.environment.scene.getObjectByName("portals002"), i = new cE();
      this.portal1 = new bc(e, i.getModalInfo("aboutMe")), this.portal2 = new bc(t, i.getModalInfo("projects")), this.portal3 = new bc(n, i.getModalInfo("contactMe"));
    }
    setupSoccer() {
      const e = this.environment.scene, t = (m) => m.map((v) => e.getObjectByName(v)).find(Boolean), n = (m) => {
        if (!m) return null;
        if (m.isMesh) return m;
        let v = null;
        return m.traverse((b) => {
          !v && b.isMesh && (v = b);
        }), v;
      }, i = t([
        "soccer_ball",
        "Soccer_Ball",
        "SoccerBall",
        "ball"
      ]), s = [];
      i && i.traverse((m) => {
        m.isMesh && s.push(m);
      });
      let r = null, a = -1 / 0;
      for (const m of s) {
        if (!m.geometry) continue;
        m.geometry.computeBoundingSphere();
        const v = m.geometry.boundingSphere ? m.geometry.boundingSphere.radius : 0;
        v > a && (a = v, r = m);
      }
      const c = r || n(i);
      if (c) {
        const m = s.filter((b) => b !== c);
        c.updateWorldMatrix(true, false);
        const v = new ze().copy(c.matrixWorld).invert();
        for (const b of m) {
          b.updateWorldMatrix(true, false);
          const _ = new ze().multiplyMatrices(v, b.matrixWorld), x = new P(), w = new xt(), S = new P();
          _.decompose(x, w, S), b.parent && b.parent.remove(b), c.add(b), b.position.copy(x), b.quaternion.copy(w), b.scale.copy(S);
        }
        c.visible = true, this.physics.add(c, "dynamic", "ball", {
          restitution: 0.5,
          friction: 0.7,
          linearDamping: 0.2,
          angularDamping: 0.1
        }), this.soccerBall = c;
      }
      const u = t([
        "Net",
        "net"
      ]), p = t([
        "Frame",
        "frame",
        "GoalFrame"
      ]);
      if (p) {
        const m = [];
        if (p.traverse((v) => {
          v.isMesh && m.push(v);
        }), m.length === 0) {
          const v = n(p);
          v && m.push(v);
        }
        for (const v of m) this.physics.add(v, "fixed", "trimesh");
      }
      if (u) {
        const m = [];
        if (u.traverse((v) => {
          v.isMesh && m.push(v);
        }), m.length === 0) {
          const v = n(u);
          v && m.push(v);
        }
        for (const v of m) this.physics.add(v, "fixed", "trimesh", {
          sensor: true
        });
      }
      const f = u || p;
      if (f) {
        const m = new Bn().setFromObject(f), v = m.getSize(new P()), b = m.getCenter(new P()), _ = new P(v.x * 0.9, v.y * 0.95, Math.max(0.2, v.z * 0.5)), x = b.clone(), w = new Vn(_.x, _.y, _.z), S = new $t({
          visible: false
        }), y = new kt(w, S);
        y.position.copy(x), this.scene.add(y), this.goalSensorMesh = y, this.physics.add(y, "fixed", "cuboid", {
          sensor: true
        });
      }
    }
    loop() {
      if (this.portal1.loop(), this.portal2.loop(), this.portal3.loop(), this.soccerBall && this.goalSensorMesh) {
        const e = new P();
        this.soccerBall.getWorldPosition(e);
        const n = new Bn().setFromObject(this.goalSensorMesh).containsPoint(e);
        n && !this._scoredAlready && (this._scoredAlready = true, console.log("GOAL!")), !n && this._scoredAlready && (this._scoredAlready = false);
      }
    }
  }
  class uE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.assetStore = dl.getState(), this.avatar = this.assetStore.loadedAssets.avatar, this.instantiateCharacter();
    }
    instantiateCharacter() {
      const e = new Vn(0.6, 2, 0.6), t = new gr({
        color: 65280,
        wireframe: true,
        visible: false
      });
      this.instance = new kt(e, t), this.instance.position.set(0, 4, 0), this.scene.add(this.instance);
      const n = this.avatar.scene;
      n.rotation.y = Math.PI, n.position.y = -1, this.instance.add(n);
    }
  }
  class dE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.physics = this.app.world.physics, this.character = this.app.world.character.instance, We.subscribe((e) => {
        this.forward = e.forward, this.backward = e.backward, this.left = e.left, this.right = e.right;
      }), this.instantiateController();
    }
    instantiateController() {
      this.rigidBodyType = this.physics.rapier.RigidBodyDesc.kinematicPositionBased(), this.rigidBody = this.physics.world.createRigidBody(this.rigidBodyType), this.colliderType = this.physics.rapier.ColliderDesc.cuboid(0.3, 1, 0.3), this.collider = this.physics.world.createCollider(this.colliderType, this.rigidBody);
      const e = this.character.getWorldPosition(new P()), t = this.character.getWorldQuaternion(new xt());
      this.rigidBody.setTranslation(e), this.rigidBody.setRotation(t), this.characterController = this.physics.world.createCharacterController(0.01), this.characterController.setApplyImpulsesToDynamicBodies(true), this.characterController.enableAutostep(1, 0.3, false), this.characterController.enableSnapToGround(1);
    }
    loop(e = 0) {
      const t = Math.max(0, Math.min(e || 0, 0.1)), n = 4, i = 1 - Math.exp(-6 * t), s = new P();
      if (this.forward && (s.z -= 1), this.backward && (s.z += 1), this.left && (s.x -= 1), this.right && (s.x += 1), s.length() !== 0) {
        const a = Math.atan2(s.x, s.z) + Math.PI, c = new xt().setFromAxisAngle(new P(0, 1, 0), a);
        this.character.quaternion.slerp(c, i);
      }
      s.lengthSq() > 0 && s.normalize().multiplyScalar(n * t), s.y = -3.5 * t, this.characterController.computeColliderMovement(this.collider, s);
      const r = new P().copy(this.rigidBody.translation()).add(this.characterController.computedMovement());
      this.rigidBody.setNextKinematicTranslation(r), this.character.position.lerp(this.rigidBody.translation(), i);
    }
  }
  class pE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.avatar = this.app.world.character.avatar, We.subscribe((e) => this.onInput(e)), this.instantiatedAnimations();
    }
    instantiatedAnimations() {
      this.avatar.animations[0], this.mixer = new Wm(this.avatar.scene), this.animations = /* @__PURE__ */ new Map(), this.avatar.animations.forEach((e) => {
        this.animations.set(e.name, this.mixer.clipAction(e));
      }), this.currentAction = this.animations.get("idle"), this.currentAction.play();
    }
    playAnimation(e) {
      if (this.currentAction === this.animations.get(e)) return;
      const t = this.animations.get(e);
      t.reset(), t.play(), t.crossFadeFrom(this.currentAction, 0.2), this.currentAction = t;
    }
    onInput(e) {
      e.forward || e.backward || e.left || e.right ? this.playAnimation("run") : this.playAnimation("idle");
    }
    loop(e) {
      this.mixer.update(e);
    }
  }
  class fE {
    constructor() {
      this.app = new Ln(), this.scene = this.app.scene, this.physics = new oE();
      const e = ho.subscribe((t) => {
        t.physicsReady && t.assetsReady && (this.environment = new hE(), this.character = new uE(), this.characterController = new dE(), this.animationController = new pE(), e());
      });
      this.loop();
    }
    loop(e, t) {
      this.physics.loop(), this.environment && this.environment.loop(), this.characterController && this.characterController.loop(e), this.animationController && this.animationController.loop(e);
    }
  }
  class mE {
    constructor() {
      const { setState: e } = au;
      window.addEventListener("resize", () => {
        e({
          width: window.innerWidth,
          height: window.innerHeight,
          pixelRatio: Math.min(window.devicePixelRatio, 2)
        });
      });
    }
  }
  function Up(l, e) {
    if (e === Gf) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), l;
    if (e === Ga || e === Mh) {
      let t = l.getIndex();
      if (t === null) {
        const r = [], a = l.getAttribute("position");
        if (a !== void 0) {
          for (let c = 0; c < a.count; c++) r.push(c);
          l.setIndex(r), t = l.getIndex();
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), l;
      }
      const n = t.count - 2, i = [];
      if (e === Ga) for (let r = 1; r <= n; r++) i.push(t.getX(0)), i.push(t.getX(r)), i.push(t.getX(r + 1));
      else for (let r = 0; r < n; r++) r % 2 === 0 ? (i.push(t.getX(r)), i.push(t.getX(r + 1)), i.push(t.getX(r + 2))) : (i.push(t.getX(r + 2)), i.push(t.getX(r + 1)), i.push(t.getX(r)));
      i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
      const s = l.clone();
      return s.setIndex(i), s.clearGroups(), s;
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), l;
  }
  class Xm extends sn {
    constructor(e) {
      super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
        return new bE(t);
      }), this.register(function(t) {
        return new CE(t);
      }), this.register(function(t) {
        return new AE(t);
      }), this.register(function(t) {
        return new wE(t);
      }), this.register(function(t) {
        return new ME(t);
      }), this.register(function(t) {
        return new SE(t);
      }), this.register(function(t) {
        return new EE(t);
      }), this.register(function(t) {
        return new xE(t);
      }), this.register(function(t) {
        return new TE(t);
      }), this.register(function(t) {
        return new yE(t);
      }), this.register(function(t) {
        return new vE(t);
      }), this.register(function(t) {
        return new PE(t);
      }), this.register(function(t) {
        return new LE(t);
      });
    }
    load(e, t, n, i) {
      const s = this;
      let r;
      this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = cr.extractUrlBase(e), this.manager.itemStart(e);
      const a = function(u) {
        i ? i(u) : console.error(u), s.manager.itemError(e), s.manager.itemEnd(e);
      }, c = new pn(this.manager);
      c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(u) {
        try {
          s.parse(u, r, function(p) {
            t(p), s.manager.itemEnd(e);
          }, a);
        } catch (p) {
          a(p);
        }
      }, n, a);
    }
    setDRACOLoader(e) {
      return this.dracoLoader = e, this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(e) {
      return this.ktx2Loader = e, this;
    }
    setMeshoptDecoder(e) {
      return this.meshoptDecoder = e, this;
    }
    register(e) {
      return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
    }
    unregister(e) {
      return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
    }
    parse(e, t, n, i) {
      let s;
      const r = {}, a = {}, c = new TextDecoder();
      if (typeof e == "string") s = JSON.parse(e);
      else if (e instanceof ArrayBuffer) if (c.decode(new Uint8Array(e, 0, 4)) === jm) {
        try {
          r[ot.KHR_BINARY_GLTF] = new RE(e);
        } catch (f) {
          i && i(f);
          return;
        }
        s = JSON.parse(r[ot.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(c.decode(e));
      else s = e;
      if (s.asset === void 0 || s.asset.version[0] < 2) {
        i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      const u = new WE(s, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      u.fileLoader.setRequestHeader(this.requestHeader);
      for (let p = 0; p < this.pluginCallbacks.length; p++) {
        const f = this.pluginCallbacks[p](u);
        a[f.name] = f, r[f.name] = true;
      }
      if (s.extensionsUsed) for (let p = 0; p < s.extensionsUsed.length; ++p) {
        const f = s.extensionsUsed[p], m = s.extensionsRequired || [];
        switch (f) {
          case ot.KHR_MATERIALS_UNLIT:
            r[f] = new _E();
            break;
          case ot.KHR_DRACO_MESH_COMPRESSION:
            r[f] = new IE(s, this.dracoLoader);
            break;
          case ot.KHR_TEXTURE_TRANSFORM:
            r[f] = new DE();
            break;
          case ot.KHR_MESH_QUANTIZATION:
            r[f] = new kE();
            break;
          default:
            m.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
      u.setExtensions(r), u.setPlugins(a), u.parse(n, i);
    }
    parseAsync(e, t) {
      const n = this;
      return new Promise(function(i, s) {
        n.parse(e, t, i, s);
      });
    }
  }
  function gE() {
    let l = {};
    return {
      get: function(e) {
        return l[e];
      },
      add: function(e, t) {
        l[e] = t;
      },
      remove: function(e) {
        delete l[e];
      },
      removeAll: function() {
        l = {};
      }
    };
  }
  const ot = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
  };
  class vE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_LIGHTS_PUNCTUAL, this.cache = {
        refs: {},
        uses: {}
      };
    }
    _markDefs() {
      const e = this.parser, t = this.parser.json.nodes || [];
      for (let n = 0, i = t.length; n < i; n++) {
        const s = t[n];
        s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      const t = this.parser, n = "light:" + e;
      let i = t.cache.get(n);
      if (i) return i;
      const s = t.json, c = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
      let u;
      const p = new we(16777215);
      c.color !== void 0 && p.fromArray(c.color);
      const f = c.range !== void 0 ? c.range : 0;
      switch (c.type) {
        case "directional":
          u = new ll(p), u.target.position.set(0, 0, -1), u.add(u.target);
          break;
        case "point":
          u = new eu(p), u.distance = f;
          break;
        case "spot":
          u = new Qh(p), u.distance = f, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, u.angle = c.spot.outerConeAngle, u.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, u.target.position.set(0, 0, -1), u.add(u.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
      }
      return u.position.set(0, 0, 0), u.decay = 2, yi(u, c), c.intensity !== void 0 && (u.intensity = c.intensity), u.name = t.createUniqueName(c.name || "light_" + e), i = Promise.resolve(u), t.cache.add(n, i), i;
    }
    getDependency(e, t) {
      if (e === "light") return this._loadLight(t);
    }
    createNodeAttachment(e) {
      const t = this, n = this.parser, s = n.json.nodes[e], a = (s.extensions && s.extensions[this.name] || {}).light;
      return a === void 0 ? null : this._loadLight(a).then(function(c) {
        return n._getNodeRef(t.cache, a, c);
      });
    }
  }
  class _E {
    constructor() {
      this.name = ot.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return $t;
    }
    extendParams(e, t, n) {
      const i = [];
      e.color = new we(1, 1, 1), e.opacity = 1;
      const s = t.pbrMetallicRoughness;
      if (s) {
        if (Array.isArray(s.baseColorFactor)) {
          const r = s.baseColorFactor;
          e.color.fromArray(r), e.opacity = r[3];
        }
        s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, ct));
      }
      return Promise.all(i);
    }
  }
  class xE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_EMISSIVE_STRENGTH;
    }
    extendMaterialParams(e, t) {
      const i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = i.extensions[this.name].emissiveStrength;
      return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
    }
  }
  class bE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], r = i.extensions[this.name];
      if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
        const a = r.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new te(a, a);
      }
      return Promise.all(s);
    }
  }
  class yE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_IRIDESCENCE;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], r = i.extensions[this.name];
      return r.iridescenceFactor !== void 0 && (t.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (t.iridescenceIOR = r.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
        100,
        400
      ]), r.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(s);
    }
  }
  class wE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [];
      t.sheenColor = new we(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
      const r = i.extensions[this.name];
      return r.sheenColorFactor !== void 0 && t.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", r.sheenColorTexture, ct)), r.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(s);
    }
  }
  class ME {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], r = i.extensions[this.name];
      return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(s);
    }
  }
  class SE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], r = i.extensions[this.name];
      t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
      const a = r.attenuationColor || [
        1,
        1,
        1
      ];
      return t.attenuationColor = new we(a[0], a[1], a[2]), Promise.all(s);
    }
  }
  class EE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_IOR;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const i = this.parser.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = i.extensions[this.name];
      return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve();
    }
  }
  class TE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(e) {
      const n = this.parser.json.materials[e];
      return !n.extensions || !n.extensions[this.name] ? null : oi;
    }
    extendMaterialParams(e, t) {
      const n = this.parser, i = n.json.materials[e];
      if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
      const s = [], r = i.extensions[this.name];
      t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", r.specularTexture));
      const a = r.specularColorFactor || [
        1,
        1,
        1
      ];
      return t.specularColor = new we(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", r.specularColorTexture, ct)), Promise.all(s);
    }
  }
  class CE {
    constructor(e) {
      this.parser = e, this.name = ot.KHR_TEXTURE_BASISU;
    }
    loadTexture(e) {
      const t = this.parser, n = t.json, i = n.textures[e];
      if (!i.extensions || !i.extensions[this.name]) return null;
      const s = i.extensions[this.name], r = t.options.ktx2Loader;
      if (!r) {
        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        return null;
      }
      return t.loadTextureImage(e, s.source, r);
    }
  }
  class AE {
    constructor(e) {
      this.parser = e, this.name = ot.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(e) {
      const t = this.name, n = this.parser, i = n.json, s = i.textures[e];
      if (!s.extensions || !s.extensions[t]) return null;
      const r = s.extensions[t], a = i.images[r.source];
      let c = n.textureLoader;
      if (a.uri) {
        const u = n.options.manager.getHandler(a.uri);
        u !== null && (c = u);
      }
      return this.detectSupport().then(function(u) {
        if (u) return n.loadTextureImage(e, r.source, c);
        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        return n.loadTexture(e);
      });
    }
    detectSupport() {
      return this.isSupported || (this.isSupported = new Promise(function(e) {
        const t = new Image();
        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
          e(t.height === 1);
        };
      })), this.isSupported;
    }
  }
  class PE {
    constructor(e) {
      this.name = ot.EXT_MESHOPT_COMPRESSION, this.parser = e;
    }
    loadBufferView(e) {
      const t = this.parser.json, n = t.bufferViews[e];
      if (n.extensions && n.extensions[this.name]) {
        const i = n.extensions[this.name], s = this.parser.getDependency("buffer", i.buffer), r = this.parser.options.meshoptDecoder;
        if (!r || !r.supported) {
          if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          return null;
        }
        return s.then(function(a) {
          const c = i.byteOffset || 0, u = i.byteLength || 0, p = i.count, f = i.byteStride, m = new Uint8Array(a, c, u);
          return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(p, f, m, i.mode, i.filter).then(function(v) {
            return v.buffer;
          }) : r.ready.then(function() {
            const v = new ArrayBuffer(p * f);
            return r.decodeGltfBuffer(new Uint8Array(v), p, f, m, i.mode, i.filter), v;
          });
        });
      } else return null;
    }
  }
  class LE {
    constructor(e) {
      this.name = ot.EXT_MESH_GPU_INSTANCING, this.parser = e;
    }
    createNodeMesh(e) {
      const t = this.parser.json, n = t.nodes[e];
      if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
      const i = t.meshes[n.mesh];
      for (const u of i.primitives) if (u.mode !== vn.TRIANGLES && u.mode !== vn.TRIANGLE_STRIP && u.mode !== vn.TRIANGLE_FAN && u.mode !== void 0) return null;
      const r = n.extensions[this.name].attributes, a = [], c = {};
      for (const u in r) a.push(this.parser.getDependency("accessor", r[u]).then((p) => (c[u] = p, c[u])));
      return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((u) => {
        const p = u.pop(), f = p.isGroup ? p.children : [
          p
        ], m = u[0].count, v = [];
        for (const b of f) {
          const _ = new ze(), x = new P(), w = new xt(), S = new P(1, 1, 1), y = new Oh(b.geometry, b.material, m);
          for (let M = 0; M < m; M++) c.TRANSLATION && x.fromBufferAttribute(c.TRANSLATION, M), c.ROTATION && w.fromBufferAttribute(c.ROTATION, M), c.SCALE && S.fromBufferAttribute(c.SCALE, M), y.setMatrixAt(M, _.compose(x, w, S));
          for (const M in c) M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && b.geometry.setAttribute(M, c[M]);
          rt.prototype.copy.call(y, b), y.frustumCulled = false, this.parser.assignFinalMaterial(y), v.push(y);
        }
        return p.isGroup ? (p.clear(), p.add(...v), p) : v[0];
      }));
    }
  }
  const jm = "glTF", Wr = 12, zp = {
    JSON: 1313821514,
    BIN: 5130562
  };
  class RE {
    constructor(e) {
      this.name = ot.KHR_BINARY_GLTF, this.content = null, this.body = null;
      const t = new DataView(e, 0, Wr), n = new TextDecoder();
      if (this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, true),
        length: t.getUint32(8, true)
      }, this.header.magic !== jm) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const i = this.header.length - Wr, s = new DataView(e, Wr);
      let r = 0;
      for (; r < i; ) {
        const a = s.getUint32(r, true);
        r += 4;
        const c = s.getUint32(r, true);
        if (r += 4, c === zp.JSON) {
          const u = new Uint8Array(e, Wr + r, a);
          this.content = n.decode(u);
        } else if (c === zp.BIN) {
          const u = Wr + r;
          this.body = e.slice(u, u + a);
        }
        r += a;
      }
      if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class IE {
    constructor(e, t) {
      if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      this.name = ot.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      const n = this.json, i = this.dracoLoader, s = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, c = {}, u = {};
      for (const p in r) {
        const f = dh[p] || p.toLowerCase();
        a[f] = r[p];
      }
      for (const p in e.attributes) {
        const f = dh[p] || p.toLowerCase();
        if (r[p] !== void 0) {
          const m = n.accessors[e.attributes[p]], v = Qs[m.componentType];
          u[f] = v.name, c[f] = m.normalized === true;
        }
      }
      return t.getDependency("bufferView", s).then(function(p) {
        return new Promise(function(f) {
          i.decodeDracoFile(p, function(m) {
            for (const v in m.attributes) {
              const b = m.attributes[v], _ = c[v];
              _ !== void 0 && (b.normalized = _);
            }
            f(m);
          }, a, u);
        });
      });
    }
  }
  class DE {
    constructor() {
      this.name = ot.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return t.texCoord !== void 0 && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
    }
  }
  class kE {
    constructor() {
      this.name = ot.KHR_MESH_QUANTIZATION;
    }
  }
  class Km extends vr {
    constructor(e, t, n, i) {
      super(e, t, n, i);
    }
    copySampleValue_(e) {
      const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, s = e * i * 3 + i;
      for (let r = 0; r !== i; r++) t[r] = n[s + r];
      return t;
    }
    interpolate_(e, t, n, i) {
      const s = this.resultBuffer, r = this.sampleValues, a = this.valueSize, c = a * 2, u = a * 3, p = i - t, f = (n - t) / p, m = f * f, v = m * f, b = e * u, _ = b - u, x = -2 * v + 3 * m, w = v - m, S = 1 - x, y = w - m + f;
      for (let M = 0; M !== a; M++) {
        const C = r[_ + M + a], R = r[_ + M + c] * p, k = r[b + M + a], T = r[b + M] * p;
        s[M] = S * C + y * R + x * k + w * T;
      }
      return s;
    }
  }
  const NE = new xt();
  class OE extends Km {
    interpolate_(e, t, n, i) {
      const s = super.interpolate_(e, t, n, i);
      return NE.fromArray(s).normalize().toArray(s), s;
    }
  }
  const vn = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  }, Qs = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  }, Vp = {
    9728: Et,
    9729: yt,
    9984: eo,
    9985: Ka,
    9986: Zs,
    9987: Fn
  }, Gp = {
    33071: Xt,
    33648: er,
    10497: Ti
  }, yc = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  }, dh = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  }, xi = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  }, FE = {
    CUBICSPLINE: void 0,
    LINEAR: us,
    STEP: nr
  }, wc = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function BE(l) {
    return l.DefaultMaterial === void 0 && (l.DefaultMaterial = new gr({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: On
    })), l.DefaultMaterial;
  }
  function qr(l, e, t) {
    for (const n in t.extensions) l[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
  }
  function yi(l, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(l.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
  }
  function UE(l, e, t) {
    let n = false, i = false, s = false;
    for (let u = 0, p = e.length; u < p; u++) {
      const f = e[u];
      if (f.POSITION !== void 0 && (n = true), f.NORMAL !== void 0 && (i = true), f.COLOR_0 !== void 0 && (s = true), n && i && s) break;
    }
    if (!n && !i && !s) return Promise.resolve(l);
    const r = [], a = [], c = [];
    for (let u = 0, p = e.length; u < p; u++) {
      const f = e[u];
      if (n) {
        const m = f.POSITION !== void 0 ? t.getDependency("accessor", f.POSITION) : l.attributes.position;
        r.push(m);
      }
      if (i) {
        const m = f.NORMAL !== void 0 ? t.getDependency("accessor", f.NORMAL) : l.attributes.normal;
        a.push(m);
      }
      if (s) {
        const m = f.COLOR_0 !== void 0 ? t.getDependency("accessor", f.COLOR_0) : l.attributes.color;
        c.push(m);
      }
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(c)
    ]).then(function(u) {
      const p = u[0], f = u[1], m = u[2];
      return n && (l.morphAttributes.position = p), i && (l.morphAttributes.normal = f), s && (l.morphAttributes.color = m), l.morphTargetsRelative = true, l;
    });
  }
  function zE(l, e) {
    if (l.updateMorphTargets(), e.weights !== void 0) for (let t = 0, n = e.weights.length; t < n; t++) l.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
      const t = e.extras.targetNames;
      if (l.morphTargetInfluences.length === t.length) {
        l.morphTargetDictionary = {};
        for (let n = 0, i = t.length; n < i; n++) l.morphTargetDictionary[t[n]] = n;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function VE(l) {
    const e = l.extensions && l.extensions[ot.KHR_DRACO_MESH_COMPRESSION];
    let t;
    return e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Hp(e.attributes) : t = l.indices + ":" + Hp(l.attributes) + ":" + l.mode, t;
  }
  function Hp(l) {
    let e = "";
    const t = Object.keys(l).sort();
    for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + l[t[n]] + ";";
    return e;
  }
  function ph(l) {
    switch (l) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  function GE(l) {
    return l.search(/\.jpe?g($|\?)/i) > 0 || l.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : l.search(/\.webp($|\?)/i) > 0 || l.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
  }
  const HE = new ze();
  class WE {
    constructor(e = {}, t = {}) {
      this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new gE(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = {
        refs: {},
        uses: {}
      }, this.cameraCache = {
        refs: {},
        uses: {}
      }, this.lightCache = {
        refs: {},
        uses: {}
      }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
      let n = false, i = false, s = -1;
      typeof navigator < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && s < 98 ? this.textureLoader = new Zh(this.options.manager) : this.textureLoader = new Vm(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new pn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
    }
    setExtensions(e) {
      this.extensions = e;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    parse(e, t) {
      const n = this, i = this.json, s = this.extensions;
      this.cache.removeAll(), this._invokeAll(function(r) {
        return r._markDefs && r._markDefs();
      }), Promise.all(this._invokeAll(function(r) {
        return r.beforeRoot && r.beforeRoot();
      })).then(function() {
        return Promise.all([
          n.getDependencies("scene"),
          n.getDependencies("animation"),
          n.getDependencies("camera")
        ]);
      }).then(function(r) {
        const a = {
          scene: r[0][i.scene || 0],
          scenes: r[0],
          animations: r[1],
          cameras: r[2],
          asset: i.asset,
          parser: n,
          userData: {}
        };
        qr(s, a, i), yi(a, i), Promise.all(n._invokeAll(function(c) {
          return c.afterRoot && c.afterRoot(a);
        })).then(function() {
          e(a);
        });
      }).catch(t);
    }
    _markDefs() {
      const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
      for (let i = 0, s = t.length; i < s; i++) {
        const r = t[i].joints;
        for (let a = 0, c = r.length; a < c; a++) e[r[a]].isBone = true;
      }
      for (let i = 0, s = e.length; i < s; i++) {
        const r = e[i];
        r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (n[r.mesh].isSkinnedMesh = true)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
      }
    }
    _addNodeRef(e, t) {
      t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }
    _getNodeRef(e, t, n) {
      if (e.refs[t] <= 1) return n;
      const i = n.clone(), s = (r, a) => {
        const c = this.associations.get(r);
        c != null && this.associations.set(a, c);
        for (const [u, p] of r.children.entries()) s(p, a.children[u]);
      };
      return s(n, i), i.name += "_instance_" + e.uses[t]++, i;
    }
    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);
      for (let n = 0; n < t.length; n++) {
        const i = e(t[n]);
        if (i) return i;
      }
      return null;
    }
    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const n = [];
      for (let i = 0; i < t.length; i++) {
        const s = e(t[i]);
        s && n.push(s);
      }
      return n;
    }
    getDependency(e, t) {
      const n = e + ":" + t;
      let i = this.cache.get(n);
      if (!i) {
        switch (e) {
          case "scene":
            i = this.loadScene(t);
            break;
          case "node":
            i = this._invokeOne(function(s) {
              return s.loadNode && s.loadNode(t);
            });
            break;
          case "mesh":
            i = this._invokeOne(function(s) {
              return s.loadMesh && s.loadMesh(t);
            });
            break;
          case "accessor":
            i = this.loadAccessor(t);
            break;
          case "bufferView":
            i = this._invokeOne(function(s) {
              return s.loadBufferView && s.loadBufferView(t);
            });
            break;
          case "buffer":
            i = this.loadBuffer(t);
            break;
          case "material":
            i = this._invokeOne(function(s) {
              return s.loadMaterial && s.loadMaterial(t);
            });
            break;
          case "texture":
            i = this._invokeOne(function(s) {
              return s.loadTexture && s.loadTexture(t);
            });
            break;
          case "skin":
            i = this.loadSkin(t);
            break;
          case "animation":
            i = this._invokeOne(function(s) {
              return s.loadAnimation && s.loadAnimation(t);
            });
            break;
          case "camera":
            i = this.loadCamera(t);
            break;
          default:
            if (i = this._invokeOne(function(s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            }), !i) throw new Error("Unknown type: " + e);
            break;
        }
        this.cache.add(n, i);
      }
      return i;
    }
    getDependencies(e) {
      let t = this.cache.get(e);
      if (!t) {
        const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
        t = Promise.all(i.map(function(s, r) {
          return n.getDependency(e, r);
        })), this.cache.add(e, t);
      }
      return t;
    }
    loadBuffer(e) {
      const t = this.json.buffers[e], n = this.fileLoader;
      if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
      if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[ot.KHR_BINARY_GLTF].body);
      const i = this.options;
      return new Promise(function(s, r) {
        n.load(cr.resolveURL(t.uri, i.path), s, void 0, function() {
          r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
        });
      });
    }
    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function(n) {
        const i = t.byteLength || 0, s = t.byteOffset || 0;
        return n.slice(s, s + i);
      });
    }
    loadAccessor(e) {
      const t = this, n = this.json, i = this.json.accessors[e];
      if (i.bufferView === void 0 && i.sparse === void 0) {
        const r = yc[i.type], a = Qs[i.componentType], c = i.normalized === true, u = new a(i.count * r);
        return Promise.resolve(new ht(u, r, c));
      }
      const s = [];
      return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(r) {
        const a = r[0], c = yc[i.type], u = Qs[i.componentType], p = u.BYTES_PER_ELEMENT, f = p * c, m = i.byteOffset || 0, v = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, b = i.normalized === true;
        let _, x;
        if (v && v !== f) {
          const w = Math.floor(m / v), S = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + w + ":" + i.count;
          let y = t.cache.get(S);
          y || (_ = new u(a, w * v, i.count * v / p), y = new _o(_, v / p), t.cache.add(S, y)), x = new Pi(y, c, m % v / p, b);
        } else a === null ? _ = new u(i.count * c) : _ = new u(a, m, i.count * c), x = new ht(_, c, b);
        if (i.sparse !== void 0) {
          const w = yc.SCALAR, S = Qs[i.sparse.indices.componentType], y = i.sparse.indices.byteOffset || 0, M = i.sparse.values.byteOffset || 0, C = new S(r[1], y, i.sparse.count * w), R = new u(r[2], M, i.sparse.count * c);
          a !== null && (x = new ht(x.array.slice(), x.itemSize, x.normalized));
          for (let k = 0, T = C.length; k < T; k++) {
            const L = C[k];
            if (x.setX(L, R[k * c]), c >= 2 && x.setY(L, R[k * c + 1]), c >= 3 && x.setZ(L, R[k * c + 2]), c >= 4 && x.setW(L, R[k * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return x;
      });
    }
    loadTexture(e) {
      const t = this.json, n = this.options, s = t.textures[e].source, r = t.images[s];
      let a = this.textureLoader;
      if (r.uri) {
        const c = n.manager.getHandler(r.uri);
        c !== null && (a = c);
      }
      return this.loadTextureImage(e, s, a);
    }
    loadTextureImage(e, t, n) {
      const i = this, s = this.json, r = s.textures[e], a = s.images[t], c = (a.uri || a.bufferView) + ":" + r.sampler;
      if (this.textureCache[c]) return this.textureCache[c];
      const u = this.loadImageSource(t, n).then(function(p) {
        p.flipY = false, p.name = r.name || a.name || "";
        const m = (s.samplers || {})[r.sampler] || {};
        return p.magFilter = Vp[m.magFilter] || yt, p.minFilter = Vp[m.minFilter] || Fn, p.wrapS = Gp[m.wrapS] || Ti, p.wrapT = Gp[m.wrapT] || Ti, i.associations.set(p, {
          textures: e
        }), p;
      }).catch(function() {
        return null;
      });
      return this.textureCache[c] = u, u;
    }
    loadImageSource(e, t) {
      const n = this, i = this.json, s = this.options;
      if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((f) => f.clone());
      const r = i.images[e], a = self.URL || self.webkitURL;
      let c = r.uri || "", u = false;
      if (r.bufferView !== void 0) c = n.getDependency("bufferView", r.bufferView).then(function(f) {
        u = true;
        const m = new Blob([
          f
        ], {
          type: r.mimeType
        });
        return c = a.createObjectURL(m), c;
      });
      else if (r.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
      const p = Promise.resolve(c).then(function(f) {
        return new Promise(function(m, v) {
          let b = m;
          t.isImageBitmapLoader === true && (b = function(_) {
            const x = new Mt(_);
            x.needsUpdate = true, m(x);
          }), t.load(cr.resolveURL(f, s.path), b, void 0, v);
        });
      }).then(function(f) {
        return u === true && a.revokeObjectURL(c), f.userData.mimeType = r.mimeType || GE(r.uri), f;
      }).catch(function(f) {
        throw console.error("THREE.GLTFLoader: Couldn't load texture", c), f;
      });
      return this.sourceCache[e] = p, p;
    }
    assignTexture(e, t, n, i) {
      const s = this;
      return this.getDependency("texture", n.index).then(function(r) {
        if (!r) return null;
        if (n.texCoord !== void 0 && n.texCoord != 0 && !(t === "aoMap" && n.texCoord == 1) && console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), s.extensions[ot.KHR_TEXTURE_TRANSFORM]) {
          const a = n.extensions !== void 0 ? n.extensions[ot.KHR_TEXTURE_TRANSFORM] : void 0;
          if (a) {
            const c = s.associations.get(r);
            r = s.extensions[ot.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), s.associations.set(r, c);
          }
        }
        return i !== void 0 && (r.encoding = i), e[t] = r, r;
      });
    }
    assignFinalMaterial(e) {
      const t = e.geometry;
      let n = e.material;
      const i = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, r = t.attributes.normal === void 0;
      if (e.isPoints) {
        const a = "PointsMaterial:" + n.uuid;
        let c = this.cache.get(a);
        c || (c = new sl(), Bt.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = false, this.cache.add(a, c)), n = c;
      } else if (e.isLine) {
        const a = "LineBasicMaterial:" + n.uuid;
        let c = this.cache.get(a);
        c || (c = new Zt(), Bt.prototype.copy.call(c, n), c.color.copy(n.color), this.cache.add(a, c)), n = c;
      }
      if (i || s || r) {
        let a = "ClonedMaterial:" + n.uuid + ":";
        i && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), r && (a += "flat-shading:");
        let c = this.cache.get(a);
        c || (c = n.clone(), s && (c.vertexColors = true), r && (c.flatShading = true), i && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(a, c), this.associations.set(c, this.associations.get(n))), n = c;
      }
      n.aoMap && t.attributes.uv2 === void 0 && t.attributes.uv !== void 0 && t.setAttribute("uv2", t.attributes.uv), e.material = n;
    }
    getMaterialType() {
      return gr;
    }
    loadMaterial(e) {
      const t = this, n = this.json, i = this.extensions, s = n.materials[e];
      let r;
      const a = {}, c = s.extensions || {}, u = [];
      if (c[ot.KHR_MATERIALS_UNLIT]) {
        const f = i[ot.KHR_MATERIALS_UNLIT];
        r = f.getMaterialType(), u.push(f.extendParams(a, s, t));
      } else {
        const f = s.pbrMetallicRoughness || {};
        if (a.color = new we(1, 1, 1), a.opacity = 1, Array.isArray(f.baseColorFactor)) {
          const m = f.baseColorFactor;
          a.color.fromArray(m), a.opacity = m[3];
        }
        f.baseColorTexture !== void 0 && u.push(t.assignTexture(a, "map", f.baseColorTexture, ct)), a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (u.push(t.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)), u.push(t.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture))), r = this._invokeOne(function(m) {
          return m.getMaterialType && m.getMaterialType(e);
        }), u.push(Promise.all(this._invokeAll(function(m) {
          return m.extendMaterialParams && m.extendMaterialParams(e, a);
        })));
      }
      s.doubleSided === true && (a.side = Dn);
      const p = s.alphaMode || wc.OPAQUE;
      if (p === wc.BLEND ? (a.transparent = true, a.depthWrite = false) : (a.transparent = false, p === wc.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && r !== $t && (u.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new te(1, 1), s.normalTexture.scale !== void 0)) {
        const f = s.normalTexture.scale;
        a.normalScale.set(f, f);
      }
      return s.occlusionTexture !== void 0 && r !== $t && (u.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && r !== $t && (a.emissive = new we().fromArray(s.emissiveFactor)), s.emissiveTexture !== void 0 && r !== $t && u.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, ct)), Promise.all(u).then(function() {
        const f = new r(a);
        return s.name && (f.name = s.name), yi(f, s), t.associations.set(f, {
          materials: e
        }), s.extensions && qr(i, f, s), f;
      });
    }
    createUniqueName(e) {
      const t = st.sanitizeNodeName(e || "");
      let n = t;
      for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
      return this.nodeNamesUsed[n] = true, n;
    }
    loadGeometries(e) {
      const t = this, n = this.extensions, i = this.primitiveCache;
      function s(a) {
        return n[ot.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(c) {
          return Wp(c, a, t);
        });
      }
      const r = [];
      for (let a = 0, c = e.length; a < c; a++) {
        const u = e[a], p = VE(u), f = i[p];
        if (f) r.push(f.promise);
        else {
          let m;
          u.extensions && u.extensions[ot.KHR_DRACO_MESH_COMPRESSION] ? m = s(u) : m = Wp(new Xe(), u, t), i[p] = {
            primitive: u,
            promise: m
          }, r.push(m);
        }
      }
      return Promise.all(r);
    }
    loadMesh(e) {
      const t = this, n = this.json, i = this.extensions, s = n.meshes[e], r = s.primitives, a = [];
      for (let c = 0, u = r.length; c < u; c++) {
        const p = r[c].material === void 0 ? BE(this.cache) : this.getDependency("material", r[c].material);
        a.push(p);
      }
      return a.push(t.loadGeometries(r)), Promise.all(a).then(function(c) {
        const u = c.slice(0, c.length - 1), p = c[c.length - 1], f = [];
        for (let v = 0, b = p.length; v < b; v++) {
          const _ = p[v], x = r[v];
          let w;
          const S = u[v];
          if (x.mode === vn.TRIANGLES || x.mode === vn.TRIANGLE_STRIP || x.mode === vn.TRIANGLE_FAN || x.mode === void 0) w = s.isSkinnedMesh === true ? new Nh(_, S) : new kt(_, S), w.isSkinnedMesh === true && !w.geometry.attributes.skinWeight.normalized && w.normalizeSkinWeights(), x.mode === vn.TRIANGLE_STRIP ? w.geometry = Up(w.geometry, Mh) : x.mode === vn.TRIANGLE_FAN && (w.geometry = Up(w.geometry, Ga));
          else if (x.mode === vn.LINES) w = new Cn(_, S);
          else if (x.mode === vn.LINE_STRIP) w = new si(_, S);
          else if (x.mode === vn.LINE_LOOP) w = new Fh(_, S);
          else if (x.mode === vn.POINTS) w = new Bh(_, S);
          else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + x.mode);
          Object.keys(w.geometry.morphAttributes).length > 0 && zE(w, s), w.name = t.createUniqueName(s.name || "mesh_" + e), yi(w, s), x.extensions && qr(i, w, x), t.assignFinalMaterial(w), f.push(w);
        }
        for (let v = 0, b = f.length; v < b; v++) t.associations.set(f[v], {
          meshes: e,
          primitives: v
        });
        if (f.length === 1) return f[0];
        const m = new ni();
        t.associations.set(m, {
          meshes: e
        });
        for (let v = 0, b = f.length; v < b; v++) m.add(f[v]);
        return m;
      });
    }
    loadCamera(e) {
      let t;
      const n = this.json.cameras[e], i = n[n.type];
      if (!i) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      return n.type === "perspective" ? t = new Ft(Kf.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new vo(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), yi(t, n), Promise.resolve(t);
    }
    loadSkin(e) {
      const t = this.json.skins[e], n = [];
      for (let i = 0, s = t.joints.length; i < s; i++) n.push(this.getDependency("node", t.joints[i]));
      return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
        const s = i.pop(), r = i, a = [], c = [];
        for (let u = 0, p = r.length; u < p; u++) {
          const f = r[u];
          if (f) {
            a.push(f);
            const m = new ze();
            s !== null && m.fromArray(s.array, u * 16), c.push(m);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[u]);
        }
        return new xo(a, c);
      });
    }
    loadAnimation(e) {
      const n = this.json.animations[e], i = [], s = [], r = [], a = [], c = [];
      for (let u = 0, p = n.channels.length; u < p; u++) {
        const f = n.channels[u], m = n.samplers[f.sampler], v = f.target, b = v.node, _ = n.parameters !== void 0 ? n.parameters[m.input] : m.input, x = n.parameters !== void 0 ? n.parameters[m.output] : m.output;
        i.push(this.getDependency("node", b)), s.push(this.getDependency("accessor", _)), r.push(this.getDependency("accessor", x)), a.push(m), c.push(v);
      }
      return Promise.all([
        Promise.all(i),
        Promise.all(s),
        Promise.all(r),
        Promise.all(a),
        Promise.all(c)
      ]).then(function(u) {
        const p = u[0], f = u[1], m = u[2], v = u[3], b = u[4], _ = [];
        for (let w = 0, S = p.length; w < S; w++) {
          const y = p[w], M = f[w], C = m[w], R = v[w], k = b[w];
          if (y === void 0) continue;
          y.updateMatrix();
          let T;
          switch (xi[k.path]) {
            case xi.weights:
              T = or;
              break;
            case xi.rotation:
              T = Li;
              break;
            case xi.position:
            case xi.scale:
            default:
              T = ar;
              break;
          }
          const L = y.name ? y.name : y.uuid, F = R.interpolation !== void 0 ? FE[R.interpolation] : us, j = [];
          xi[k.path] === xi.weights ? y.traverse(function(z) {
            z.morphTargetInfluences && j.push(z.name ? z.name : z.uuid);
          }) : j.push(L);
          let Y = C.array;
          if (C.normalized) {
            const z = ph(Y.constructor), B = new Float32Array(Y.length);
            for (let Z = 0, ie = Y.length; Z < ie; Z++) B[Z] = Y[Z] * z;
            Y = B;
          }
          for (let z = 0, B = j.length; z < B; z++) {
            const Z = new T(j[z] + "." + xi[k.path], M.array, Y, F);
            R.interpolation === "CUBICSPLINE" && (Z.createInterpolant = function(re) {
              const W = this instanceof Li ? OE : Km;
              return new W(this.times, this.values, this.getValueSize() / 3, re);
            }, Z.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), _.push(Z);
          }
        }
        const x = n.name ? n.name : "animation_" + e;
        return new lr(x, void 0, _);
      });
    }
    createNodeMesh(e) {
      const t = this.json, n = this, i = t.nodes[e];
      return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
        const r = n._getNodeRef(n.meshCache, i.mesh, s);
        return i.weights !== void 0 && r.traverse(function(a) {
          if (a.isMesh) for (let c = 0, u = i.weights.length; c < u; c++) a.morphTargetInfluences[c] = i.weights[c];
        }), r;
      });
    }
    loadNode(e) {
      const t = this.json, n = this.extensions, i = this, s = t.nodes[e], r = s.name ? i.createUniqueName(s.name) : "";
      return (function() {
        const a = [], c = i._invokeOne(function(m) {
          return m.createNodeMesh && m.createNodeMesh(e);
        });
        c && a.push(c), s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(m) {
          return i._getNodeRef(i.cameraCache, s.camera, m);
        })), i._invokeAll(function(m) {
          return m.createNodeAttachment && m.createNodeAttachment(e);
        }).forEach(function(m) {
          a.push(m);
        });
        const u = [], p = s.children || [];
        for (let m = 0, v = p.length; m < v; m++) u.push(i.getDependency("node", p[m]));
        const f = s.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", s.skin);
        return Promise.all([
          Promise.all(a),
          Promise.all(u),
          f
        ]);
      })().then(function(a) {
        const c = a[0], u = a[1], p = a[2];
        let f;
        if (s.isBone === true ? f = new il() : c.length > 1 ? f = new ni() : c.length === 1 ? f = c[0] : f = new rt(), f !== c[0]) for (let m = 0, v = c.length; m < v; m++) f.add(c[m]);
        if (s.name && (f.userData.name = s.name, f.name = r), yi(f, s), s.extensions && qr(n, f, s), s.matrix !== void 0) {
          const m = new ze();
          m.fromArray(s.matrix), f.applyMatrix4(m);
        } else s.translation !== void 0 && f.position.fromArray(s.translation), s.rotation !== void 0 && f.quaternion.fromArray(s.rotation), s.scale !== void 0 && f.scale.fromArray(s.scale);
        i.associations.has(f) || i.associations.set(f, {}), i.associations.get(f).nodes = e, p !== null && f.traverse(function(m) {
          m.isSkinnedMesh && m.bind(p, HE);
        });
        for (let m = 0, v = u.length; m < v; m++) f.add(u[m]);
        return f;
      });
    }
    loadScene(e) {
      const t = this.extensions, n = this.json.scenes[e], i = this, s = new ni();
      n.name && (s.name = i.createUniqueName(n.name)), yi(s, n), n.extensions && qr(t, s, n);
      const r = n.nodes || [], a = [];
      for (let c = 0, u = r.length; c < u; c++) a.push(i.getDependency("node", r[c]));
      return Promise.all(a).then(function(c) {
        for (let p = 0, f = c.length; p < f; p++) s.add(c[p]);
        const u = (p) => {
          const f = /* @__PURE__ */ new Map();
          for (const [m, v] of i.associations) (m instanceof Bt || m instanceof Mt) && f.set(m, v);
          return p.traverse((m) => {
            const v = i.associations.get(m);
            v != null && f.set(m, v);
          }), f;
        };
        return i.associations = u(s), s;
      });
    }
  }
  function qE(l, e, t) {
    const n = e.attributes, i = new Bn();
    if (n.POSITION !== void 0) {
      const a = t.json.accessors[n.POSITION], c = a.min, u = a.max;
      if (c !== void 0 && u !== void 0) {
        if (i.set(new P(c[0], c[1], c[2]), new P(u[0], u[1], u[2])), a.normalized) {
          const p = ph(Qs[a.componentType]);
          i.min.multiplyScalar(p), i.max.multiplyScalar(p);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else return;
    const s = e.targets;
    if (s !== void 0) {
      const a = new P(), c = new P();
      for (let u = 0, p = s.length; u < p; u++) {
        const f = s[u];
        if (f.POSITION !== void 0) {
          const m = t.json.accessors[f.POSITION], v = m.min, b = m.max;
          if (v !== void 0 && b !== void 0) {
            if (c.setX(Math.max(Math.abs(v[0]), Math.abs(b[0]))), c.setY(Math.max(Math.abs(v[1]), Math.abs(b[1]))), c.setZ(Math.max(Math.abs(v[2]), Math.abs(b[2]))), m.normalized) {
              const _ = ph(Qs[m.componentType]);
              c.multiplyScalar(_);
            }
            a.max(c);
          } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      i.expandByVector(a);
    }
    l.boundingBox = i;
    const r = new Ii();
    i.getCenter(r.center), r.radius = i.min.distanceTo(i.max) / 2, l.boundingSphere = r;
  }
  function Wp(l, e, t) {
    const n = e.attributes, i = [];
    function s(r, a) {
      return t.getDependency("accessor", r).then(function(c) {
        l.setAttribute(a, c);
      });
    }
    for (const r in n) {
      const a = dh[r] || r.toLowerCase();
      a in l.attributes || i.push(s(n[r], a));
    }
    if (e.indices !== void 0 && !l.index) {
      const r = t.getDependency("accessor", e.indices).then(function(a) {
        l.setIndex(a);
      });
      i.push(r);
    }
    return yi(l, e), qE(l, e, t), Promise.all(i).then(function() {
      return e.targets !== void 0 ? UE(l, e.targets, t) : l;
    });
  }
  const XE = Object.freeze(Object.defineProperty({
    __proto__: null,
    GLTFLoader: Xm
  }, Symbol.toStringTag, {
    value: "Module"
  })), Mc = /* @__PURE__ */ new WeakMap();
  class Ym extends sn {
    constructor(e) {
      super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD"
      }, this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array"
      };
    }
    setDecoderPath(e) {
      return this.decoderPath = e, this;
    }
    setDecoderConfig(e) {
      return this.decoderConfig = e, this;
    }
    setWorkerLimit(e) {
      return this.workerLimit = e, this;
    }
    load(e, t, n, i) {
      const s = new pn(this.manager);
      s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (r) => {
        this.decodeDracoFile(r, t).catch(i);
      }, n, i);
    }
    decodeDracoFile(e, t, n, i) {
      const s = {
        attributeIDs: n || this.defaultAttributeIDs,
        attributeTypes: i || this.defaultAttributeTypes,
        useUniqueIDs: !!n
      };
      return this.decodeGeometry(e, s).then(t);
    }
    decodeGeometry(e, t) {
      const n = JSON.stringify(t);
      if (Mc.has(e)) {
        const c = Mc.get(e);
        if (c.key === n) return c.promise;
        if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
      }
      let i;
      const s = this.workerNextTaskID++, r = e.byteLength, a = this._getWorker(s, r).then((c) => (i = c, new Promise((u, p) => {
        i._callbacks[s] = {
          resolve: u,
          reject: p
        }, i.postMessage({
          type: "decode",
          id: s,
          taskConfig: t,
          buffer: e
        }, [
          e
        ]);
      }))).then((c) => this._createGeometry(c.geometry));
      return a.catch(() => true).then(() => {
        i && s && this._releaseTask(i, s);
      }), Mc.set(e, {
        key: n,
        promise: a
      }), a;
    }
    _createGeometry(e) {
      const t = new Xe();
      e.index && t.setIndex(new ht(e.index.array, 1));
      for (let n = 0; n < e.attributes.length; n++) {
        const i = e.attributes[n], s = i.name, r = i.array, a = i.itemSize;
        t.setAttribute(s, new ht(r, a));
      }
      return t;
    }
    _loadLibrary(e, t) {
      const n = new pn(this.manager);
      return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, s) => {
        n.load(e, i, void 0, s);
      });
    }
    preload() {
      return this._initDecoder(), this;
    }
    _initDecoder() {
      if (this.decoderPending) return this.decoderPending;
      const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
      return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
        const i = n[0];
        e || (this.decoderConfig.wasmBinary = n[1]);
        const s = jE.toString(), r = [
          "/* draco decoder */",
          i,
          "",
          "/* worker */",
          s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([
          r
        ]));
      }), this.decoderPending;
    }
    _getWorker(e, t) {
      return this._initDecoder().then(() => {
        if (this.workerPool.length < this.workerLimit) {
          const i = new Worker(this.workerSourceURL);
          i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
            type: "init",
            decoderConfig: this.decoderConfig
          }), i.onmessage = function(s) {
            const r = s.data;
            switch (r.type) {
              case "decode":
                i._callbacks[r.id].resolve(r);
                break;
              case "error":
                i._callbacks[r.id].reject(r);
                break;
              default:
                console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
            }
          }, this.workerPool.push(i);
        } else this.workerPool.sort(function(i, s) {
          return i._taskLoad > s._taskLoad ? -1 : 1;
        });
        const n = this.workerPool[this.workerPool.length - 1];
        return n._taskCosts[e] = t, n._taskLoad += t, n;
      });
    }
    _releaseTask(e, t) {
      e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
    }
    debug() {
      console.log("Task load: ", this.workerPool.map((e) => e._taskLoad));
    }
    dispose() {
      for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
      return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
    }
  }
  function jE() {
    let l, e;
    onmessage = function(r) {
      const a = r.data;
      switch (a.type) {
        case "init":
          l = a.decoderConfig, e = new Promise(function(p) {
            l.onModuleLoaded = function(f) {
              p({
                draco: f
              });
            }, DracoDecoderModule(l);
          });
          break;
        case "decode":
          const c = a.buffer, u = a.taskConfig;
          e.then((p) => {
            const f = p.draco, m = new f.Decoder(), v = new f.DecoderBuffer();
            v.Init(new Int8Array(c), c.byteLength);
            try {
              const b = t(f, m, v, u), _ = b.attributes.map((x) => x.array.buffer);
              b.index && _.push(b.index.array.buffer), self.postMessage({
                type: "decode",
                id: a.id,
                geometry: b
              }, _);
            } catch (b) {
              console.error(b), self.postMessage({
                type: "error",
                id: a.id,
                error: b.message
              });
            } finally {
              f.destroy(v), f.destroy(m);
            }
          });
          break;
      }
    };
    function t(r, a, c, u) {
      const p = u.attributeIDs, f = u.attributeTypes;
      let m, v;
      const b = a.GetEncodedGeometryType(c);
      if (b === r.TRIANGULAR_MESH) m = new r.Mesh(), v = a.DecodeBufferToMesh(c, m);
      else if (b === r.POINT_CLOUD) m = new r.PointCloud(), v = a.DecodeBufferToPointCloud(c, m);
      else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
      if (!v.ok() || m.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + v.error_msg());
      const _ = {
        index: null,
        attributes: []
      };
      for (const x in p) {
        const w = self[f[x]];
        let S, y;
        if (u.useUniqueIDs) y = p[x], S = a.GetAttributeByUniqueId(m, y);
        else {
          if (y = a.GetAttributeId(m, r[p[x]]), y === -1) continue;
          S = a.GetAttribute(m, y);
        }
        _.attributes.push(i(r, a, m, x, w, S));
      }
      return b === r.TRIANGULAR_MESH && (_.index = n(r, a, m)), r.destroy(m), _;
    }
    function n(r, a, c) {
      const p = c.num_faces() * 3, f = p * 4, m = r._malloc(f);
      a.GetTrianglesUInt32Array(c, f, m);
      const v = new Uint32Array(r.HEAPF32.buffer, m, p).slice();
      return r._free(m), {
        array: v,
        itemSize: 1
      };
    }
    function i(r, a, c, u, p, f) {
      const m = f.num_components(), b = c.num_points() * m, _ = b * p.BYTES_PER_ELEMENT, x = s(r, p), w = r._malloc(_);
      a.GetAttributeDataArrayForAllPoints(c, f, x, _, w);
      const S = new p(r.HEAPF32.buffer, w, b).slice();
      return r._free(w), {
        name: u,
        array: S,
        itemSize: m
      };
    }
    function s(r, a) {
      switch (a) {
        case Float32Array:
          return r.DT_FLOAT32;
        case Int8Array:
          return r.DT_INT8;
        case Int16Array:
          return r.DT_INT16;
        case Int32Array:
          return r.DT_INT32;
        case Uint8Array:
          return r.DT_UINT8;
        case Uint16Array:
          return r.DT_UINT16;
        case Uint32Array:
          return r.DT_UINT32;
      }
    }
  }
  const KE = Object.freeze(Object.defineProperty({
    __proto__: null,
    DRACOLoader: Ym
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class YE {
    constructor() {
      this.assetStore = dl.getState(), this.assetsToLoad = this.assetStore.assetsToLoad, this.addLoadedAsset = this.assetStore.addLoadedAsset, this.instantiateLoaders(), this.startLoading();
    }
    instantiateLoaders() {
      const e = new Ym();
      e.setDecoderPath("/draco/"), this.gltfLoader = new Xm(), this.gltfLoader.setDRACOLoader(e), this.textureLoader = new Zh();
    }
    startLoading() {
      this.assetsToLoad.forEach((e) => {
        e.type === "texture" && this.textureLoader.load(e.path, (t) => {
          this.addLoadedAsset(t, e.id);
        }), e.type === "model" && this.gltfLoader.load(e.path, (t) => {
          this.addLoadedAsset(t, e.id);
        });
      });
    }
  }
  class $E {
    constructor() {
      this.assetStore = dl, this.overlay = document.querySelector(".overlay"), this.loading = document.querySelector(".loading"), this.startButton = document.querySelector(".start"), this.popup = document.querySelector("#popup"), this.assetStore.subscribe((e) => {
        this.numberOfLoadedAssets = Object.keys(e.loadedAssets).length, this.numberOfAssetsToLoad = e.assetsToLoad.length, this.progress = this.numberOfLoadedAssets / this.numberOfAssetsToLoad, this.progress = Math.trunc(this.progress * 100), document.getElementById("progressPercentage").innerHTML = this.progress, this.progress === 100 && (ho.setState({
          assetsReady: true
        }), this.loading.classList.add("fade"), window.setTimeout(() => this.ready(), 1200));
      });
    }
    ready() {
      this.loading.remove(), this.startButton.style.display = "inline", this.startButton.classList.add("fadeIn"), this.startButton.addEventListener("click", () => {
        this.overlay.classList.add("fade"), this.startButton.classList.add("fadeOut"), window.setTimeout(() => {
          this.overlay.remove(), this.startButton.remove();
        }, 2e3), this.popup.classList.add("show"), window.setTimeout(() => this.popup.classList.remove("show"), 6e3), ho.setState({
          nippleReady: true
        });
      }, {
        once: true
      });
    }
  }
  const za = (l, e) => {
    const t = e.x - l.x, n = e.y - l.y;
    return Math.sqrt(t * t + n * n);
  }, ZE = (l, e) => {
    const t = e.x - l.x, n = e.y - l.y;
    return QE(Math.atan2(n, t));
  }, JE = (l, e, t) => {
    const n = {
      x: 0,
      y: 0
    };
    return t = fh(t), n.x = l.x - e * Math.cos(t), n.y = l.y - e * Math.sin(t), n;
  }, fh = (l) => l * (Math.PI / 180), QE = (l) => l * (180 / Math.PI), eT = (l) => isNaN(l.buttons) ? l.pressure !== 0 : l.buttons !== 0, Sc = /* @__PURE__ */ new Map(), qp = (l) => {
    Sc.has(l) && clearTimeout(Sc.get(l)), Sc.set(l, setTimeout(l, 100));
  }, qa = (l, e, t) => {
    const n = e.split(/[ ,]+/g);
    let i;
    for (let s = 0; s < n.length; s += 1) i = n[s], l.addEventListener ? l.addEventListener(i, t, false) : l.attachEvent && l.attachEvent(i, t);
  }, Xp = (l, e, t) => {
    const n = e.split(/[ ,]+/g);
    let i;
    for (let s = 0; s < n.length; s += 1) i = n[s], l.removeEventListener ? l.removeEventListener(i, t) : l.detachEvent && l.detachEvent(i, t);
  }, $m = (l) => (l.preventDefault(), l.type.match(/^touch/) ? l.changedTouches : l), jp = () => {
    const l = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, e = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    return {
      x: l,
      y: e
    };
  }, Kp = (l, e) => {
    e.top || e.right || e.bottom || e.left ? (l.style.top = e.top, l.style.right = e.right, l.style.bottom = e.bottom, l.style.left = e.left) : (l.style.left = e.x + "px", l.style.top = e.y + "px");
  }, lu = (l, e, t) => {
    const n = Zm(l);
    for (let i in n) if (n.hasOwnProperty(i)) if (typeof e == "string") n[i] = e + " " + t;
    else {
      let s = "";
      for (let r = 0, a = e.length; r < a; r += 1) s += e[r] + " " + t + ", ";
      n[i] = s.slice(0, -2);
    }
    return n;
  }, tT = (l, e) => {
    const t = Zm(l);
    for (let n in t) t.hasOwnProperty(n) && (t[n] = e);
    return t;
  }, Zm = (l) => {
    const e = {};
    return e[l] = "", [
      "webkit",
      "Moz",
      "o"
    ].forEach(function(n) {
      e[n + l.charAt(0).toUpperCase() + l.slice(1)] = "";
    }), e;
  }, Ec = (l, e) => {
    for (let t in e) e.hasOwnProperty(t) && (l[t] = e[t]);
    return l;
  }, nT = (l, e) => {
    const t = {};
    for (let n in l) l.hasOwnProperty(n) && e.hasOwnProperty(n) ? t[n] = e[n] : l.hasOwnProperty(n) && (t[n] = l[n]);
    return t;
  }, mh = (l, e) => {
    if (l.length) for (let t = 0, n = l.length; t < n; t += 1) e(l[t]);
    else e(l);
  }, iT = (l, e, t) => ({
    x: Math.min(Math.max(l.x, e.x - t), e.x + t),
    y: Math.min(Math.max(l.y, e.y - t), e.y + t)
  });
  var sT = "ontouchstart" in window, rT = !!window.PointerEvent, oT = !!window.MSPointerEvent, Xr = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      end: "touchend, touchcancel"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      end: "mouseup"
    },
    pointer: {
      start: "pointerdown",
      move: "pointermove",
      end: "pointerup, pointercancel"
    },
    MSPointer: {
      start: "MSPointerDown",
      move: "MSPointerMove",
      end: "MSPointerUp"
    }
  }, $s, uo = {};
  rT ? $s = Xr.pointer : oT ? $s = Xr.MSPointer : sT ? ($s = Xr.touch, uo = Xr.mouse) : $s = Xr.mouse;
  function ai() {
  }
  ai.prototype.on = function(l, e) {
    var t = this, n = l.split(/[ ,]+/g), i;
    t._handlers_ = t._handlers_ || {};
    for (var s = 0; s < n.length; s += 1) i = n[s], t._handlers_[i] = t._handlers_[i] || [], t._handlers_[i].push(e);
    return t;
  };
  ai.prototype.off = function(l, e) {
    var t = this;
    return t._handlers_ = t._handlers_ || {}, l === void 0 ? t._handlers_ = {} : e === void 0 ? t._handlers_[l] = null : t._handlers_[l] && t._handlers_[l].indexOf(e) >= 0 && t._handlers_[l].splice(t._handlers_[l].indexOf(e), 1), t;
  };
  ai.prototype.trigger = function(l, e) {
    var t = this, n = l.split(/[ ,]+/g), i;
    t._handlers_ = t._handlers_ || {};
    for (var s = 0; s < n.length; s += 1) i = n[s], t._handlers_[i] && t._handlers_[i].length && t._handlers_[i].forEach(function(r) {
      r.call(t, {
        type: i,
        target: t
      }, e);
    });
  };
  ai.prototype.config = function(l) {
    var e = this;
    e.options = e.defaults || {}, l && (e.options = nT(e.options, l));
  };
  ai.prototype.bindEvt = function(l, e) {
    var t = this;
    return t._domHandlers_ = t._domHandlers_ || {}, t._domHandlers_[e] = function() {
      typeof t["on" + e] == "function" ? t["on" + e].apply(t, arguments) : console.warn('[WARNING] : Missing "on' + e + '" handler.');
    }, qa(l, $s[e], t._domHandlers_[e]), uo[e] && qa(l, uo[e], t._domHandlers_[e]), t;
  };
  ai.prototype.unbindEvt = function(l, e) {
    var t = this;
    return t._domHandlers_ = t._domHandlers_ || {}, Xp(l, $s[e], t._domHandlers_[e]), uo[e] && Xp(l, uo[e], t._domHandlers_[e]), delete t._domHandlers_[e], this;
  };
  function Vt(l, e) {
    return this.identifier = e.identifier, this.position = e.position, this.frontPosition = e.frontPosition, this.collection = l, this.defaults = {
      size: 100,
      threshold: 0.1,
      color: "white",
      fadeTime: 250,
      dataOnly: false,
      restJoystick: true,
      restOpacity: 0.5,
      mode: "dynamic",
      zone: document.body,
      lockX: false,
      lockY: false,
      shape: "circle"
    }, this.config(e), this.options.mode === "dynamic" && (this.options.restOpacity = 0), this.id = Vt.id, Vt.id += 1, this.buildEl().stylize(), this.instance = {
      el: this.ui.el,
      on: this.on.bind(this),
      off: this.off.bind(this),
      show: this.show.bind(this),
      hide: this.hide.bind(this),
      add: this.addToDom.bind(this),
      remove: this.removeFromDom.bind(this),
      destroy: this.destroy.bind(this),
      setPosition: this.setPosition.bind(this),
      resetDirection: this.resetDirection.bind(this),
      computeDirection: this.computeDirection.bind(this),
      trigger: this.trigger.bind(this),
      position: this.position,
      frontPosition: this.frontPosition,
      ui: this.ui,
      identifier: this.identifier,
      id: this.id,
      options: this.options
    }, this.instance;
  }
  Vt.prototype = new ai();
  Vt.constructor = Vt;
  Vt.id = 0;
  Vt.prototype.buildEl = function(l) {
    return this.ui = {}, this.options.dataOnly ? this : (this.ui.el = document.createElement("div"), this.ui.back = document.createElement("div"), this.ui.front = document.createElement("div"), this.ui.el.className = "nipple collection_" + this.collection.id, this.ui.back.className = "back", this.ui.front.className = "front", this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id), this.ui.el.appendChild(this.ui.back), this.ui.el.appendChild(this.ui.front), this);
  };
  Vt.prototype.stylize = function() {
    if (this.options.dataOnly) return this;
    var l = this.options.fadeTime + "ms", e = tT("borderRadius", "50%"), t = lu("transition", "opacity", l), n = {};
    return n.el = {
      position: "absolute",
      opacity: this.options.restOpacity,
      display: "block",
      zIndex: 999
    }, n.back = {
      position: "absolute",
      display: "block",
      width: this.options.size + "px",
      height: this.options.size + "px",
      left: 0,
      marginLeft: -this.options.size / 2 + "px",
      marginTop: -this.options.size / 2 + "px",
      background: this.options.color,
      opacity: ".5"
    }, n.front = {
      width: this.options.size / 2 + "px",
      height: this.options.size / 2 + "px",
      position: "absolute",
      display: "block",
      left: 0,
      marginLeft: -this.options.size / 4 + "px",
      marginTop: -this.options.size / 4 + "px",
      background: this.options.color,
      opacity: ".5",
      transform: "translate(0px, 0px)"
    }, Ec(n.el, t), this.options.shape === "circle" && Ec(n.back, e), Ec(n.front, e), this.applyStyles(n), this;
  };
  Vt.prototype.applyStyles = function(l) {
    for (var e in this.ui) if (this.ui.hasOwnProperty(e)) for (var t in l[e]) this.ui[e].style[t] = l[e][t];
    return this;
  };
  Vt.prototype.addToDom = function() {
    return this.options.dataOnly || document.body.contains(this.ui.el) ? this : (this.options.zone.appendChild(this.ui.el), this);
  };
  Vt.prototype.removeFromDom = function() {
    return this.options.dataOnly || !document.body.contains(this.ui.el) ? this : (this.options.zone.removeChild(this.ui.el), this);
  };
  Vt.prototype.destroy = function() {
    clearTimeout(this.removeTimeout), clearTimeout(this.showTimeout), clearTimeout(this.restTimeout), this.trigger("destroyed", this.instance), this.removeFromDom(), this.off();
  };
  Vt.prototype.show = function(l) {
    var e = this;
    return e.options.dataOnly || (clearTimeout(e.removeTimeout), clearTimeout(e.showTimeout), clearTimeout(e.restTimeout), e.addToDom(), e.restCallback(), setTimeout(function() {
      e.ui.el.style.opacity = 1;
    }, 0), e.showTimeout = setTimeout(function() {
      e.trigger("shown", e.instance), typeof l == "function" && l.call(this);
    }, e.options.fadeTime)), e;
  };
  Vt.prototype.hide = function(l) {
    var e = this;
    if (e.options.dataOnly) return e;
    if (e.ui.el.style.opacity = e.options.restOpacity, clearTimeout(e.removeTimeout), clearTimeout(e.showTimeout), clearTimeout(e.restTimeout), e.removeTimeout = setTimeout(function() {
      var t = e.options.mode === "dynamic" ? "none" : "block";
      e.ui.el.style.display = t, typeof l == "function" && l.call(e), e.trigger("hidden", e.instance);
    }, e.options.fadeTime), e.options.restJoystick) {
      const t = e.options.restJoystick, n = {};
      n.x = t === true || t.x !== false ? 0 : e.instance.frontPosition.x, n.y = t === true || t.y !== false ? 0 : e.instance.frontPosition.y, e.setPosition(l, n);
    }
    return e;
  };
  Vt.prototype.setPosition = function(l, e) {
    var t = this;
    t.frontPosition = {
      x: e.x,
      y: e.y
    };
    var n = t.options.fadeTime + "ms", i = {};
    i.front = lu("transition", [
      "transform"
    ], n);
    var s = {
      front: {}
    };
    s.front = {
      transform: "translate(" + t.frontPosition.x + "px," + t.frontPosition.y + "px)"
    }, t.applyStyles(i), t.applyStyles(s), t.restTimeout = setTimeout(function() {
      typeof l == "function" && l.call(t), t.restCallback();
    }, t.options.fadeTime);
  };
  Vt.prototype.restCallback = function() {
    var l = this, e = {};
    e.front = lu("transition", "none", ""), l.applyStyles(e), l.trigger("rested", l.instance);
  };
  Vt.prototype.resetDirection = function() {
    this.direction = {
      x: false,
      y: false,
      angle: false
    };
  };
  Vt.prototype.computeDirection = function(l) {
    var e = l.angle.radian, t = Math.PI / 4, n = Math.PI / 2, i, s, r;
    if (e > t && e < t * 3 && !l.lockX ? i = "up" : e > -t && e <= t && !l.lockY ? i = "left" : e > -t * 3 && e <= -t && !l.lockX ? i = "down" : l.lockY || (i = "right"), l.lockY || (e > -n && e < n ? s = "left" : s = "right"), l.lockX || (e > 0 ? r = "up" : r = "down"), l.force > this.options.threshold) {
      var a = {}, c;
      for (c in this.direction) this.direction.hasOwnProperty(c) && (a[c] = this.direction[c]);
      var u = {};
      this.direction = {
        x: s,
        y: r,
        angle: i
      }, l.direction = this.direction;
      for (c in a) a[c] === this.direction[c] && (u[c] = true);
      if (u.x && u.y && u.angle) return l;
      (!u.x || !u.y) && this.trigger("plain", l), u.x || this.trigger("plain:" + s, l), u.y || this.trigger("plain:" + r, l), u.angle || this.trigger("dir dir:" + i, l);
    } else this.resetDirection();
    return l;
  };
  function Pt(l, e) {
    var t = this;
    t.nipples = [], t.idles = [], t.actives = [], t.ids = [], t.pressureIntervals = {}, t.manager = l, t.id = Pt.id, Pt.id += 1, t.defaults = {
      zone: document.body,
      multitouch: false,
      maxNumberOfNipples: 10,
      mode: "dynamic",
      position: {
        top: 0,
        left: 0
      },
      catchDistance: 200,
      size: 100,
      threshold: 0.1,
      color: "white",
      fadeTime: 250,
      dataOnly: false,
      restJoystick: true,
      restOpacity: 0.5,
      lockX: false,
      lockY: false,
      shape: "circle",
      dynamicPage: false,
      follow: false
    }, t.config(e), (t.options.mode === "static" || t.options.mode === "semi") && (t.options.multitouch = false), t.options.multitouch || (t.options.maxNumberOfNipples = 1);
    const n = getComputedStyle(t.options.zone.parentElement);
    return n && n.display === "flex" && (t.parentIsFlex = true), t.updateBox(), t.prepareNipples(), t.bindings(), t.begin(), t.nipples;
  }
  Pt.prototype = new ai();
  Pt.constructor = Pt;
  Pt.id = 0;
  Pt.prototype.prepareNipples = function() {
    var l = this, e = l.nipples;
    e.on = l.on.bind(l), e.off = l.off.bind(l), e.options = l.options, e.destroy = l.destroy.bind(l), e.ids = l.ids, e.id = l.id, e.processOnMove = l.processOnMove.bind(l), e.processOnEnd = l.processOnEnd.bind(l), e.get = function(t) {
      if (t === void 0) return e[0];
      for (var n = 0, i = e.length; n < i; n += 1) if (e[n].identifier === t) return e[n];
      return false;
    };
  };
  Pt.prototype.bindings = function() {
    var l = this;
    l.bindEvt(l.options.zone, "start"), l.options.zone.style.touchAction = "none", l.options.zone.style.msTouchAction = "none";
  };
  Pt.prototype.begin = function() {
    var l = this, e = l.options;
    if (e.mode === "static") {
      var t = l.createNipple(e.position, l.manager.getIdentifier());
      t.add(), l.idles.push(t);
    }
  };
  Pt.prototype.createNipple = function(l, e) {
    var t = this, n = t.manager.scroll, i = {}, s = t.options, r = {
      x: t.parentIsFlex ? n.x : n.x + t.box.left,
      y: t.parentIsFlex ? n.y : n.y + t.box.top
    };
    if (l.x && l.y) i = {
      x: l.x - r.x,
      y: l.y - r.y
    };
    else if (l.top || l.right || l.bottom || l.left) {
      var a = document.createElement("DIV");
      a.style.display = "hidden", a.style.top = l.top, a.style.right = l.right, a.style.bottom = l.bottom, a.style.left = l.left, a.style.position = "absolute", s.zone.appendChild(a);
      var c = a.getBoundingClientRect();
      s.zone.removeChild(a), i = l, l = {
        x: c.left + n.x,
        y: c.top + n.y
      };
    }
    var u = new Vt(t, {
      color: s.color,
      size: s.size,
      threshold: s.threshold,
      fadeTime: s.fadeTime,
      dataOnly: s.dataOnly,
      restJoystick: s.restJoystick,
      restOpacity: s.restOpacity,
      mode: s.mode,
      identifier: e,
      position: l,
      zone: s.zone,
      frontPosition: {
        x: 0,
        y: 0
      },
      shape: s.shape
    });
    return s.dataOnly || (Kp(u.ui.el, i), Kp(u.ui.front, u.frontPosition)), t.nipples.push(u), t.trigger("added " + u.identifier + ":added", u), t.manager.trigger("added " + u.identifier + ":added", u), t.bindNipple(u), u;
  };
  Pt.prototype.updateBox = function() {
    var l = this;
    l.box = l.options.zone.getBoundingClientRect();
  };
  Pt.prototype.bindNipple = function(l) {
    var e = this, t, n = function(i, s) {
      t = i.type + " " + s.id + ":" + i.type, e.trigger(t, s);
    };
    l.on("destroyed", e.onDestroyed.bind(e)), l.on("shown hidden rested dir plain", n), l.on("dir:up dir:right dir:down dir:left", n), l.on("plain:up plain:right plain:down plain:left", n);
  };
  Pt.prototype.pressureFn = function(l, e, t) {
    var n = this, i = 0;
    clearInterval(n.pressureIntervals[t]), n.pressureIntervals[t] = setInterval((function() {
      var s = l.force || l.pressure || l.webkitForce || 0;
      s !== i && (e.trigger("pressure", s), n.trigger("pressure " + e.identifier + ":pressure", s), i = s);
    }).bind(n), 100);
  };
  Pt.prototype.onstart = function(l) {
    var e = this, t = e.options, n = l;
    l = $m(l), e.updateBox();
    var i = function(s) {
      e.actives.length < t.maxNumberOfNipples ? e.processOnStart(s) : n.type.match(/^touch/) && (Object.keys(e.manager.ids).forEach(function(r) {
        if (Object.values(n.touches).findIndex(function(c) {
          return c.identifier === r;
        }) < 0) {
          var a = [
            l[0]
          ];
          a.identifier = r, e.processOnEnd(a);
        }
      }), e.actives.length < t.maxNumberOfNipples && e.processOnStart(s));
    };
    return mh(l, i), e.manager.bindDocument(), false;
  };
  Pt.prototype.processOnStart = function(l) {
    var e = this, t = e.options, n, i = e.manager.getIdentifier(l), s = l.force || l.pressure || l.webkitForce || 0, r = {
      x: l.pageX,
      y: l.pageY
    }, a = e.getOrCreate(i, r);
    a.identifier !== i && e.manager.removeIdentifier(a.identifier), a.identifier = i;
    var c = function(p) {
      p.trigger("start", p), e.trigger("start " + p.id + ":start", p), p.show(), s > 0 && e.pressureFn(l, p, p.identifier), e.processOnMove(l);
    };
    if ((n = e.idles.indexOf(a)) >= 0 && e.idles.splice(n, 1), e.actives.push(a), e.ids.push(a.identifier), t.mode !== "semi") c(a);
    else {
      var u = za(r, a.position);
      if (u <= t.catchDistance) c(a);
      else {
        a.destroy(), e.processOnStart(l);
        return;
      }
    }
    return a;
  };
  Pt.prototype.getOrCreate = function(l, e) {
    var t = this, n = t.options, i;
    return /(semi|static)/.test(n.mode) ? (i = t.idles[0], i ? (t.idles.splice(0, 1), i) : n.mode === "semi" ? t.createNipple(e, l) : (console.warn("Coudln't find the needed nipple."), false)) : (i = t.createNipple(e, l), i);
  };
  Pt.prototype.processOnMove = function(l) {
    var e = this, t = e.options, n = e.manager.getIdentifier(l), i = e.nipples.get(n), s = e.manager.scroll;
    if (!eT(l)) {
      this.processOnEnd(l);
      return;
    }
    if (!i) {
      console.error("Found zombie joystick with ID " + n), e.manager.removeIdentifier(n);
      return;
    }
    if (t.dynamicPage) {
      var r = i.el.getBoundingClientRect();
      i.position = {
        x: s.x + r.left,
        y: s.y + r.top
      };
    }
    i.identifier = n;
    var a = i.options.size / 2, c = {
      x: l.pageX,
      y: l.pageY
    };
    t.lockX && (c.y = i.position.y), t.lockY && (c.x = i.position.x);
    var u = za(c, i.position), p = ZE(c, i.position), f = fh(p), m = u / a, v = {
      distance: u,
      position: c
    }, b, _;
    if (i.options.shape === "circle" ? (b = Math.min(u, a), _ = JE(i.position, b, p)) : (_ = iT(c, i.position, a), b = za(_, i.position)), t.follow) {
      if (u > a) {
        let y = c.x - _.x, M = c.y - _.y;
        i.position.x += y, i.position.y += M, i.el.style.top = i.position.y - (e.box.top + s.y) + "px", i.el.style.left = i.position.x - (e.box.left + s.x) + "px", u = za(c, i.position);
      }
    } else c = _, u = b;
    var x = c.x - i.position.x, w = c.y - i.position.y;
    i.frontPosition = {
      x,
      y: w
    }, t.dataOnly || (i.ui.front.style.transform = "translate(" + x + "px," + w + "px)");
    var S = {
      identifier: i.identifier,
      position: c,
      force: m,
      pressure: l.force || l.pressure || l.webkitForce || 0,
      distance: u,
      angle: {
        radian: f,
        degree: p
      },
      vector: {
        x: x / a,
        y: -w / a
      },
      raw: v,
      instance: i,
      lockX: t.lockX,
      lockY: t.lockY
    };
    S = i.computeDirection(S), S.angle = {
      radian: fh(180 - p),
      degree: 180 - p
    }, i.trigger("move", S), e.trigger("move " + i.id + ":move", S);
  };
  Pt.prototype.processOnEnd = function(l) {
    var e = this, t = e.options, n = e.manager.getIdentifier(l), i = e.nipples.get(n), s = e.manager.removeIdentifier(i.identifier);
    i && (t.dataOnly || i.hide(function() {
      t.mode === "dynamic" && (i.trigger("removed", i), e.trigger("removed " + i.id + ":removed", i), e.manager.trigger("removed " + i.id + ":removed", i), i.destroy());
    }), clearInterval(e.pressureIntervals[i.identifier]), i.resetDirection(), i.trigger("end", i), e.trigger("end " + i.id + ":end", i), e.ids.indexOf(i.identifier) >= 0 && e.ids.splice(e.ids.indexOf(i.identifier), 1), e.actives.indexOf(i) >= 0 && e.actives.splice(e.actives.indexOf(i), 1), /(semi|static)/.test(t.mode) ? e.idles.push(i) : e.nipples.indexOf(i) >= 0 && e.nipples.splice(e.nipples.indexOf(i), 1), e.manager.unbindDocument(), /(semi|static)/.test(t.mode) && (e.manager.ids[s.id] = s.identifier));
  };
  Pt.prototype.onDestroyed = function(l, e) {
    var t = this;
    t.nipples.indexOf(e) >= 0 && t.nipples.splice(t.nipples.indexOf(e), 1), t.actives.indexOf(e) >= 0 && t.actives.splice(t.actives.indexOf(e), 1), t.idles.indexOf(e) >= 0 && t.idles.splice(t.idles.indexOf(e), 1), t.ids.indexOf(e.identifier) >= 0 && t.ids.splice(t.ids.indexOf(e.identifier), 1), t.manager.removeIdentifier(e.identifier), t.manager.unbindDocument();
  };
  Pt.prototype.destroy = function() {
    var l = this;
    l.unbindEvt(l.options.zone, "start"), l.nipples.forEach(function(t) {
      t.destroy();
    });
    for (var e in l.pressureIntervals) l.pressureIntervals.hasOwnProperty(e) && clearInterval(l.pressureIntervals[e]);
    l.trigger("destroyed", l.nipples), l.manager.unbindDocument(), l.off();
  };
  function Wt(l) {
    var e = this;
    e.ids = {}, e.index = 0, e.collections = [], e.scroll = jp(), e.config(l), e.prepareCollections();
    var t = function() {
      var i;
      e.collections.forEach(function(s) {
        s.forEach(function(r) {
          i = r.el.getBoundingClientRect(), r.position = {
            x: e.scroll.x + i.left,
            y: e.scroll.y + i.top
          };
        });
      });
    };
    qa(window, "resize", function() {
      qp(t);
    });
    var n = function() {
      e.scroll = jp();
    };
    return qa(window, "scroll", function() {
      qp(n);
    }), e.collections;
  }
  Wt.prototype = new ai();
  Wt.constructor = Wt;
  Wt.prototype.prepareCollections = function() {
    var l = this;
    l.collections.create = l.create.bind(l), l.collections.on = l.on.bind(l), l.collections.off = l.off.bind(l), l.collections.destroy = l.destroy.bind(l), l.collections.get = function(e) {
      var t;
      return l.collections.every(function(n) {
        return t = n.get(e), !t;
      }), t;
    };
  };
  Wt.prototype.create = function(l) {
    return this.createCollection(l);
  };
  Wt.prototype.createCollection = function(l) {
    var e = this, t = new Pt(e, l);
    return e.bindCollection(t), e.collections.push(t), t;
  };
  Wt.prototype.bindCollection = function(l) {
    var e = this, t, n = function(i, s) {
      t = i.type + " " + s.id + ":" + i.type, e.trigger(t, s);
    };
    l.on("destroyed", e.onDestroyed.bind(e)), l.on("shown hidden rested dir plain", n), l.on("dir:up dir:right dir:down dir:left", n), l.on("plain:up plain:right plain:down plain:left", n);
  };
  Wt.prototype.bindDocument = function() {
    var l = this;
    l.binded || (l.bindEvt(document, "move").bindEvt(document, "end"), l.binded = true);
  };
  Wt.prototype.unbindDocument = function(l) {
    var e = this;
    (!Object.keys(e.ids).length || l === true) && (e.unbindEvt(document, "move").unbindEvt(document, "end"), e.binded = false);
  };
  Wt.prototype.getIdentifier = function(l) {
    var e;
    return l ? (e = l.identifier === void 0 ? l.pointerId : l.identifier, e === void 0 && (e = this.latest || 0)) : e = this.index, this.ids[e] === void 0 && (this.ids[e] = this.index, this.index += 1), this.latest = e, this.ids[e];
  };
  Wt.prototype.removeIdentifier = function(l) {
    var e = {};
    for (var t in this.ids) if (this.ids[t] === l) {
      e.id = t, e.identifier = this.ids[t], delete this.ids[t];
      break;
    }
    return e;
  };
  Wt.prototype.onmove = function(l) {
    var e = this;
    return e.onAny("move", l), false;
  };
  Wt.prototype.onend = function(l) {
    var e = this;
    return e.onAny("end", l), false;
  };
  Wt.prototype.oncancel = function(l) {
    var e = this;
    return e.onAny("end", l), false;
  };
  Wt.prototype.onAny = function(l, e) {
    var t = this, n, i = "processOn" + l.charAt(0).toUpperCase() + l.slice(1);
    e = $m(e);
    var s = function(a, c, u) {
      u.ids.indexOf(c) >= 0 && (u[i](a), a._found_ = true);
    }, r = function(a) {
      n = t.getIdentifier(a), mh(t.collections, s.bind(null, a, n)), a._found_ || t.removeIdentifier(n);
    };
    return mh(e, r), false;
  };
  Wt.prototype.destroy = function() {
    var l = this;
    l.unbindDocument(true), l.ids = {}, l.index = 0, l.collections.forEach(function(e) {
      e.destroy();
    }), l.off();
  };
  Wt.prototype.onDestroyed = function(l, e) {
    var t = this;
    if (t.collections.indexOf(e) < 0) return false;
    t.collections.splice(t.collections.indexOf(e), 1);
  };
  const Yp = new Wt(), aT = {
    create: function(l) {
      return Yp.create(l);
    },
    factory: Yp
  };
  var gt;
  class lT {
    constructor() {
      this.startListening(), this.inputStore = We, this.keyPressed = {}, ho.subscribe((e) => {
        this.nipple = e.nippleReady, console.log(e.nippleReady), this.nipple == true && this.createNipple();
      });
    }
    createNipple() {
      gt = aT.create({
        zone: document.getElementById("space"),
        mode: "dynamic",
        position: {
          left: "100px",
          top: "100px"
        },
        follow: false
      });
      var e = "";
      gt.on("move", function(t, n) {
        gt.position = n.position, gt.distance = n.distance, gt.direction = n.angle.radian, console.log(gt.distance);
        var i = 6.279201325062565;
        gt.direction >= 5.755934547974017 && gt.direction <= i || gt.direction >= 0 && gt.direction <= 0.5232667770885471 ? (console.log("right"), e != "r" && (We.setState({
          forward: false
        }), We.setState({
          left: false
        }), We.setState({
          backward: false
        }), We.setState({
          right: true
        }), e = "r")) : gt.direction >= 0.5232667770885471 && gt.direction <= 1.046533554177094 ? (console.log("right + up"), e != "ru" && (We.setState({
          left: false
        }), We.setState({
          backward: false
        }), We.setState({
          right: true
        }), We.setState({
          forward: true
        }), e = "ru")) : gt.direction >= 1.046533554177094 && gt.direction <= 2.093067108354188 ? (console.log("up"), e != "u" && (We.setState({
          right: false
        }), We.setState({
          left: false
        }), We.setState({
          backward: false
        }), We.setState({
          forward: true
        }), e = "u")) : gt.direction >= 2.093067108354188 && gt.direction <= 2.616333885442735 ? (console.log("left + up"), e != "lu" && (We.setState({
          right: false
        }), We.setState({
          backward: false
        }), We.setState({
          forward: true
        }), We.setState({
          left: true
        }), e = "lu")) : gt.direction >= 2.616333885442735 && gt.direction <= 3.662867439619829 ? (console.log("left"), e != "l" && (We.setState({
          right: false
        }), We.setState({
          forward: false
        }), We.setState({
          backward: false
        }), We.setState({
          left: true
        }), e = "l")) : gt.direction >= 3.662867439619829 && gt.direction <= 4.186134216708376 ? (console.log("left + bottom"), e != "lb" && (We.setState({
          right: false
        }), We.setState({
          forward: false
        }), We.setState({
          left: true
        }), We.setState({
          backward: true
        }), e = "lb")) : gt.direction >= 4.186134216708376 && gt.direction <= 5.23266777088547 ? (console.log("bottom"), e != "b" && (We.setState({
          right: false
        }), We.setState({
          forward: false
        }), We.setState({
          left: false
        }), We.setState({
          backward: true
        }), e = "b")) : gt.direction >= 5.23266777088547 && gt.direction <= 5.755934547974017 && (console.log("right + bottom"), e != "rb" && (We.setState({
          forward: false
        }), We.setState({
          left: false
        }), We.setState({
          backward: true
        }), We.setState({
          right: true
        }), e = "rb"));
      }), gt.on("end", function(t, n) {
        We.setState({
          right: false
        }), We.setState({
          forward: false
        }), We.setState({
          left: false
        }), We.setState({
          backward: false
        });
      });
    }
    startListening() {
      window.addEventListener("keydown", (e) => this.onKeyDown(e)), window.addEventListener("keyup", (e) => this.onKeyUp(e));
    }
    onKeyDown(e) {
      if (!this.keyPressed[e.code]) {
        switch (e.code) {
          case "KeyW":
          case "ArrowUp":
            console.log("forward"), We.setState({
              forward: true
            });
            break;
          case "KeyA":
          case "ArrowLeft":
            We.setState({
              left: true
            });
            break;
          case "KeyS":
          case "ArrowDown":
            We.setState({
              backward: true
            });
            break;
          case "KeyD":
          case "ArrowRight":
            We.setState({
              right: true
            });
            break;
        }
        this.keyPressed[e.code] = true;
      }
    }
    onKeyUp(e) {
      switch (e.code) {
        case "KeyW":
        case "ArrowUp":
          We.setState({
            forward: false
          });
          break;
        case "KeyA":
        case "ArrowLeft":
          We.setState({
            left: false
          });
          break;
        case "KeyS":
        case "ArrowDown":
          We.setState({
            backward: false
          });
          break;
        case "KeyD":
        case "ArrowRight":
          We.setState({
            right: false
          });
          break;
      }
      this.keyPressed[e.code] = false;
    }
  }
  let Tc = null;
  class Ln {
    constructor() {
      if (Tc) return Tc;
      Tc = this, this.canvas = document.querySelector("canvas.threejs"), this.scene = new Dh(), this.gui = new iE(), this.assetLoader = new YE(), this.preloader = new $E(), this.inputController = new lT(), this.world = new fE(), this.camera = new J1(), this.renderer = new Q1(), this.loop = new eE(), this.resize = new mE();
    }
  }
  const cT = !!document.querySelector("canvas.threejs");
  cT && new Ln();
  function hT() {
    try {
      return localStorage.getItem("theme");
    } catch {
      return null;
    }
  }
  function uT(l) {
    try {
      localStorage.setItem("theme", l);
    } catch {
    }
  }
  function dT() {
    return typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
  }
  function Jm(l) {
    document.documentElement.classList.toggle("dark", l);
    const e = (t) => {
      if (!t) return;
      t.setAttribute("aria-pressed", l ? "true" : "false");
      const n = t.querySelector(".sun"), i = t.querySelector(".moon");
      n && i && (n.classList.toggle("hidden", l), i.classList.toggle("hidden", !l));
    };
    e(document.getElementById("theme-toggle")), e(document.getElementById("theme-toggle-mobile"));
  }
  function pT() {
    const l = hT(), e = l ? l === "dark" : dT();
    Jm(e);
  }
  function fT() {
    const l = document.getElementById("mobile-menu-toggle"), e = document.getElementById("mobile-menu");
    !l || !e || l.addEventListener("click", () => {
      const t = e.classList.contains("hidden");
      e.classList.toggle("hidden"), l.setAttribute("aria-expanded", t ? "true" : "false");
    });
  }
  pT();
  window.addEventListener("DOMContentLoaded", () => {
    fT();
    const l = () => {
      const n = !document.documentElement.classList.contains("dark");
      Jm(n), uT(n ? "dark" : "light");
    }, e = document.getElementById("theme-toggle"), t = document.getElementById("theme-toggle-mobile");
    e && e.addEventListener("click", l), t && t.addEventListener("click", l);
  });
  async function mT() {
    const l = document.getElementById("avatarPortrait");
    if (!l) return;
    const [{ WebGLRenderer: e, Scene: t, PerspectiveCamera: n, Color: i, sRGBEncoding: s, ACESFilmicToneMapping: r, AmbientLight: a, DirectionalLight: c, Box3: u, Vector3: p }, { GLTFLoader: f }, { DRACOLoader: m }] = await Promise.all([
      Ua(() => Promise.resolve().then(() => Y1), void 0, import.meta.url),
      Ua(() => Promise.resolve().then(() => XE), void 0, import.meta.url),
      Ua(() => Promise.resolve().then(() => KE), void 0, import.meta.url)
    ]), v = new e({
      canvas: l,
      antialias: true,
      alpha: true
    });
    v.outputEncoding = s, v.toneMapping = r, v.setClearColor(new i(0, 0, 0), 0);
    const b = new t(), _ = new n(30, 1, 0.1, 100);
    b.add(new a(16777215, 0.6));
    const x = new c(16777215, 1);
    x.position.set(2, 3, 4), b.add(x);
    const w = new m();
    w.setDecoderPath("/draco/");
    const S = new f();
    S.setDRACOLoader(w);
    let y;
    await new Promise((Y, z) => {
      S.load("/models/avatar.glb", (B) => {
        y = B.scene, b.add(y), Y();
      }, void 0, z);
    });
    const M = new u().setFromObject(y), C = new p(), R = new p();
    M.getSize(C), M.getCenter(R);
    const L = Math.max(C.x, C.y, C.z) / (2 * Math.tan(Math.PI * _.fov / 360)) * 1.4;
    _.position.set(R.x, R.y + C.y * 0.1, R.z + L), _.lookAt(R), y.position.sub(R);
    function F() {
      const Y = Math.min(window.devicePixelRatio || 1, 2), z = l.clientWidth || 180, B = l.clientHeight || 180;
      (l.width !== Math.round(z * Y) || l.height !== Math.round(B * Y)) && (v.setPixelRatio(Y), v.setSize(z, B, false), _.aspect = z / B, _.updateProjectionMatrix());
    }
    function j() {
      F(), y && (y.rotation.y += 5e-3), v.render(b, _), requestAnimationFrame(j);
    }
    j();
  }
  window.addEventListener("DOMContentLoaded", () => {
    mT();
  });
})();
